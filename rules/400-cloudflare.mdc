---
title: Cloudflare Ruleset Engineering Guide
description: End-to-end prompts and patterns for designing, testing, and deploying Cloudflare rulesets (WAF, Rate Limiting, Transform, Workers integration).
priority: 400
alwaysApply: false
files:
  include:
    - "**/*.tf"
    - "wrangler.toml"
    - "**/*.workers.js"
    - "**/*.workers.ts"
    - "**/*.cf.mdc"
---

# Cloudflare Ruleset Engineering Guide

**Goal:** Build secure, performant, maintainable Cloudflare rulesets that protect applications while maintaining excellent user experience.

## Cloudflare Ruleset Philosophy

**Guiding Principles:**

- **Naming Consistency**: Never use `CloudFlare` anywhere (code/documentation). If any existing docs contain it, flag and fix to `Cloudflare`
- **Terminology Consistency**: Do not use the word `Domain` for Cloudflare. Always use `Zone`. If any existing docs mention “Cloudflare Domain”, flag and fix to “Cloudflare Zone”
- **Performance First**: Order conditions from fast to slow (IP/host/method → path/headers → body/regex)
- **Security by Default**: Assume hostile intent; validate and sanitize all inputs
- **Fail Securely**: Block by default, allow explicitly; log everything
- **User Experience**: Use challenges before blocks; provide clear error messages
- **Operational Excellence**: Test thoroughly, deploy gradually, monitor continuously
- **Cost Awareness**: Minimize expensive operations (body inspection, regex); use Workers for complex logic

**Core Tenets:**

1. **Fast Evaluation Order**: Cheap checks (IP, host, method) before expensive ones (body, regex)
2. **Defense in Depth**: Multiple layers of protection (WAF → Rate Limiting → Bot Management)
3. **Zero Trust**: Never trust user input; validate and sanitize everything
4. **Observability**: Log all actions; monitor effectiveness; alert on anomalies
5. **Iterative Improvement**: Start with log-only, refine based on data, then enforce

**Applying Cloudflare Philosophy:**

```javascript
// BAD: Expensive operations first
(http.request.body.raw contains "malicious" and http.host eq "api.acme.com")

// GOOD: Fast checks first, short-circuit early
(http.host eq "api.acme.com" and http.request.body.raw contains "malicious")

// BAD: Trusting user input
http.request.uri.path contains "/admin"

// GOOD: Zero trust - validate and sanitize
(
  lower(http.request.uri.path) contains "/admin" or
  lower(urldecode(http.request.uri.path)) contains "/admin" or
  lower(urldecode(urldecode(http.request.uri.path))) contains "/admin"
)

// BAD: Block immediately (poor UX)
(http.request.uri.path contains "/api/" and rate(ip.src, 1m) > 100)
# Action: Block

// GOOD: Challenge first, then block (better UX)
(http.request.uri.path contains "/api/" and rate(ip.src, 1m) > 100)
# Action: Managed Challenge
# If challenge fails → Block
```

---

## Quick Reference

### Essential Commands

> [!CAUTION]
> **Remote/stateful operations:** `terraform apply` and `wrangler publish` modify remote infrastructure/state.
> Run only with explicit approval and prefer `terraform plan` / `wrangler dev` first.

```bash
# Terraform
terraform plan                                    # Preview
terraform apply                                   # Deploy
terraform state list                              # List resources

# Cloudflare API
export CF_API_TOKEN="your_token"
curl -X GET "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/rulesets" \
  -H "Authorization: Bearer $CF_API_TOKEN"

# Workers
wrangler dev                                      # Test locally
wrangler publish                                  # Deploy
```

### Critical Patterns
```javascript
//  GOOD: Fast to slow evaluation order
(
  http.request.method eq "POST" and              // Fast: method
  http.host eq "api.acme.com" and            // Fast: host
  starts_with(http.request.uri.path, "/admin") and  // Medium: path
  not ip.src in {1.1.1.0/24}                    // Fast: IP
)

//  GOOD: Use 'in' for multiple values
http.host in {"api.acme.com" "admin.acme.com"}
//  BAD: Multiple OR
http.host eq "api.acme.com" or http.host eq "admin.acme.com"

//  GOOD: Case-insensitive with encoding checks
(
  lower(http.request.uri.path) contains "/admin" or
  lower(urldecode(http.request.uri.path)) contains "/admin"
)
```

### Field Performance Tiers
```
Fast: ip.src, http.host, http.request.method
Medium: http.request.uri.path, headers, cf.threat_score
Expensive: http.request.body, matches (regex)
```

---

##  Meta-Prompt (How to Use This Guide)

```
You are an expert Cloudflare engineer. Use this guide to help me create, optimize, test, and deploy Cloudflare rules for my requirement: **[Insert requirement]**

Follow these phases:
1. Discovery & Planning
2. Rule Generation
3. Optimization
4. Security Hardening
5. Testing & Validation
6. Deployment
7. Workers Integration
8. Multi-Environment Management
9. CI/CD Integration
10. Incident Response

For each phase, show your work and provide a final production-ready rule with deployment recommendations.
```

---

##  Phase 1: Discovery & Planning

### 1) Requirements Analysis (Prompt)
> Analyze the requirement and identify:
> 1. Primary security/business objective
> 2. Edge cases / exceptions
> 3. Traffic volume / performance constraints
> 4. Interaction with existing rules (phase/order)
> 5. Compliance/audit needs

### 2) Rule Type Selection (Prompt)
> Recommend the optimal product/rule type (with trade-offs):
> - **WAF Custom Rules** (`http_request_firewall_custom`)
> - **Rate Limiting Rules** (`http_ratelimit`)
> - **Transform Rules** (URI/path/header edits, redirects)
> - **Bot Management** signals (allowlist verified bots, score gates)
> - **Workers** (complex, stateful or body-inspection logic)

---

##  Phase 2: Rule Generation

### 3) Generate from Policy (Prompt + Pattern)
> Create a Cloudflare expression for: **[Policy]**
> Use `in` sets, clear grouping, and comments.

```javascript
# Admin panel protection
(
  http.host in {"admin.acme.com" "manage.acme.com"} and
  starts_with(http.request.uri.path, "/admin/") and
  not (ip.src in {10.0.0.0/8 192.168.0.0/16} or cf.tls_client_auth.cert_verified)
)
```

### 4) Smart Regex (Prompt)
> Generate an optimized regex for **[field]**; prefer non-regex when possible. Include test cases.

### 5) Geo + AS Nuance (Prompt)
> Build a geo/ASN rule that blocks high-risk regions and known hostile ASNs, with bypasses for verified bots/VPN scenarios.

### 6) API Protection (Prompt + Pattern)
```javascript
# API hardening for /api/v2/*
(
  starts_with(http.request.uri.path, "/api/v2/") and
  (
    (http.request.method in {"POST" "PUT"} and
     not lower(http.request.headers["content-type"][0]) contains "application/json") or
    (http.request.body.size > 10485760) or  # 10MB limit
    (http.request.headers["x-api-key"][0] eq "" or
     not http.request.headers["x-api-key"][0] matches "^[A-Za-z0-9]{32}$")
  )
)
```

---

## Phase 3: Optimization

### 7) Performance Ordering (Prompt)
> Reorder cheap checks first (IP, host, method), then path/header, and use regex last. Short-circuit for early exits.

**Example:**
```javascript
//  BAD: Expensive first
(http.request.body.raw contains "x" and http.host eq "acme.com")

//  GOOD: Fast first
(http.host eq "acme.com" and contains(http.request.body.raw, "x"))
```

### 8) Readability Pass (Prompt)
> Add comments, group parenthesis, and standard indentation.

### 9) Consolidate Redundancy (Prompt)
> Merge rules with common predicates; keep separate if operational clarity/ownership needs require it.

## Advanced Patterns

### Dynamic Rule Generation

**Pattern:** Generate rules programmatically for multiple endpoints or environments.

```hcl
# Terraform: Generate rules for multiple API endpoints
locals {
  api_endpoints = [
    "/api/v1/users",
    "/api/v1/orders",
    "/api/v1/payments"
  ]

  rate_limit_rules = [
    for endpoint in local.api_endpoints : {
      description = "Rate limit ${endpoint}"
      expression  = "(starts_with(http.request.uri.path, \"${endpoint}\") and rate(ip.src, 1m) > 100)"
      action      = "managed_challenge"
    }
  ]
}

resource "cloudflare_ruleset" "api_rate_limit" {
  zone_id = var.zone_id
  name    = "API Rate Limiting"
  kind    = "zone"
  phase   = "http_ratelimit"

  dynamic "rules" {
    for_each = local.rate_limit_rules
    content {
      description = rules.value.description
      enabled     = true
      action      = rules.value.action
      expression  = rules.value.expression
    }
  }
}
```

### Conditional Actions Based on Threat Score

**Pattern:** Escalate actions based on threat intelligence.

```javascript
// Tier 1: Low threat - log only
(cf.threat_score ge 1 and cf.threat_score lt 10)
# Action: Log

// Tier 2: Medium threat - challenge
(cf.threat_score ge 10 and cf.threat_score lt 30)
# Action: Managed Challenge

// Tier 3: High threat - block
(cf.threat_score ge 30)
# Action: Block
```

### Multi-Factor Authentication Bypass

**Pattern:** Allow verified bots and authenticated users to bypass rate limits.

```javascript
(
  http.request.uri.path contains "/api/" and
  rate(ip.src, 1m) > 100 and
  not (
    cf.bot_management.verified_bot or
    http.request.headers["authorization"][0] matches "^Bearer [A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+$"
  )
)
# Action: Managed Challenge
```

### Geographic Rate Limiting

**Pattern:** Different rate limits for different regions.

```javascript
// High-risk regions: stricter limits
(
  http.request.uri.path contains "/api/" and
  ip.geoip.country in {"CN" "RU" "KP"} and
  rate(ip.src, 1m) > 10
)
# Action: Block

// Low-risk regions: standard limits
(
  http.request.uri.path contains "/api/" and
  not ip.geoip.country in {"CN" "RU" "KP"} and
  rate(ip.src, 1m) > 100
)
# Action: Managed Challenge
```

### Request Size Validation

**Pattern:** Block oversized requests before they consume resources.

```javascript
(
  http.request.method in {"POST" "PUT" "PATCH"} and
  (
    http.request.body.size > 10485760 or  # 10MB limit
    http.request.headers["content-length"][0] matches "^[1-9][0-9]{7,}$"  # > 10MB
  )
)
# Action: Block
```

### Header Injection Prevention

**Pattern:** Prevent CRLF injection and header manipulation.

```javascript
(
  http.request.headers["x-forwarded-for"][0] matches "[\\r\\n]" or
  http.request.headers["user-agent"][0] matches "[\\r\\n]" or
  http.request.uri.query contains "%0d%0a"
)
# Action: Block
```

## Performance Optimization

### Evaluation Cost Reduction

**Minimize expensive operations:**

```javascript
// BAD: Multiple regex operations
(
  http.request.uri.path matches "^/api/v[0-9]+/users$" and
  http.request.uri.query matches ".*id=[0-9]+.*" and
  http.request.body.raw matches ".*email.*"
)

// GOOD: Use faster operators when possible
(
  starts_with(http.request.uri.path, "/api/v") and
  http.request.uri.path contains "/users" and
  http.request.uri.query contains "id=" and
  http.request.body.raw contains "email"
)

// BAD: Body inspection for simple checks
(http.request.body.raw contains "admin")

// GOOD: Use path/header checks when possible
(http.request.uri.path contains "/admin" or http.request.headers["x-role"][0] eq "admin")
```

### Rule Consolidation

**Merge similar rules to reduce evaluation overhead:**

```javascript
// BAD: Multiple separate rules
(http.host eq "api.acme.com" and http.request.uri.path eq "/v1/users")
(http.host eq "api.acme.com" and http.request.uri.path eq "/v1/orders")
(http.host eq "api.acme.com" and http.request.uri.path eq "/v1/payments")

// GOOD: Single consolidated rule
(
  http.host eq "api.acme.com" and
  http.request.uri.path in {"/v1/users" "/v1/orders" "/v1/payments"} and
  rate(ip.src, 1m) > 100
)
```

### Caching Strategy

**Use Workers KV for expensive lookups:**

```javascript
// Workers: Cache IP reputation lookups
export default {
  async fetch(request, env) {
    const ip = request.headers.get('CF-Connecting-IP');

    // Check cache first
    const cached = await env.IP_REPUTATION_KV.get(ip);
    if (cached) {
      const data = JSON.parse(cached);
      if (data.threat_score > 30) {
        return new Response('Blocked', { status: 403 });
      }
    }

    // Expensive lookup (external API)
    const reputation = await checkIPReputation(ip);

    // Cache for 1 hour
    await env.IP_REPUTATION_KV.put(ip, JSON.stringify(reputation), {
      expirationTtl: 3600
    });

    return fetch(request);
  }
};
```

### Workers vs Rules Decision Matrix

**Use Rules when:**
- Simple request filtering
- Rate limiting
- Header/path manipulation
- IP/geo blocking
- Bot score gating

**Use Workers when:**
- Response body inspection
- External API calls
- Stateful logic (KV/Durable Objects)
- Complex JSON manipulation
- Custom authentication flows
- Expensive computations

## Testing Strategies

### Unit Testing Rules

**Test rule expressions in isolation:**

```bash
# Test rule logic with curl
# Should match (block)
curl -X POST https://api.acme.com/admin \
  -H "Host: admin.acme.com" \
  -H "X-Forwarded-For: 1.1.1.1" \
  -d "malicious=payload"
# Expected: 403

# Should not match (allow)
curl -X GET https://api.acme.com/admin \
  -H "Host: admin.acme.com" \
  -H "X-Forwarded-For: 10.0.0.1" \
  -H "Authorization: Bearer valid-token"
# Expected: 200
```

### Integration Testing

**Test rules in staging environment:**

```yaml
# GitHub Actions: Test rules before production
name: Test Cloudflare Rules

on: [pull_request]

jobs:
  test-rules:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Deploy to staging
        run: terraform apply -auto-approve -var-file=staging.tfvars

      - name: Run test suite
        run: |
          ./scripts/test-rules.sh staging

      - name: Validate rule effectiveness
        run: |
          python scripts/validate_rules.py \
            --zone-id ${{ secrets.CF_STAGING_ZONE_ID }} \
            --ruleset-id ${{ secrets.CF_STAGING_RULESET_ID }}
```

### Performance Testing

**Measure rule evaluation time:**

```bash
# Benchmark rule performance
for i in {1..1000}; do
  curl -s -o /dev/null -w "%{time_total}\n" \
    -H "Host: api.acme.com" \
    https://edge.acme.com/api/test
done | awk '{sum+=$1; count++} END {print "Average:", sum/count}'
```

### Security Testing

**Test bypass attempts:**

```bash
# Test encoding bypasses
curl "https://api.acme.com/%2561dmin"  # Double URL encoding
curl "https://api.acme.com/%2Fadmin"   # Path encoding
curl "https://api.acme.com/admin%2F"   # Trailing slash encoding

# Test case sensitivity
curl "https://api.acme.com/ADMIN"
curl "https://api.acme.com/Admin"

# Test header injection
curl -H "X-Forwarded-For: 1.1.1.1\r\nX-Admin: true" https://api.acme.com/
```

## Troubleshooting & Debugging

### Rule Not Triggering

**Diagnosis Steps:**

1. **Check rule order:**
   ```bash
   # List rules in order
   curl -X GET \
     "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/rulesets/phases/http_request_firewall_custom/entrypoint" \
     -H "Authorization: Bearer $CF_API_TOKEN" | jq '.result.rules[] | {id, description, enabled, action}'
   ```

2. **Verify rule is enabled:**
   ```bash
   # Check specific rule
   curl -X GET \
     "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/rulesets/$RULESET_ID/rules/$RULE_ID" \
     -H "Authorization: Bearer $CF_API_TOKEN"
   ```

3. **Test with simpler expression:**
   ```javascript
   // Start simple
   (http.host eq "api.acme.com")

   // Then add conditions incrementally
   (http.host eq "api.acme.com" and http.request.method eq "POST")
   ```

4. **Check field names (case-sensitive):**
   ```javascript
   // BAD: Wrong case
   http.request.uri.Path contains "/admin"

   // GOOD: Correct case
   http.request.uri.path contains "/admin"
   ```

### False Positives

**Common Causes & Fixes:**

1. **Missing bypass for verified bots:**
   ```javascript
   // BAD: Blocks legitimate bots
   (http.request.uri.path contains "/api/" and rate(ip.src, 1m) > 100)

   // GOOD: Allow verified bots
   (
     http.request.uri.path contains "/api/" and
     rate(ip.src, 1m) > 100 and
     not cf.bot_management.verified_bot
   )
   ```

2. **Case-sensitive matching:**
   ```javascript
   // BAD: Case sensitive
   http.request.uri.path contains "/Admin"

   // GOOD: Case insensitive
   lower(http.request.uri.path) contains "/admin"
   ```

3. **Missing IP allowlist:**
   ```javascript
   // Add allowlist for known good IPs
   (
     http.request.uri.path contains "/admin" and
     not ip.src in {1.1.1.0/24 10.0.0.0/8}
   )
   ```

### Performance Issues

**Symptoms & Solutions:**

1. **High evaluation time:**
   - Reorder conditions (fast → slow)
   - Replace regex with simpler operators
   - Remove body inspection (use Workers)

2. **Rule evaluation timeout:**
   - Split complex rule into multiple simpler rules
   - Move complex logic to Workers

3. **High API costs:**
   - Minimize regex operations
   - Use `in` sets instead of multiple `or` conditions
   - Cache expensive lookups in Workers KV

### Terraform State Issues

**Common Problems:**

1. **State lock:**
   ```bash
   # Force unlock (use with caution)
   terraform force-unlock <LOCK_ID>
   ```

2. **State drift:**
   ```bash
   # Refresh state
   terraform refresh

   # Import existing resources
   terraform import cloudflare_ruleset.waf_custom <ruleset_id>
   ```

3. **State conflicts:**
   ```bash
   # Use remote state backend
   terraform {
     backend "s3" {
       bucket = "terraform-state"
       key    = "cloudflare/rulesets.tfstate"
       region = "us-east-1"
     }
   }
   ```

---

##  Phase 4: Security Hardening

### 10) Bypass Analysis (Prompt + Hardened Pattern)
```javascript
//  VULNERABLE: Case sensitive, single encoding
http.request.uri.path contains "/admin"

//  HARDENED: Case insensitive, multiple encoding
(
  lower(http.request.uri.path) contains "/admin" or
  lower(urldecode(http.request.uri.path)) contains "/admin" or
  lower(urldecode(urldecode(http.request.uri.path))) contains "/admin"
)
```

### 11) Rate Limiting Strategy (Prompt)
> Define per-IP, per-key/JWT, and endpoint-tier limits; specify increment conditions and bypasses.

**Tiered Rate Limiting:**
```javascript
# Tier 1: Per-IP (basic protection)
(http.request.uri.path contains "/api/" and rate(ip.src, 1m) > 100)

# Tier 2: Per API key (distributed attack protection)
(http.request.uri.path contains "/api/" and
 rate(http.request.headers["x-api-key"][0], 10m) > 5000)

# Tier 3: Global endpoint (expensive operations)
(http.request.uri.path eq "/api/v2/search" and rate(http.host, 1m) > 10000)
```

### 12) Bot Management (Prompt)
> Gate by `cf.bot_management.score`, allow verified bots, challenge suspicious automation.

### 13) DLP Helpers (Prompt)
> Request-side rules to prevent leaking tokens/PANs in query/paths; note response scanning needs DLP features or Workers.

---

##  Phase 5: Testing & Validation

### 14) Test Case Generator (Prompt)
> Produce **positive/negative/edge/security/perf** cases (curl or API format) for the rule.

**Example Tests:**
```bash
# Should block
curl -H "Host: admin.acme.com" https://edge.acme.com/dashboard
# Expected: 403

# Should allow
curl -H "X-Forwarded-For: 1.1.1.1" https://admin.acme.com/dashboard
# Expected: 200

# Security test (encoding bypass)
curl https://edge.acme.com/%2561dmin
# Expected: 403
```

### 15) Logic Validator (Prompt)
> Double-check operator precedence (**AND** before **OR**), null header handling, and field existence.

**Common Logic Errors:**
```javascript
//  BAD: Precedence issue
A or B and C  // Interpreted as: A or (B and C)

//  GOOD: Explicit parentheses
(A or B) and C

//  BAD: Null header not handled
http.request.headers["x-api-key"][0] eq "secret"

//  GOOD: Check existence
(http.request.headers["x-api-key"][0] ne "" and
 http.request.headers["x-api-key"][0] eq "secret")
```

### 16) Monitoring Queries (Prompt + Pattern)
```graphql
# Monitor rule effectiveness
{
  viewer {
    zones(filter: {zoneTag: "xxx"}) {
      firewallEventsAdaptive(
        filter: { ruleId: "rule_123", datetime_geq: "2024-01-01T00:00:00Z" }
        limit: 100
      ) {
        action
        clientIP
        userAgent
        clientCountryName
      }
    }
  }
}
```

---

##  Phase 6: Deployment & Ops

### 17) IaC / API Conversion (Prompt + Terraform & API)

**Terraform:**
```hcl
resource "cloudflare_ruleset" "waf_custom" {
  zone_id = var.zone_id
  name    = "WAF Custom Rules"
  kind    = "zone"
  phase   = "http_request_firewall_custom"

  rules {
    description = "Admin protection: VPN or mTLS"
    enabled     = true
    action      = "block"
    expression  = <<-EOT
      (
        http.host in {"admin.acme.com"} and
        not ip.src in {1.1.1.0/24}
      )
    EOT

    action_parameters {
      response {
        status_code  = 403
        content      = "Access Denied"
        content_type = "text/plain"
      }
    }
  }
}
```

**API:**
```bash
curl -X POST \
  "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/rulesets" \
  -H "Authorization: Bearer $CF_API_TOKEN" \
  -d '{"action":"block","expression":"...","description":"Admin block"}'
```

### 18) Staged Rollout (Prompt)
> Log-only -> Managed Challenge -> Block; narrow by path/geo; define rollback triggers & SLOs.

**Rollout Phases:**
```
Phase 1: Log (Week 1) - Identify FPs
Phase 2: Challenge (Week 2) - Validate solve rate
Phase 3: Regional Block (Week 3) - 50% traffic
Phase 4: Full Block (Week 4) - 100% traffic
```

### 19) Runbook (Prompt)
> Purpose, dependencies, normal/abnormal metrics, common FPs, emergency disable, escalation contacts, related rules.

### 20) Cost Analysis (Prompt)
> Estimate evaluation cost; reduce regex/body checks; consider Workers for heavy logic; evaluate plan-tier trade-offs.

---

##  Phase 7: Workers Integration

### 21) When to Use Workers vs Rules
**Use Workers if:**
- Need response body inspection
- External API calls required
- Stateful logic (KV/Durable Objects)
- Complex JSON manipulation
- Custom authentication flows

**Use Rules if:**
- Simple request filtering
- Rate limiting
- Header/path manipulation
- Bot score gating
- IP/geo blocking

### 22) Workers Pattern
```javascript
// Complex authentication with Workers
export default {
  async fetch(request, env) {
    const url = new URL(request.url);

    if (url.pathname.startsWith('/admin')) {
      const token = request.headers.get('Authorization')?.replace('Bearer ', '');
      if (!token) return new Response('Unauthorized', { status: 401 });

      const isValid = await verifyJWT(token, env.JWT_SECRET);
      if (!isValid) return new Response('Invalid token', { status: 403 });

      const user = await env.USERS_KV.get(token, { type: 'json' });
      if (!user?.isAdmin) return new Response('Not an admin', { status: 403 });
    }

    return fetch(request);
  }
};
```

---

##  Phase 8: Multi-Environment Management

### 23) Environment Strategy
```hcl
# Environment-specific behavior
locals {
  rule_action = {
    dev        = "log"              # Dev: Log only
    staging    = "managed_challenge" # Staging: Challenge
    production = "block"             # Prod: Block
  }
}

resource "cloudflare_ruleset" "admin" {
  zone_id = var.zone_ids[var.environment]

  rules {
    action      = local.rule_action[var.environment]
    expression  = file("rules/admin_protection.txt")
    description = "Admin VPN enforcement [${var.environment}]"
  }
}
```

### 24) Feature Flags
```hcl
variable "feature_flags" {
  type = map(bool)
  default = {
    admin_vpn_enforcement = true
    api_rate_limiting     = true
    geo_blocking_apac     = false  # Waiting approval
  }
}

dynamic "rules" {
  for_each = var.feature_flags.admin_vpn_enforcement ? [1] : []
  content {
    action = "block"
    expression = "(http.host eq \"admin.acme.com\" and not ip.src in {1.1.1.0/24})"
  }
}
```

---

##  Phase 9: CI/CD Integration

### 25) GitHub Actions Workflow
```yaml
name: Cloudflare Rules CI

on: [push, pull_request]

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v3
      - run: terraform fmt -check
      - run: terraform validate
      - run: python scripts/validate_rules.py rules/**/*.txt

  plan:
    needs: validate
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v3
      - run: terraform plan -no-color
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CF_API_TOKEN }}

  deploy:
    needs: plan
    if: github.ref == 'refs/heads/main'
    environment: production
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v3
      - run: terraform apply -auto-approve
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CF_API_TOKEN_PROD }}
```

---

##  Security Hardening

### Bypass Protection Patterns
```javascript
//  HARDENED: Multiple encoding + case insensitive
(
  lower(http.request.uri.path) contains "/admin" or
  lower(urldecode(http.request.uri.path)) contains "/admin" or
  lower(urldecode(urldecode(http.request.uri.path))) contains "/admin"
)

//  HARDENED: Prevent header injection
(
  http.request.headers["x-custom"][0] ne "" and
  not http.request.headers["x-custom"][0] matches "[\\r\\n]"  // Block CRLF
)
```

---

##  Monitoring & Analytics

### GraphQL Queries
```graphql
# Rule effectiveness
{
  viewer {
    zones(filter: {zoneTag: "xxx"}) {
      firewallEventsAdaptive(
        filter: { ruleId: "rule_123" }
        limit: 100
      ) {
        action
        clientIP
        clientCountryName
      }
    }
  }
}
```

### Alerts
```yaml
# Prometheus alerting
- alert: HighRuleBlockRate
  expr: rate(cloudflare_firewall_events_total{action="block"}[5m]) > 100
  for: 5m
  annotations:
    summary: "High block rate on rule {{ $labels.rule_id }}"
```

---

##  Incident Response

### Emergency Deployment
```bash
# EMERGENCY: Deploy rule in < 2 minutes
EXPRESSION='(http.request.uri.path eq "/api/login" and cf.threat_score gt 30)'

curl -X POST \
  "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/rulesets/phases/http_request_firewall_custom/entrypoint" \
  -H "Authorization: Bearer $CF_API_TOKEN" \
  -d "{\"rules\":[{\"expression\":\"$EXPRESSION\",\"action\":\"managed_challenge\"}]}"

# Monitor effectiveness
# Next: Refine based on FP rate
```

### Rollback Procedure
```bash
# Disable rule immediately
curl -X PATCH \
  "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/rulesets/$RULESET_ID/rules/$RULE_ID" \
  -H "Authorization: Bearer $CF_API_TOKEN" \
  -d '{"enabled": false}'

# Or change to log mode
curl -X PATCH \
  "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/rulesets/$RULESET_ID/rules/$RULE_ID" \
  -H "Authorization: Bearer $CF_API_TOKEN" \
  -d '{"action": "log"}'
```

---

##  Troubleshooting

### Common Issues

**Rule Not Triggering:**
1. Check if rule is enabled
2. Verify rule order (earlier rules catch first)
3. Test with simpler expression
4. Check field names (case-sensitive)

**Blocking Legitimate Traffic:**
1. Add bypass for verified bots
2. Change Block -> Managed Challenge
3. Add allowlist for known IPs
4. Use case-insensitive matching

**Performance Issues:**
1. Reorder conditions (fast -> slow)
2. Replace regex with simpler operators
3. Remove body inspection (use Workers)
4. Split complex rule into multiple

**Terraform Failures:**
1. Unlock state: `terraform force-unlock <ID>`
2. Import existing: `terraform import cloudflare_ruleset.x <id>`
3. Refresh state: `terraform apply -refresh-only`

---

##  Example Library

### E-commerce Checkout
```javascript
(
  http.host eq "shop.acme.com" and
  http.request.uri.path in {"/checkout" "/payment"} and
  (
    (cf.bot_management.score lt 30 and not cf.bot_management.verified_bot) or
    (not ip.geoip.country in {"US" "CA" "GB"}) or
    (rate(ip.src, 10m) > 20)
  )
)
# Action: Managed Challenge
```

### API Gateway Auth
```javascript
(
  starts_with(http.request.uri.path, "/api/") and
  not (
    http.request.headers["authorization"][0] matches
      "^Bearer [A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+$" or
    http.request.headers["x-api-key"][0] in {"key_abc123" "key_def456"} or
    (ip.src in {10.0.0.0/8} and http.request.headers["x-service-name"][0] ne "")
  )
)
# Action: Block
```

### WordPress Hardening
```javascript
(
  (contains(lower(http.request.uri.path), "wp-admin") and not ip.src in {1.1.1.0/24}) or
  (http.request.uri.path contains "wp-content/uploads" and
   http.request.uri.path matches "\\.(php|phtml|php5)$") or
  (http.request.uri.path eq "/xmlrpc.php" and http.request.method eq "POST") or
  (http.request.uri.query contains "author=")
)
```

### GraphQL Protection
```javascript
(
  http.request.uri.path eq "/graphql" and
  (
    http.request.body.size > 5000 or
    http.request.body.raw matches "\\{[^}]*\\{[^}]*\\{[^}]*\\{" or  # 4+ nesting
    (http.request.body.raw contains "__schema" and not ip.src in {10.0.0.0/8})
  )
)
```

---

## Comprehensive Example: E-Commerce Platform Protection

**Scenario:** Protect an e-commerce platform with multiple layers of security.

### Requirements

- Protect admin panel (VPN/mTLS only)
- Rate limit API endpoints
- Block high-risk regions
- Protect checkout flow from bots
- Monitor and alert on attacks

### Complete Terraform Configuration

```hcl
# terraform/cloudflare-rulesets/main.tf

terraform {
  required_providers {
    cloudflare = {
      source  = "cloudflare/cloudflare"
      version = "~> 5.14"
    }
  }
}

variable "zone_id" {
  description = "Cloudflare Zone ID"
  type        = string
}

variable "environment" {
  description = "Environment (dev, staging, production)"
  type        = string
  default     = "production"
}

locals {
  # Environment-specific actions
  rule_actions = {
    dev        = "log"
    staging    = "managed_challenge"
    production = "block"
  }

  # Admin IP allowlist
  admin_ips = {
    dev        = ["10.0.0.0/8"]
    staging    = ["10.0.0.0/8", "192.168.0.0/16"]
    production = ["1.1.1.0/24", "10.0.0.0/8"]
  }

  # High-risk countries
  high_risk_countries = ["CN", "RU", "KP", "IR"]
}

# WAF Custom Rules
resource "cloudflare_ruleset" "waf_custom" {
  zone_id = var.zone_id
  name    = "E-Commerce WAF Rules"
  kind    = "zone"
  phase   = "http_request_firewall_custom"

  # Rule 1: Admin Panel Protection
  rules {
    description = "Admin panel: VPN or mTLS only"
    enabled     = true
    action      = local.rule_actions[var.environment]
    expression  = <<-EOT
      (
        http.host in {"admin.acme.com" "manage.acme.com"} and
        starts_with(http.request.uri.path, "/admin/") and
        not (
          ip.src in ${jsonencode(local.admin_ips[var.environment])} or
          cf.tls_client_auth.cert_verified
        )
      )
    EOT

    action_parameters {
      response {
        status_code  = 403
        content      = "Access Denied: Admin panel requires VPN or mTLS"
        content_type = "text/plain"
      }
    }
  }

  # Rule 2: API Authentication
  rules {
    description = "API: Require authentication"
    enabled     = true
    action      = "block"
    expression  = <<-EOT
      (
        starts_with(http.request.uri.path, "/api/v2/") and
        not (
          http.request.headers["authorization"][0] matches "^Bearer [A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+$" or
          http.request.headers["x-api-key"][0] in {"key_abc123" "key_def456"}
        )
      )
    EOT
  }

  # Rule 3: High-Risk Region Blocking
  rules {
    description = "Block high-risk regions"
    enabled     = var.environment == "production"
    action      = "block"
    expression  = <<-EOT
      (
        http.request.uri.path contains "/api/" and
        ip.geoip.country in ${jsonencode(local.high_risk_countries)} and
        not cf.bot_management.verified_bot
      )
    EOT
  }

  # Rule 4: Request Size Limit
  rules {
    description = "Block oversized requests"
    enabled     = true
    action      = "block"
    expression  = <<-EOT
      (
        http.request.method in {"POST" "PUT" "PATCH"} and
        http.request.body.size > 10485760
      )
    EOT
  }
}

# Rate Limiting Rules
resource "cloudflare_ruleset" "rate_limit" {
  zone_id = var.zone_id
  name    = "E-Commerce Rate Limiting"
  kind    = "zone"
  phase   = "http_ratelimit"

  # Rule 1: API Rate Limit (Per IP)
  rules {
    description = "API rate limit: 100 requests/minute per IP"
    enabled     = true
    action      = "managed_challenge"
    expression  = <<-EOT
      (
        starts_with(http.request.uri.path, "/api/") and
        rate(ip.src, 1m) > 100
      )
    EOT

    ratelimit {
      characteristics = ["ip.src"]
      period          = 60
      requests_per_period = 100
      mitigation_timeout = 600
    }
  }

  # Rule 2: Checkout Rate Limit (Stricter)
  rules {
    description = "Checkout rate limit: 10 requests/minute per IP"
    enabled     = true
    action      = "block"
    expression  = <<-EOT
      (
        http.request.uri.path in {"/checkout" "/payment"} and
        rate(ip.src, 1m) > 10
      )
    EOT

    ratelimit {
      characteristics = ["ip.src"]
      period          = 60
      requests_per_period = 10
      mitigation_timeout = 300
    }
  }

  # Rule 3: API Key Rate Limit (Distributed)
  rules {
    description = "API key rate limit: 5000 requests/10 minutes"
    enabled     = true
    action      = "block"
    expression  = <<-EOT
      (
        starts_with(http.request.uri.path, "/api/") and
        http.request.headers["x-api-key"][0] ne "" and
        rate(http.request.headers["x-api-key"][0], 10m) > 5000
      )
    EOT

    ratelimit {
      characteristics = ["http.request.headers[\"x-api-key\"][0]"]
      period          = 600
      requests_per_period = 5000
      mitigation_timeout = 3600
    }
  }
}

# Bot Management Rules
resource "cloudflare_ruleset" "bot_management" {
  zone_id = var.zone_id
  name    = "E-Commerce Bot Management"
  kind    = "zone"
  phase   = "http_request_firewall_custom"

  # Rule 1: Checkout Bot Protection
  rules {
    description = "Checkout: Block low bot score"
    enabled     = true
    action      = "managed_challenge"
    expression  = <<-EOT
      (
        http.request.uri.path in {"/checkout" "/payment"} and
        cf.bot_management.score lt 30 and
        not cf.bot_management.verified_bot
      )
    EOT
  }

  # Rule 2: API Bot Protection
  rules {
    description = "API: Challenge suspicious bots"
    enabled     = true
    action      = "managed_challenge"
    expression  = <<-EOT
      (
        starts_with(http.request.uri.path, "/api/") and
        cf.bot_management.score lt 20 and
        not cf.bot_management.verified_bot
      )
    EOT
  }
}
```

### Monitoring Dashboard

```graphql
# GraphQL: Monitor rule effectiveness
{
  viewer {
    zones(filter: {zoneTag: "xxx"}) {
      firewallEventsAdaptive(
        filter: {
          datetime_geq: "2024-01-01T00:00:00Z"
          action: "block"
        }
        limit: 1000
      ) {
        action
        clientIP
        clientCountryName
        ruleId
        source
        userAgent
      }
    }
  }
}
```

### Alerting Configuration

```yaml
# Prometheus: Alert on high block rate
groups:
  - name: cloudflare_rules
    rules:
      - alert: HighBlockRate
        expr: |
          rate(cloudflare_firewall_events_total{
            action="block",
            rule_id="admin_protection"
          }[5m]) > 10
        for: 5m
        annotations:
          summary: "High block rate on admin protection rule"
          description: "{{ $value }} blocks/minute on admin panel"

      - alert: RateLimitTriggered
        expr: |
          rate(cloudflare_rate_limit_events_total{
            action="managed_challenge"
          }[5m]) > 50
        for: 5m
        annotations:
          summary: "Rate limiting frequently triggered"
          description: "{{ $value }} rate limit challenges/minute"
```

### Deployment Workflow

```yaml
# GitHub Actions: Deploy rules with validation
name: Deploy Cloudflare Rules

on:
  push:
    branches: [main]
    paths:
      - 'terraform/cloudflare-rulesets/**'

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v3

      - name: Validate Terraform
        run: |
          cd terraform/cloudflare-rulesets
          terraform init
          terraform validate
          terraform fmt -check

      - name: Validate Rules
        run: |
          python scripts/validate_rules.py \
            --rules-dir terraform/cloudflare-rulesets/rules

  plan:
    needs: validate
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v3

      - name: Terraform Plan
        run: |
          cd terraform/cloudflare-rulesets
          terraform plan -out=tfplan
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CF_API_TOKEN }}

  deploy-staging:
    needs: plan
    if: github.ref == 'refs/heads/main'
    environment: staging
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v3

      - name: Deploy to Staging
        run: |
          cd terraform/cloudflare-rulesets
          terraform apply -auto-approve -var-file=staging.tfvars
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CF_STAGING_API_TOKEN }}

      - name: Run Tests
        run: ./scripts/test-rules.sh staging

  deploy-production:
    needs: deploy-staging
    if: github.ref == 'refs/heads/main'
    environment: production
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v3

      - name: Deploy to Production
        run: |
          cd terraform/cloudflare-rulesets
          terraform apply -auto-approve -var-file=production.tfvars
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CF_PROD_API_TOKEN }}
```

### Runbook

```markdown
# Admin Panel Protection Rule

## Purpose
Protect admin panel from unauthorized access. Only allows VPN IPs or mTLS clients.

## Dependencies
- VPN IP ranges configured in Terraform
- mTLS certificates configured in Cloudflare

## Normal Metrics
- Block rate: < 5/minute
- False positive rate: < 1%
- Response time impact: < 10ms

## Abnormal Metrics
- Block rate > 20/minute → Possible attack
- False positive rate > 5% → Rule too strict
- Response time impact > 50ms → Performance issue

## Common False Positives
- Legitimate admin users not on VPN
- Mobile admin access
- Third-party integrations

## Emergency Disable
```bash
curl -X PATCH \
  "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/rulesets/$RULESET_ID/rules/$RULE_ID" \
  -H "Authorization: Bearer $CF_API_TOKEN" \
  -d '{"enabled": false}'
```

## Escalation
- On-call engineer: +1-xxx-xxx-xxxx
- Security team: security@acme.com
```

---

## Final Checklist (Pre-Prod)

- [ ] Stakeholder/requirement sign-off
- [ ] Bypass analysis complete
- [ ] Perf order verified (cheap -> expensive)
- [ ] UX risk assessed + mitigations
- [ ] Tests (pos/neg/edge/security) pass
- [ ] Monitoring queries + dashboard ready
- [ ] Rollout plan + rollback ready
- [ ] Runbook updated
- [ ] Cost impact understood
- [ ] Multi-environment tested (dev -> staging -> prod)
- [ ] CI/CD pipeline validated
- [ ] Terraform state configured
- [ ] Security scanning passed
- [ ] Deployed in business hours with on-call

---

**Cloudflare API Version**: v4
**Terraform Provider Version**: >= 5.14
