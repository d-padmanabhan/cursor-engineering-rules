---
title: Go Engineering Ruleset
description: Secure, idiomatic, maintainable Go with evidence-based performance; applies to generation and review.
priority: 180
alwaysApply: false
files:
  include:
    - "**/*.go"
    - "go.mod"
    - "go.sum"
    - ".golangci.yml"
    - "Makefile"
    - ".github/workflows/go.yml"
---

# Go Engineering Ruleset - (December 2025)

**Audience**: engineers writing and reviewing Go code
**Goal**: secure, idiomatic, efficient, and highly maintainable Go - without over-engineering

**Core Philosophy**: Correctness & Safety  Simplicity & Maintainability  Evidence-Based Performance

---

## Quick Reference

### Essential Commands
```bash
# Module Management
go mod init <module>          # Initialize new module
go mod tidy                   # Add missing, remove unused
go test -race ./...          # Run with race detector
go test -cover ./...         # Show coverage
go test -bench=. -benchmem   # Benchmark with memory stats

# Quality & Linting
gofmt -s -w .                # Simplify and format
go vet ./...                 # Vet for suspicious constructs
staticcheck ./...            # Advanced static analysis
golangci-lint run            # Run all linters
govulncheck ./...            # Check vulnerabilities

# Profiling
go test -cpuprofile=cpu.prof -bench=.  # CPU profile
go tool pprof cpu.prof                  # Analyze profile
dlv debug                               # Start delve debugger
```

### Critical Patterns
```go
// 1. Always check errors
result, err := someFunc()
if err != nil {
    return fmt.Errorf("operation failed: %w", err)  //  Wrap with context
}

// 2. Use context for cancellation
func processData(ctx context.Context, data []string) error {
    for _, item := range data {
        select {
        case <-ctx.Done():
            return ctx.Err()  //  Respect cancellation
        default:
            // Process item
        }
    }
    return nil
}

// 3. Always manage goroutine lifecycle
var wg sync.WaitGroup
wg.Add(1)
go func() {
    defer wg.Done()  //  Always defer Done()
    // work here
}()
wg.Wait()

// 4. Defer cleanup immediately
file, err := os.Open("file.txt")
if err != nil {
    return err
}
defer file.Close()  //  Defer right after open

// 5. Use table-driven tests
func TestAdd(t *testing.T) {
    tests := []struct {
        name string
        a, b int
        want int
    }{
        {"positive", 1, 2, 3},
        {"negative", -1, -2, -3},
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            if got := Add(tt.a, tt.b); got != tt.want {
                t.Errorf("Add() = %v, want %v", got, tt.want)
            }
        })
    }
}
```

---

## 1. Correctness & Safety First

### Error Handling

```go
//  GOOD: Sentinel errors
var ErrNotFound = errors.New("not found")

//  GOOD: Custom error types
type ValidationError struct {
    Field string
    Issue string
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("validation failed on %s: %s", e.Field, e.Issue)
}

//  GOOD: Error wrapping
func processUser(id string) error {
    user, err := fetchUser(id)
    if err != nil {
        return fmt.Errorf("failed to process user %s: %w", id, err)
    }
    // ...
}

//  GOOD: Error checking
if errors.Is(err, ErrNotFound) { /* handle */ }
var valErr *ValidationError
if errors.As(err, &valErr) { /* handle */ }
```

### Context & Cancellation

```go
//  GOOD: Context as first parameter
func fetchUser(ctx context.Context, id string) (*User, error) {
    req, err := http.NewRequestWithContext(ctx, "GET", "/users/"+id, nil)
    // ...
}

//  GOOD: Check context in loops
func processItems(ctx context.Context, items []Item) error {
    for _, item := range items {
        select {
        case <-ctx.Done():
            return ctx.Err()
        default:
            if err := processItem(item); err != nil {
                return err
            }
        }
    }
    return nil
}
```

### Security

```go
//  GOOD: Input validation
func CreateUser(email string) error {
    if !isValidEmail(email) {
        return fmt.Errorf("invalid email: %w", ErrInvalidInput)
    }
}

//  GOOD: TLS configuration
tlsConfig := &tls.Config{
    MinVersion: tls.VersionTLS13,
}

//  GOOD: Parameterized queries
_, err := db.ExecContext(ctx, "INSERT INTO users (email) VALUES ($1)", email)
```

---

## 2. Simplicity & Idiomatic Go

### Design Principles

- **KISS/DRY/YAGNI**: Avoid speculative abstractions
- **Small Functions**: Do one thing well
- **Small Interfaces**: Define at the consumer
- **Composition First**: Prefer composing types

```go
//  GOOD: Small interface at consumer
type UserStore interface {
    GetUser(ctx context.Context, id string) (*User, error)
}

//  GOOD: Function options pattern
type ServerOption func(*ServerOptions)

func WithPort(port int) ServerOption {
    return func(o *ServerOptions) { o.Port = port }
}

func NewServer(opts ...ServerOption) *Server {
    cfg := ServerOptions{Port: 8080, Host: "localhost"}
    for _, opt := range opts {
        opt(&cfg)
    }
    return &Server{/* initialize */}
}
```

### Project Layout

```
project/
 cmd/
    server/main.go
    cli/main.go
 internal/
    auth/
    handler/
 pkg/
    models/
 go.mod
 go.sum
```

### Naming

- **`gofmt -s`**: Required
- **Imports**: Group as stdlib | third-party | internal
- **Exported**: PascalCase; unexported: camelCase
- **Acronyms**: Uppercase (`HTTPServer`, `UserID`)
- **Interfaces**: `-er` suffix (`Reader`, `Hasher`)

---

## 3. Concurrency

### Choose the Simplest Correct Primitive

```go
//  GOOD: Mutex for protecting shared state
type SafeCounter struct {
    mu    sync.Mutex
    count int
}

func (c *SafeCounter) Increment() {
    c.mu.Lock()
    c.count++
    c.mu.Unlock()
}

//  GOOD: Channel for communication
func worker(jobs <-chan Job, results chan<- Result) {
    for job := range jobs {
        results <- process(job)
    }
}

//  GOOD: sync.Once for initialization
var (
    instance *Singleton
    once     sync.Once
)

func GetInstance() *Singleton {
    once.Do(func() {
        instance = &Singleton{}
    })
    return instance
}
```

### Goroutine Management

```go
//  GOOD: errgroup for error propagation
import "golang.org/x/sync/errgroup"

func processFiles(ctx context.Context, files []string) error {
    g, ctx := errgroup.WithContext(ctx)
    g.SetLimit(10)  // Max 10 concurrent goroutines

    for _, file := range files {
        file := file
        g.Go(func() error {
            return processFile(ctx, file)
        })
    }

    return g.Wait()
}
```

### Race Safety

- **Required**: Code must pass `go test -race`
- **No Data Races**: Even "benign" ones

---

## 4. Performance (Evidence-Based Only)

### Measurement Required

```go
func BenchmarkProcessData(b *testing.B) {
    data := generateTestData()
    b.ResetTimer()
    b.ReportAllocs()

    for i := 0; i < b.N; i++ {
        ProcessData(data)
    }
}
```

### Memory Management

```go
//  GOOD: Preallocate slice
users := make([]User, 0, expectedCount)

//  GOOD: strings.Builder for concatenation
var sb strings.Builder
sb.Grow(estimatedSize)
for _, part := range parts {
    sb.WriteString(part)
}
result := sb.String()
```

---

## 5. Testing & Quality

### Test Structure

```go
//  GOOD: Table-driven test
func TestAdd(t *testing.T) {
    tests := []struct {
        name string
        a, b int
        want int
    }{
        {"positive", 1, 2, 3},
        {"negative", -1, -2, -3},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            t.Parallel()

            got := Add(tt.a, tt.b)
            if got != tt.want {
                t.Errorf("Add(%d, %d) = %d, want %d", tt.a, tt.b, got, tt.want)
            }
        })
    }
}

//  GOOD: Fuzz test
func FuzzParseURL(f *testing.F) {
    f.Add("https://acme.com")

    f.Fuzz(func(t *testing.T, url string) {
        _, err := ParseURL(url)
        _ = err  // Must not panic
    })
}
```

### CI Gates (Non-Negotiable)

```bash
gofmt -s -w .
go vet ./...
staticcheck ./...
golangci-lint run
go test -race ./...
govulncheck ./...
```

---

## 6. Common Mistakes & Anti-Patterns

### 1. Using Goroutines Without WaitGroup

```go
//  BAD: Fire-and-forget
func processItems(items []Item) {
    for _, item := range items {
        go process(item)  // No way to wait!
    }
}

//  GOOD: Use WaitGroup
func processItems(items []Item) {
    var wg sync.WaitGroup
    for _, item := range items {
        wg.Add(1)
        go func(item Item) {
            defer wg.Done()
            process(item)
        }(item)
    }
    wg.Wait()
}
```

### 2. Not Checking Error Returns

```go
//  BAD: Ignoring errors
result, _ := someFunc()

//  GOOD: Check errors
result, err := someFunc()
if err != nil {
    return fmt.Errorf("someFunc failed: %w", err)
}
```

### 3. Shadowing Variables with `:=`

```go
//  BAD: Shadowing err
result, err := step1()
if result.NeedsStep2 {
    result, err := step2()  // Shadows outer err!
}

//  GOOD: Reuse err
result, err := step1()
if result.NeedsStep2 {
    result, err = step2()  // Reuses outer err
}
```

### 4. Closing Channels from Receiver Side

```go
//  BAD: Receiver closes channel
func receiver(ch <-chan int) {
    for v := range ch {
        process(v)
    }
    close(ch)  // WRONG! Only sender should close
}

//  GOOD: Sender closes channel
func sender(ch chan<- int, values []int) {
    defer close(ch)
    for _, v := range values {
        ch <- v
    }
}
```

### 5. Global Mutable State

```go
//  BAD: Global mutable state
var cache = make(map[string]interface{})

func Get(key string) interface{} {
    return cache[key]  // Race!
}

//  GOOD: Encapsulated with mutex
type Cache struct {
    mu    sync.RWMutex
    items map[string]interface{}
}

func (c *Cache) Get(key string) (interface{}, bool) {
    c.mu.RLock()
    defer c.mu.RUnlock()
    val, ok := c.items[key]
    return val, ok
}
```

---

## 7. Troubleshooting Guide

### Debug Logging

```go
import "log/slog"

logger := slog.New(slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{
    Level: slog.LevelDebug,
}))

logger.Debug("processing user", "user_id", userID, "step", "validation")
```

### Using Delve

```bash
dlv debug ./cmd/myapp
dlv test ./pkg/mypackage
dlv attach <PID>

# Delve commands
(dlv) break main.main
(dlv) continue
(dlv) next
(dlv) print variable
(dlv) goroutines
```

### CPU Profiling

```bash
go test -cpuprofile=cpu.prof -bench=.
go tool pprof cpu.prof

# pprof commands
(pprof) top
(pprof) list functionName
(pprof) web
```

### Common Errors

**Nil Pointer**: Check nil before dereferencing
**Index Out of Range**: Check length before accessing
**Deadlock**: Ensure channels are closed
**Race Condition**: Run `go test -race`

---

## 8. CI/CD Integration

### GitHub Actions Example

```yaml
name: Go CI

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        go-version: ['1.24', '1.25']

    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version: ${{ matrix.go-version }}
          cache: true

      - run: go mod download
      - run: gofmt -s -l . | tee /dev/stderr | test -z "$(cat)"
      - run: go vet ./...
      - run: staticcheck ./...
      - run: golangci-lint run
      - run: go test -race -coverprofile=coverage.out ./...
      - run: govulncheck ./...
```

---

## 9. Advanced Patterns

### Fan-Out, Fan-In

```go
func fanOutFanIn(ctx context.Context, inputs []Input) ([]Result, error) {
    jobs := make(chan Input, len(inputs))
    results := make(chan Result, len(inputs))

    // Start workers
    var wg sync.WaitGroup
    for i := 0; i < runtime.NumCPU(); i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for input := range jobs {
                select {
                case results <- process(input):
                case <-ctx.Done():
                    return
                }
            }
        }()
    }

    // Send jobs and close
    go func() {
        for _, input := range inputs {
            jobs <- input
        }
        close(jobs)
    }()

    // Wait and close results
    go func() {
        wg.Wait()
        close(results)
    }()

    // Collect results
    var collected []Result
    for result := range results {
        collected = append(collected, result)
    }

    return collected, nil
}
```

### Rate Limiting

```go
type RateLimiter struct {
    rate     int
    tokens   chan struct{}
}

func NewRateLimiter(rate int) *RateLimiter {
    rl := &RateLimiter{
        rate:   rate,
        tokens: make(chan struct{}, rate),
    }
    for i := 0; i < rate; i++ {
        rl.tokens <- struct{}{}
    }
    return rl
}

func (rl *RateLimiter) Wait(ctx context.Context) error {
    select {
    case <-rl.tokens:
        return nil
    case <-ctx.Done():
        return ctx.Err()
    }
}
```

---

## 10. Documentation

- **Package Docs**: Capture purpose in `doc.go`
- **Exported Items**: Every exported item gets a comment
- **Concurrency Contracts**: Document goroutine-safety

```go
// Package user provides user management functionality.
package user

// User represents a user in the system.
type User struct {
    ID   string
    Name string
}

// GetUser retrieves a user by ID.
// It returns ErrNotFound if the user doesn't exist.
func GetUser(ctx context.Context, id string) (*User, error) {
    // ...
}
```

---

## Anti-Patterns (Automatic Rejection)

### Critical
-  Panic/recover as control flow
-  Goroutines without lifecycle management
-  Swallowed errors
-  Global mutable state
-  Logging secrets/PII

### Code Smells
-  Channels for simple mutual exclusion
-  Reflection/unsafe without benchmarks
-  "God" interfaces
-  Premature abstraction
-  Missing context propagation

---

**Context Matters**: These rules optimize for long-lived production services. A one-off script has different needs than a high-traffic API. Deviations are fine when justified and intentional.

**Go Version**: 1.25+
