---
title: Go Engineering Ruleset
description: Secure, idiomatic, maintainable Go with evidence-based performance; applies to generation and review.
priority: 180
alwaysApply: false
files:
  include:
    - "**/*.go"
    - "go.mod"
    - "go.sum"
    - ".golangci.yml"
    - "Makefile"
    - ".github/workflows/go.yml"
---

# Go Engineering Ruleset - (December 2025)

**Audience**: engineers writing and reviewing Go code
**Goal**: secure, idiomatic, efficient, and highly maintainable Go - without over-engineering

**Core Philosophy**: Correctness & Safety  Simplicity & Maintainability  Evidence-Based Performance

**Essential Reading:**
- [Go Proverbs](https://go-proverbs.github.io/) - Simple, poetic, pithy principles from Rob Pike
- [Effective Go](https://go.dev/doc/effective_go) - Official idiomatic Go guide (note: written in 2009, still valuable for language idioms)

---

## Go Proverbs (Core Principles)

These proverbs from Rob Pike guide idiomatic Go:

- **"Don't communicate by sharing memory, share memory by communicating"** - Use channels for coordination
- **"Concurrency is not parallelism"** - Concurrency is about structure, parallelism is about execution
- **"Channels orchestrate; mutexes serialize"** - Use channels for coordination, mutexes for mutual exclusion
- **"The bigger the interface, the weaker the abstraction"** - Keep interfaces small and focused
- **"Make the zero value useful"** - Types should work correctly when zero-initialized
- **"interface{} says nothing"** - Prefer specific types; use generics or type assertions when needed
- **"Gofmt's style is no one's favorite, yet gofmt is everyone's favorite"** - Always use `gofmt`
- **"A little copying is better than a little dependency"** - Prefer copying small code over adding dependencies
- **"Clear is better than clever"** - Readability over cleverness
- **"Reflection is never clear"** - Avoid reflection unless necessary
- **"Errors are values"** - Handle errors explicitly; don't ignore them
- **"Don't just check errors, handle them gracefully"** - Provide context and recovery paths
- **"Don't panic"** - Use errors, not panics, for normal error handling

---

## Quick Reference

### Essential Commands
```bash
# Module Management
go mod init <module>          # Initialize new module
go mod tidy                   # Add missing, remove unused
go test -race ./...          # Run with race detector
go test -cover ./...         # Show coverage
go test -bench=. -benchmem   # Benchmark with memory stats

# Quality & Linting
gofmt -s -w .                # Simplify and format
go vet ./...                 # Vet for suspicious constructs
staticcheck ./...            # Advanced static analysis
golangci-lint run            # Run all linters
govulncheck ./...            # Check vulnerabilities

# Profiling
go test -cpuprofile=cpu.prof -bench=.  # CPU profile
go tool pprof cpu.prof                  # Analyze profile
dlv debug                               # Start delve debugger
```

### Critical Patterns
```go
// 1. Always check errors
result, err := someFunc()
if err != nil {
    return fmt.Errorf("operation failed: %w", err)  //  Wrap with context
}

// 2. Use context for cancellation
func processData(ctx context.Context, data []string) error {
    for _, item := range data {
        select {
        case <-ctx.Done():
            return ctx.Err()  //  Respect cancellation
        default:
            // Process item
        }
    }
    return nil
}

// 3. Always manage goroutine lifecycle
var wg sync.WaitGroup
wg.Add(1)
go func() {
    defer wg.Done()  //  Always defer Done()
    // work here
}()
wg.Wait()

// 4. Defer cleanup immediately
file, err := os.Open("file.txt")
if err != nil {
    return err
}
defer file.Close()  //  Defer right after open

// 5. Use table-driven tests
func TestAdd(t *testing.T) {
    tests := []struct {
        name string
        a, b int
        want int
    }{
        {"positive", 1, 2, 3},
        {"negative", -1, -2, -3},
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            if got := Add(tt.a, tt.b); got != tt.want {
                t.Errorf("Add() = %v, want %v", got, tt.want)
            }
        })
    }
}
```

---

## 1. Correctness & Safety First

### Error Handling

**Proverb**: "Errors are values" and "Don't just check errors, handle them gracefully"

```go
//  GOOD: Sentinel errors
var ErrNotFound = errors.New("not found")

//  GOOD: Custom error types
type ValidationError struct {
    Field string
    Issue string
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("validation failed on %s: %s", e.Field, e.Issue)
}

//  GOOD: Error wrapping with context
func processUser(id string) error {
    user, err := fetchUser(id)
    if err != nil {
        return fmt.Errorf("failed to process user %s: %w", id, err)
    }
    // ...
}

//  GOOD: Error checking and handling
if errors.Is(err, ErrNotFound) {
    return nil  // Handle gracefully, don't just check
}
var valErr *ValidationError
if errors.As(err, &valErr) {
    log.Printf("validation error on %s: %s", valErr.Field, valErr.Issue)
    return fmt.Errorf("invalid input: %w", valErr)
}

//  GOOD: Errors as values - can be stored, passed, and composed
type ErrorHandler func(error) error

func withRetry(maxAttempts int) ErrorHandler {
    return func(err error) error {
        // Retry logic here
        return err
    }
}

//  BAD: Ignoring errors
result, _ := someFunc()  // Never ignore errors

//  BAD: Panic for normal errors
if err != nil {
    panic(err)  // Use errors, not panics
}
```

### Don't Panic

**Proverb**: "Don't panic"

Panics are for truly exceptional, unrecoverable situations (programming errors). Use errors for normal error handling.

```go
//  BAD: Panic for normal errors
func GetUser(id string) *User {
    user, err := fetchUser(id)
    if err != nil {
        panic(err)  // Wrong! Use errors
    }
    return user
}

//  GOOD: Return errors
func GetUser(id string) (*User, error) {
    user, err := fetchUser(id)
    if err != nil {
        return nil, fmt.Errorf("failed to get user %s: %w", id, err)
    }
    return user, nil
}

//  GOOD: Panic only for programming errors (unrecoverable)
func MustGetUser(id string) *User {
    user, err := fetchUser(id)
    if err != nil {
        panic(fmt.Sprintf("programming error: user %s must exist", id))
    }
    return user
}

//  GOOD: Recover only at package boundaries (main, HTTP handlers)
func httpHandler(w http.ResponseWriter, r *http.Request) {
    defer func() {
        if r := recover(); r != nil {
            log.Printf("panic recovered: %v", r)
            http.Error(w, "internal server error", http.StatusInternalServerError)
        }
    }()
    // Handler logic
}

//  BAD: Recover in library code
func libraryFunction() {
    defer func() {
        recover()  // Libraries should return errors, not recover
    }()
}
```

### Context & Cancellation

```go
//  GOOD: Context as first parameter
func fetchUser(ctx context.Context, id string) (*User, error) {
    req, err := http.NewRequestWithContext(ctx, "GET", "/users/"+id, nil)
    // ...
}

//  GOOD: Check context in loops
func processItems(ctx context.Context, items []Item) error {
    for _, item := range items {
        select {
        case <-ctx.Done():
            return ctx.Err()
        default:
            if err := processItem(item); err != nil {
                return err
            }
        }
    }
    return nil
}
```

### Security

```go
//  GOOD: Input validation
func CreateUser(email string) error {
    if !isValidEmail(email) {
        return fmt.Errorf("invalid email: %w", ErrInvalidInput)
    }
}

//  GOOD: TLS configuration
tlsConfig := &tls.Config{
    MinVersion: tls.VersionTLS13,
}

//  GOOD: Parameterized queries
_, err := db.ExecContext(ctx, "INSERT INTO users (email) VALUES ($1)", email)
```

---

## 2. Simplicity & Idiomatic Go

### Design Principles

- **KISS/DRY/YAGNI**: Avoid speculative abstractions
- **Small Functions**: Do one thing well
- **Small Interfaces**: Define at the consumer ("The bigger the interface, the weaker the abstraction")
- **Composition First**: Prefer composing types
- **Make the Zero Value Useful**: Types should work correctly when zero-initialized
- **A Little Copying is Better Than a Little Dependency**: Prefer copying small, stable code over adding dependencies

### Dependency Management

**Proverb**: "A little copying is better than a little dependency"

```go
//  BAD: Adding dependency for simple utility
import "github.com/some/lib/stringutils"

func process(s string) string {
    return stringutils.TrimAndLower(s)  // Dependency for 10 lines of code
}

//  GOOD: Copy small, stable utility code
func trimAndLower(s string) string {
    return strings.ToLower(strings.TrimSpace(s))
}

func process(s string) string {
    return trimAndLower(s)
}

//  GOOD: Use stdlib when possible
import (
    "strings"
    "fmt"
    "time"
)

//  BAD: External dependency for what stdlib provides
import "github.com/lib/timeutils"  // When time package works fine

//  GOOD: Add dependency only when:
//  - Functionality is complex (crypto, networking, parsing)
//  - Maintenance burden is high
//  - Code is large (>100 lines)
//  - It's a well-maintained, stable library
```

### Make the Zero Value Useful

**Proverb**: "Make the zero value useful"

```go
//  GOOD: Zero value is useful
type Buffer struct {
    data []byte
}

func (b *Buffer) Write(p []byte) (int, error) {
    b.data = append(b.data, p...)
    return len(p), nil
}

// Can use without initialization:
var buf Buffer
buf.Write([]byte("hello"))  // Works!

//  GOOD: Zero value for sync primitives
var mu sync.Mutex
mu.Lock()  // Zero value mutex is ready to use

//  GOOD: Zero value for slices and maps
var users []User  // nil slice, safe to append
var cache map[string]int  // nil map, but must initialize before use

//  BAD: Zero value requires initialization to be safe
type Server struct {
    port int  // Zero value (0) is invalid!
}

func NewServer(port int) *Server {
    if port == 0 {
        panic("port required")  // Zero value not useful
    }
    return &Server{port: port}
}

//  GOOD: Zero value is safe
type Server struct {
    port int
}

func NewServer() *Server {
    return &Server{port: 8080}  // Sensible default
}

func (s *Server) SetPort(port int) {
    s.port = port
}
```

```go
//  GOOD: Small interface at consumer
type UserStore interface {
    GetUser(ctx context.Context, id string) (*User, error)
}

//  GOOD: Function options pattern
type ServerOption func(*ServerOptions)

func WithPort(port int) ServerOption {
    return func(o *ServerOptions) { o.Port = port }
}

func NewServer(opts ...ServerOption) *Server {
    cfg := ServerOptions{Port: 8080, Host: "localhost"}
    for _, opt := range opts {
        opt(&cfg)
    }
    return &Server{/* initialize */}
}
```

### Clear is Better Than Clever

**Proverb**: "Clear is better than clever"

```go
//  BAD: Clever but unclear
func process(data interface{}) interface{} {
    switch v := data.(type) {
    case int:
        return v * 2
    case string:
        return len(v)
    default:
        return nil
    }
}

//  GOOD: Clear and explicit
func DoubleInt(n int) int {
    return n * 2
}

func StringLength(s string) int {
    return len(s)
}

//  BAD: Clever one-liner
result := strings.Join([]string{strings.TrimSpace(s1), strings.TrimSpace(s2)}, ",")

//  GOOD: Clear and readable
s1Trimmed := strings.TrimSpace(s1)
s2Trimmed := strings.TrimSpace(s2)
result := strings.Join([]string{s1Trimmed, s2Trimmed}, ",")

//  BAD: Clever but confusing
func find(items []Item, fn func(Item) bool) *Item {
    for i := range items {
        if fn(items[i]) {
            return &items[i]
        }
    }
    return nil
}

//  GOOD: Clear intent
func FindItem(items []Item, predicate func(Item) bool) *Item {
    for i := range items {
        if predicate(items[i]) {
            return &items[i]
        }
    }
    return nil
}
```

### Avoid interface{} When Possible

**Proverb**: "interface{} says nothing"

```go
//  BAD: interface{} loses type safety
func Process(data interface{}) error {
    // Must use type assertions everywhere
    switch v := data.(type) {
    case string:
        // ...
    case int:
        // ...
    }
}

//  GOOD: Use generics (Go 1.18+)
func Process[T any](data T) error {
    // Type-safe, no assertions needed
    // ...
}

//  GOOD: Use specific types
func ProcessString(s string) error { /* ... */ }
func ProcessInt(n int) error { /* ... */ }

//  GOOD: Use type constraints for flexibility
type Numeric interface {
    ~int | ~int64 | ~float64
}

func Sum[T Numeric](items []T) T {
    var sum T
    for _, item := range items {
        sum += item
    }
    return sum
}
```

### Project Layout

```
project/
 cmd/
    server/main.go
    cli/main.go
 internal/
    auth/
    handler/
 pkg/
    models/
 go.mod
 go.sum
```

### Naming

**Effective Go**: Names are important and have semantic effect (visibility).

- **`gofmt -s`**: Required ("Gofmt's style is no one's favorite, yet gofmt is everyone's favorite")
- **Imports**: Group as stdlib | third-party | internal
- **Exported**: PascalCase; unexported: camelCase
- **Acronyms**: Uppercase (`HTTPServer`, `UserID`)
- **Interfaces**: `-er` suffix (`Reader`, `Hasher`) - keep interfaces small ("The bigger the interface, the weaker the abstraction")
- **Package names**: Lowercase, single-word, concise (`bytes`, `ring`, not `bytesPackage` or `ringPackage`)
- **Getters**: Don't use `Get` prefix (`Owner()`, not `GetOwner()`)

```go
//  GOOD: Package name is concise
package user  // Not userPackage or userManagement

//  GOOD: Exported type uses package name context
type User struct {  // Users see it as user.User
    name string  // unexported field
}

//  GOOD: Getter without "Get" prefix (Effective Go)
func (u *User) Name() string {  // Not GetName()
    return u.name
}

//  GOOD: Setter can use "Set" prefix
func (u *User) SetName(name string) {
    u.name = name
}

//  GOOD: Small interface at consumer
type Reader interface {  // Small, focused
    Read([]byte) (int, error)
}

//  BAD: Large interface ("The bigger the interface, the weaker the abstraction")
type Everything interface {
    Read([]byte) (int, error)
    Write([]byte) (int, error)
    Close() error
    Flush() error
    Seek(int64, int) (int64, error)
    // ... too many methods
}

//  GOOD: Avoid interface{} - use generics or specific types
func Process[T any](items []T) {  // Generic, type-safe
    // ...
}

//  BAD: interface{} says nothing
func Process(items []interface{}) {  // No type safety
    // ...
}
```

---

## 3. Concurrency

**Proverbs**:
- "Don't communicate by sharing memory, share memory by communicating"
- "Channels orchestrate; mutexes serialize"
- "Concurrency is not parallelism"

### Choose the Simplest Correct Primitive

**Rule**: Use channels for coordination/orchestration, mutexes for mutual exclusion.

```go
//  GOOD: Mutex for protecting shared state (serialization)
type SafeCounter struct {
    mu    sync.Mutex
    count int
}

func (c *SafeCounter) Increment() {
    c.mu.Lock()
    defer c.mu.Unlock()  // Always use defer
    c.count++
}

//  GOOD: Channel for communication/orchestration
func worker(jobs <-chan Job, results chan<- Result) {
    for job := range jobs {
        results <- process(job)
    }
}

//  GOOD: Channel for coordination (orchestration)
func processWithCoordination(ctx context.Context, items []Item) error {
    done := make(chan error, 1)
    go func() {
        // Process items
        done <- nil
    }()

    select {
    case err := <-done:
        return err
    case <-ctx.Done():
        return ctx.Err()
    }
}

//  BAD: Using channel for simple mutual exclusion
type Counter struct {
    ch chan int  // Overkill for simple counter
}

//  GOOD: Mutex for simple mutual exclusion
type Counter struct {
    mu sync.Mutex
    count int
}

//  GOOD: sync.Once for one-time initialization
var (
    instance *Singleton
    once     sync.Once
)

func GetInstance() *Singleton {
    once.Do(func() {
        instance = &Singleton{}
    })
    return instance
}
```

### Goroutine Management

```go
//  GOOD: errgroup for error propagation
import "golang.org/x/sync/errgroup"

func processFiles(ctx context.Context, files []string) error {
    g, ctx := errgroup.WithContext(ctx)
    g.SetLimit(10)  // Max 10 concurrent goroutines

    for _, file := range files {
        file := file
        g.Go(func() error {
            return processFile(ctx, file)
        })
    }

    return g.Wait()
}
```

### Race Safety

- **Required**: Code must pass `go test -race`
- **No Data Races**: Even "benign" ones

---

## 4. Performance (Evidence-Based Only)

### Measurement Required

```go
func BenchmarkProcessData(b *testing.B) {
    data := generateTestData()
    b.ResetTimer()
    b.ReportAllocs()

    for i := 0; i < b.N; i++ {
        ProcessData(data)
    }
}
```

### Memory Management

```go
//  GOOD: Preallocate slice
users := make([]User, 0, expectedCount)

//  GOOD: strings.Builder for concatenation
var sb strings.Builder
sb.Grow(estimatedSize)
for _, part := range parts {
    sb.WriteString(part)
}
result := sb.String()
```

---

## 5. Testing & Quality

### Test Structure

```go
//  GOOD: Table-driven test
func TestAdd(t *testing.T) {
    tests := []struct {
        name string
        a, b int
        want int
    }{
        {"positive", 1, 2, 3},
        {"negative", -1, -2, -3},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            t.Parallel()

            got := Add(tt.a, tt.b)
            if got != tt.want {
                t.Errorf("Add(%d, %d) = %d, want %d", tt.a, tt.b, got, tt.want)
            }
        })
    }
}

//  GOOD: Fuzz test
func FuzzParseURL(f *testing.F) {
    f.Add("https://acme.com")

    f.Fuzz(func(t *testing.T, url string) {
        _, err := ParseURL(url)
        _ = err  // Must not panic
    })
}
```

### CI Gates (Non-Negotiable)

```bash
gofmt -s -w .
go vet ./...
staticcheck ./...
golangci-lint run
go test -race ./...
govulncheck ./...
```

---

## 6. Common Mistakes & Anti-Patterns

### 1. Using Goroutines Without WaitGroup

```go
//  BAD: Fire-and-forget
func processItems(items []Item) {
    for _, item := range items {
        go process(item)  // No way to wait!
    }
}

//  GOOD: Use WaitGroup
func processItems(items []Item) {
    var wg sync.WaitGroup
    for _, item := range items {
        wg.Add(1)
        go func(item Item) {
            defer wg.Done()
            process(item)
        }(item)
    }
    wg.Wait()
}
```

### 2. Not Checking Error Returns

```go
//  BAD: Ignoring errors
result, _ := someFunc()

//  GOOD: Check errors
result, err := someFunc()
if err != nil {
    return fmt.Errorf("someFunc failed: %w", err)
}
```

### 3. Shadowing Variables with `:=`

```go
//  BAD: Shadowing err
result, err := step1()
if result.NeedsStep2 {
    result, err := step2()  // Shadows outer err!
}

//  GOOD: Reuse err
result, err := step1()
if result.NeedsStep2 {
    result, err = step2()  // Reuses outer err
}
```

### 4. Closing Channels from Receiver Side

```go
//  BAD: Receiver closes channel
func receiver(ch <-chan int) {
    for v := range ch {
        process(v)
    }
    close(ch)  // WRONG! Only sender should close
}

//  GOOD: Sender closes channel
func sender(ch chan<- int, values []int) {
    defer close(ch)
    for _, v := range values {
        ch <- v
    }
}
```

### 5. Global Mutable State

```go
//  BAD: Global mutable state
var cache = make(map[string]interface{})

func Get(key string) interface{} {
    return cache[key]  // Race!
}

//  GOOD: Encapsulated with mutex
type Cache struct {
    mu    sync.RWMutex
    items map[string]interface{}
}

func (c *Cache) Get(key string) (interface{}, bool) {
    c.mu.RLock()
    defer c.mu.RUnlock()
    val, ok := c.items[key]
    return val, ok
}
```

---

## 7. Troubleshooting Guide

### Debug Logging

```go
import "log/slog"

logger := slog.New(slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{
    Level: slog.LevelDebug,
}))

logger.Debug("processing user", "user_id", userID, "step", "validation")
```

### Using Delve

```bash
dlv debug ./cmd/myapp
dlv test ./pkg/mypackage
dlv attach <PID>

# Delve commands
(dlv) break main.main
(dlv) continue
(dlv) next
(dlv) print variable
(dlv) goroutines
```

### CPU Profiling

```bash
go test -cpuprofile=cpu.prof -bench=.
go tool pprof cpu.prof

# pprof commands
(pprof) top
(pprof) list functionName
(pprof) web
```

### Common Errors

**Nil Pointer**: Check nil before dereferencing
**Index Out of Range**: Check length before accessing
**Deadlock**: Ensure channels are closed
**Race Condition**: Run `go test -race`

---

## 8. CI/CD Integration

### GitHub Actions Example

```yaml
name: Go CI

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        go-version: ['1.24', '1.25']

    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version: ${{ matrix.go-version }}
          cache: true

      - run: go mod download
      - run: gofmt -s -l . | tee /dev/stderr | test -z "$(cat)"
      - run: go vet ./...
      - run: staticcheck ./...
      - run: golangci-lint run
      - run: go test -race -coverprofile=coverage.out ./...
      - run: govulncheck ./...
```

---

## 9. Advanced Patterns

### Fan-Out, Fan-In

```go
func fanOutFanIn(ctx context.Context, inputs []Input) ([]Result, error) {
    jobs := make(chan Input, len(inputs))
    results := make(chan Result, len(inputs))

    // Start workers
    var wg sync.WaitGroup
    for i := 0; i < runtime.NumCPU(); i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for input := range jobs {
                select {
                case results <- process(input):
                case <-ctx.Done():
                    return
                }
            }
        }()
    }

    // Send jobs and close
    go func() {
        for _, input := range inputs {
            jobs <- input
        }
        close(jobs)
    }()

    // Wait and close results
    go func() {
        wg.Wait()
        close(results)
    }()

    // Collect results
    var collected []Result
    for result := range results {
        collected = append(collected, result)
    }

    return collected, nil
}
```

### Rate Limiting

```go
type RateLimiter struct {
    rate     int
    tokens   chan struct{}
}

func NewRateLimiter(rate int) *RateLimiter {
    rl := &RateLimiter{
        rate:   rate,
        tokens: make(chan struct{}, rate),
    }
    for i := 0; i < rate; i++ {
        rl.tokens <- struct{}{}
    }
    return rl
}

func (rl *RateLimiter) Wait(ctx context.Context) error {
    select {
    case <-rl.tokens:
        return nil
    case <-ctx.Done():
        return ctx.Err()
    }
}
```

---

## 10. Documentation

- **Package Docs**: Capture purpose in `doc.go`
- **Exported Items**: Every exported item gets a comment
- **Concurrency Contracts**: Document goroutine-safety

```go
// Package user provides user management functionality.
package user

// User represents a user in the system.
type User struct {
    ID   string
    Name string
}

// GetUser retrieves a user by ID.
// It returns ErrNotFound if the user doesn't exist.
func GetUser(ctx context.Context, id string) (*User, error) {
    // ...
}
```

---

## Anti-Patterns (Automatic Rejection)

### Critical
-  Panic/recover as control flow ("Don't panic" - use errors for normal error handling)
-  Goroutines without lifecycle management
-  Swallowed errors ("Don't just check errors, handle them gracefully")
-  Global mutable state
-  Logging secrets/PII
-  Zero values that require initialization to be safe ("Make the zero value useful")

### Code Smells
-  Channels for simple mutual exclusion (use mutexes)
-  Reflection/unsafe without benchmarks ("Reflection is never clear")
-  "God" interfaces ("The bigger the interface, the weaker the abstraction")
-  Premature abstraction ("A little copying is better than a little dependency")
-  Missing context propagation
-  Using `interface{}` when generics or specific types would work ("interface{} says nothing")
-  Clever code over clear code ("Clear is better than clever")
-  Zero values that require initialization to be safe ("Make the zero value useful")

---

**Context Matters**: These rules optimize for long-lived production services. A one-off script has different needs than a high-traffic API. Deviations are fine when justified and intentional.

**Go Version**: 1.25+
