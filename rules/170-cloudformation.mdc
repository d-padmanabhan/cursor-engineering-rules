---
title: CloudFormation Engineering Ruleset
description: Secure, maintainable CloudFormation templates with best practices for AWS infrastructure.
priority: 170
alwaysApply: false
files:
  include:
    - "**/*.yaml"
    - "**/*.yml"
    - "**/*.template"
    - "**/cloudformation/**/*"
    - "**/cfn/**/*"
---
# CloudFormation Engineering Ruleset

**Audience**: engineers writing and reviewing CloudFormation templates
**Goal:** Create secure, maintainable CloudFormation templates following AWS best practices.

## CloudFormation Philosophy (Core Principles)

**Core Principles:**

- **"Security by default"** - Least privilege IAM, encryption everywhere, no hardcoded secrets
- **"Infrastructure as Code"** - All resources defined in templates, version controlled, reviewed
- **"Parameterization over hardcoding"** - Use parameters, mappings, and conditions for flexibility
- **"Composition over duplication"** - Use nested stacks, modules, and reusable templates
- **"Validation before deployment"** - Validate templates, test changes, review diffs
- **"Idempotency is essential"** - Templates should be safe to run multiple times
- **"Explicit over implicit"** - Clear resource names, documented parameters, explicit dependencies
- **"Fail fast, fail clearly"** - Use conditions, validations, and clear error messages

**Applying CloudFormation Principles:**

```yaml
# BAD: Hardcoded, insecure, monolithic
Resources:
  rMyDatabase:
    Type: AWS::RDS::DBInstance
    Properties:
      MasterUsername: admin
      MasterUserPassword: Password123!
      DBInstanceClass: db.t2.micro

# GOOD: Parameterized, secure, modular
Parameters:
  pEnvironment:
    Type: String
    AllowedValues: [dev, staging, prod]
    Description: Deployment environment

  pDatabasePassword:
    Type: String
    NoEcho: true
    Description: Database password from Secrets Manager

Resources:
  rDatabase:
    Type: AWS::RDS::DBInstance
    Properties:
      MasterUsername: !Ref pDatabaseUsername
      MasterUserPassword: !Ref pDatabasePassword
      DBInstanceClass: !If [cIsProduction, db.r5.xlarge, db.t3.micro]
      StorageEncrypted: true
      DeletionProtection: !If [cIsProduction, true, false]
```

## Core Principles

- **Security First**: Least privilege IAM, encryption at rest and in transit
- **Infrastructure as Code**: All resources defined in templates
- **Parameterization**: Use parameters for environment-specific values
- **DRY**: Use nested stacks and modules for reusable components
- **Validation**: Validate templates before deployment

## Template Structure

```yaml
AWSTemplateFormatVersion: '2010-09-09'
Description: 'Brief description of what this template does'

Parameters:
  # Environment-specific parameters
  pEnvironment:
    Type: String
    Default: dev
    AllowedValues: [dev, staging, prod]
    Description: Environment name

Resources:
  # Resource definitions

Outputs:
  # Important outputs
```

## Security Best Practices

- **IAM Roles**: Use least privilege, never use root credentials
- **Encryption**: Enable encryption for S3, RDS, EBS volumes
- **VPC**: Use private subnets, security groups restrictively
- **Secrets**: Use AWS Secrets Manager or Parameter Store, never hardcode
- **Network**: Use VPC endpoints, avoid public internet where possible

## Resource Naming

- Use logical resource names with prefixes:
  - `r` for resources: `rMyDatabase`, `rWebServerRole`
  - `p` for parameters: `pEnvironment`, `pInstanceType`
  - `c` for conditions: `cIsProduction`, `cEnableNatGateway`
  - `m` for mappings: `mEnvironmentMap`, `mRegionMap`
  - `o` for outputs: `oVpcId`, `oSubnetIds`
- Use tags consistently: `Environment`, `Project`, `ManagedBy`
- Follow AWS naming conventions

## Stack Naming Convention

Always append the region to stack names to enable multi-region deployments and avoid naming conflicts:

```bash
# Pattern: <stack-name>-${AWS_REGION}
my-vpc-stack-us-east-1
my-app-stack-eu-west-1
```

## Deployment Commands: `create-stack`/`update-stack` vs `deploy`

| Aspect | create-stack / update-stack | deploy |
|--------|----------------------------|--------|
| Commands | Two separate commands | Single unified command |
| Stack existence | Must know if stack exists beforehand | Automatically creates OR updates |
| Idempotency | update-stack fails if no changes | Succeeds with "No changes" message |
| Change sets | Manual: create-change-set → execute-change-set | Automatically creates and executes |
| Use case | Granular control, CI/CD pipelines | Interactive/scripted deployments |

### `create-stack` / `update-stack`

```bash
# Must use correct command based on stack existence
aws cloudformation create-stack \
  --stack-name my-stack-${AWS_REGION} \
  --template-body file://template.yaml

# If stack exists, use update (fails if no changes!)
aws cloudformation update-stack \
  --stack-name my-stack-${AWS_REGION} \
  --template-body file://template.yaml
```

### `deploy` (recommended for most cases)

```bash
# Works whether stack exists or not - creates or updates automatically
aws cloudformation deploy \
  --stack-name my-stack-${AWS_REGION} \
  --template-file template.yaml \
  --parameter-overrides Key1=Value1 Key2=Value2

# Note: uses --template-file not --template-body
```

**Key `deploy` benefits:**
- **Idempotent** - Safe to run repeatedly
- **No "no changes" error** - Just reports no changes needed
- **Simpler scripting** - No need to check if stack exists first
- **Built-in change set** - Creates, reviews, and executes automatically

**When to use `create-stack`/`update-stack`:**
- Need to review change sets before execution (use `--no-execute-changeset` with deploy, or manual change set workflow)
- CI/CD pipelines requiring explicit create vs update logic
- Need `--on-failure` options (only available on create-stack)

## Validation

```bash
# Validate template
aws cloudformation validate-template --template-body file://template.yaml

# Check for drift
aws cloudformation detect-stack-drift --stack-name my-stack-${AWS_REGION}

# Create change set
aws cloudformation create-change-set --stack-name my-stack-${AWS_REGION} --change-set-name my-change-set --template-body file://template.yaml

# Review changes
aws cloudformation describe-change-set --stack-name my-stack-${AWS_REGION} --change-set-name my-change-set

# Execute change set
aws cloudformation execute-change-set --stack-name my-stack-${AWS_REGION} --change-set-name my-change-set
```

## Advanced Patterns

### Conditions & Mappings

```yaml
Mappings:
  mEnvironmentMap:
    dev:
      InstanceType: t3.micro
      MinSize: 1
      MaxSize: 2
    prod:
      InstanceType: m5.large
      MinSize: 3
      MaxSize: 10

Conditions:
  cIsProduction: !Equals [!Ref pEnvironment, prod]
  cIsDevelopment: !Equals [!Ref pEnvironment, dev]

Resources:
  rAutoScalingGroup:
    Type: AWS::AutoScaling::AutoScalingGroup
    Properties:
      MinSize: !FindInMap [mEnvironmentMap, !Ref pEnvironment, MinSize]
      MaxSize: !FindInMap [mEnvironmentMap, !Ref pEnvironment, MaxSize]
      LaunchTemplate:
        LaunchTemplateId: !Ref rLaunchTemplate
        Version: !GetAtt rLaunchTemplate.LatestVersionNumber
```

### Nested Stacks

```yaml
# Parent stack
Resources:
  rVPCStack:
    Type: AWS::CloudFormation::Stack
    Properties:
      TemplateURL: https://s3.amazonaws.com/bucket/vpc.yaml
      Parameters:
        pEnvironment: !Ref pEnvironment
        pVpcCidr: 10.0.0.0/16
      TimeoutInMinutes: 15

  rApplicationStack:
    Type: AWS::CloudFormation::Stack
    DependsOn: rVPCStack
    Properties:
      TemplateURL: https://s3.amazonaws.com/bucket/app.yaml
      Parameters:
        pVpcId: !GetAtt rVPCStack.Outputs.oVpcId
        pSubnetIds: !Join [",", !GetAtt rVPCStack.Outputs.oPrivateSubnetIds]
```

### Custom Resources

```yaml
Resources:
  rCustomResource:
    Type: AWS::CloudFormation::CustomResource
    Properties:
      ServiceToken: !GetAtt rCustomResourceFunction.Arn
      CustomProperty: value

  rCustomResourceFunction:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.12
      Handler: index.handler
      Role: !GetAtt rLambdaExecutionRole.Arn
      Code:
        ZipFile: |
          import boto3
          import cfnresponse

          def handler(event, context):
              if event['RequestType'] == 'Create':
                  # Create resource
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
              elif event['RequestType'] == 'Delete':
                  # Delete resource
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
```

### Intrinsic Functions

```yaml
# Join and Split
!Join [":", [!Ref pEnvironment, !Ref pAppName]]
!Split [":", !Ref SomeValue]

# Select and GetAtt
!Select [0, !GetAtt rSubnetGroup.SubnetIds]

# Base64 and Sub
!Base64 "value"
!Sub "arn:aws:s3:::${pBucketName}/*"

# ImportValue (cross-stack references)
!ImportValue rNetworkStack-VpcId-Export

# Transform (SAM, macros)
Transform: AWS::Serverless-2016-10-31
```

## Performance Optimization

### Stack Organization

```yaml
# BAD: Monolithic stack (slow updates, high blast radius)
Resources:
  rVPC: ...
  Subnets: ...
  SecurityGroups: ...
  EC2Instances: ...
  RDS: ...
  Lambda: ...

# GOOD: Separate stacks by change frequency
# networking-stack.yaml (changes rarely)
# compute-stack.yaml (changes moderately)
# application-stack.yaml (changes frequently)
```

### Change Sets

```bash
# Create change set for review
aws cloudformation create-change-set \
  --stack-name my-stack-${AWS_REGION} \
  --change-set-name my-change-set \
  --template-body file://template.yaml

# Review changes
aws cloudformation describe-change-set \
  --stack-name my-stack-${AWS_REGION} \
  --change-set-name my-change-set

# Execute change set
aws cloudformation execute-change-set \
  --stack-name my-stack-${AWS_REGION} \
  --change-set-name my-change-set
```

### Stack Policies

```yaml
# stack-policy.json
{
  "Statement": [
    {
      "Effect": "Deny",
      "Action": "Update:Replace",
      "Resource": "LogicalResourceId/Database*"
    },
    {
      "Effect": "Allow",
      "Action": "Update:*",
      "Resource": "*"
    }
  ]
}

# Apply policy
aws cloudformation set-stack-policy \
  --stack-name my-stack-${AWS_REGION} \
  --stack-policy-body file://stack-policy.json
```

## Testing & Validation

### Template Validation

```bash
# Validate template syntax
aws cloudformation validate-template \
  --template-body file://template.yaml

# Validate with parameters
aws cloudformation validate-template \
  --template-body file://template.yaml \
  --parameters ParameterKey=Environment,ParameterValue=dev

# Use cfn-lint for advanced validation
cfn-lint template.yaml
cfn-lint template.yaml --regions us-east-1
```

### Local Testing

```bash
# Install cfn-lint
pip install cfn-lint

# Lint template
cfn-lint template.yaml

# Check specific rules
cfn-lint template.yaml --ignore-checks W3005

# Generate JSON from YAML for validation
cfn-lint template.yaml --format json
```

### Security Scanning

```bash
# Checkov security scanning
checkov -f template.yaml --framework cloudformation

# cfn-nag security scanning
cfn_nag_scan --input-path template.yaml

# Integration with CI/CD
- name: Run Checkov
  uses: bridgecrewio/checkov-action@v12
  with:
    directory: cloudformation/
    framework: cloudformation
```

## Troubleshooting Guide

### Common Errors

**Stack Rollback:**

```bash
# View stack events
aws cloudformation describe-stack-events \
  --stack-name my-stack-${AWS_REGION} \
  --max-items 20

# View failed resource details
aws cloudformation describe-stack-resource \
  --stack-name my-stack-${AWS_REGION} \
  --logical-resource-id FailedResource
```

**Resource Creation Failures:**

```yaml
# BAD: Missing dependency
Resources:
  Subnet:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC  # VPC might not exist yet

# GOOD: Explicit dependency
Resources:
  Subnet:
    Type: AWS::EC2::Subnet
    DependsOn: VPC
    Properties:
      VpcId: !Ref VPC
```

**Parameter Validation:**

```yaml
# GOOD: Validate parameters early
Parameters:
  InstanceType:
    Type: String
    AllowedValues:
      - t3.micro
      - t3.small
      - m5.large
    ConstraintDescription: Must be a valid instance type
```

**Stack Drift:**

```bash
# Detect drift
aws cloudformation detect-stack-drift --stack-name my-stack-${AWS_REGION}

# Get drift details
aws cloudformation describe-stack-resource-drifts \
  --stack-name my-stack-${AWS_REGION}
```

## Comprehensive Example Template

Complete example demonstrating CloudFormation best practices:

```yaml
AWSTemplateFormatVersion: '2010-09-09'
Description: 'Production-ready VPC with subnets, NAT gateway, and security groups'

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: Network Configuration
        Parameters:
          - pEnvironment
          - pVpcCidr
      - Label:
          default: Security Configuration
        Parameters:
          - pAllowedCidr

Parameters:
  pEnvironment:
    Type: String
    Default: dev
    AllowedValues: [dev, staging, prod]
    Description: Deployment environment

  pVpcCidr:
    Type: String
    Default: 10.0.0.0/16
    Description: CIDR block for VPC
    AllowedPattern: ^([0-9]{1,3}\.){3}[0-9]{1,3}/[0-9]{1,2}$

  pAllowedCidr:
    Type: String
    Default: 0.0.0.0/0
    Description: CIDR block allowed to access resources

Mappings:
  mEnvironmentMap:
    dev:
      NatInstanceType: t3.micro
      EnableNatGateway: false
    prod:
      NatInstanceType: t3.small
      EnableNatGateway: true

Conditions:
  cIsProduction: !Equals [!Ref pEnvironment, prod]
  cCreateNatGateway: !FindInMap [mEnvironmentMap, !Ref pEnvironment, EnableNatGateway]

Resources:
  rVPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: !Ref pVpcCidr
      EnableDnsSupport: true
      EnableDnsHostnames: true
      Tags:
        - Key: Name
          Value: !Sub '${pEnvironment}-vpc'
        - Key: Environment
          Value: !Ref pEnvironment
        - Key: ManagedBy
          Value: CloudFormation

  rInternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
        - Key: Name
          Value: !Sub '${pEnvironment}-igw'

  rInternetGatewayAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      InternetGatewayId: !Ref rInternetGateway
      VpcId: !Ref rVPC

  rPublicSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref rVPC
      AvailabilityZone: !Select [0, !GetAZs '']
      CidrBlock: !Select [0, !Cidr [!Ref pVpcCidr, 8, 8]]
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: !Sub '${pEnvironment}-public-subnet-1'

  rPublicSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref rVPC
      AvailabilityZone: !Select [1, !GetAZs '']
      CidrBlock: !Select [1, !Cidr [!Ref pVpcCidr, 8, 8]]
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: !Sub '${pEnvironment}-public-subnet-2'

  rPrivateSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref rVPC
      AvailabilityZone: !Select [0, !GetAZs '']
      CidrBlock: !Select [2, !Cidr [!Ref pVpcCidr, 8, 8]]
      Tags:
        - Key: Name
          Value: !Sub '${pEnvironment}-private-subnet-1'

  rPrivateSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref rVPC
      AvailabilityZone: !Select [1, !GetAZs '']
      CidrBlock: !Select [3, !Cidr [!Ref pVpcCidr, 8, 8]]
      Tags:
        - Key: Name
          Value: !Sub '${pEnvironment}-private-subnet-2'

  rNatGatewayEIP:
    Type: AWS::EC2::EIP
    DependsOn: rInternetGatewayAttachment
    Properties:
      Domain: vpc
      Tags:
        - Key: Name
          Value: !Sub '${pEnvironment}-nat-eip'

  rNatGateway:
    Type: AWS::EC2::NatGateway
    Condition: cCreateNatGateway
    Properties:
      AllocationId: !GetAtt rNatGatewayEIP.AllocationId
      SubnetId: !Ref rPublicSubnet1
      Tags:
        - Key: Name
          Value: !Sub '${pEnvironment}-nat-gateway'

  rPublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref rVPC
      Tags:
        - Key: Name
          Value: !Sub '${pEnvironment}-public-rt'

  rDefaultPublicRoute:
    Type: AWS::EC2::Route
    DependsOn: rInternetGatewayAttachment
    Properties:
      RouteTableId: !Ref rPublicRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref rInternetGateway

  rPublicSubnet1RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref rPublicSubnet1
      RouteTableId: !Ref rPublicRouteTable

  rPublicSubnet2RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref rPublicSubnet2
      RouteTableId: !Ref rPublicRouteTable

  rPrivateRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref rVPC
      Tags:
        - Key: Name
          Value: !Sub '${pEnvironment}-private-rt'

  rDefaultPrivateRoute:
    Type: AWS::EC2::Route
    Condition: cCreateNatGateway
    Properties:
      RouteTableId: !Ref rPrivateRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId: !Ref rNatGateway

  rPrivateSubnet1RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref rPrivateSubnet1
      RouteTableId: !Ref rPrivateRouteTable

  rPrivateSubnet2RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref rPrivateSubnet2
      RouteTableId: !Ref rPrivateRouteTable

  rWebSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for web servers
      VpcId: !Ref rVPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: !Ref pAllowedCidr
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: !Ref pAllowedCidr
      SecurityGroupEgress:
        - IpProtocol: -1
          CidrIp: 0.0.0.0/0
      Tags:
        - Key: Name
          Value: !Sub '${pEnvironment}-web-sg'

Outputs:
  oVpcId:
    Description: VPC ID
    Value: !Ref rVPC
    Export:
      Name: !Sub '${AWS::StackName}-VpcId'

  oPublicSubnetIds:
    Description: Public subnet IDs
    Value: !Join [',', [!Ref rPublicSubnet1, !Ref rPublicSubnet2]]
    Export:
      Name: !Sub '${AWS::StackName}-PublicSubnetIds'

  oPrivateSubnetIds:
    Description: Private subnet IDs
    Value: !Join [',', [!Ref rPrivateSubnet1, !Ref rPrivateSubnet2]]
    Export:
      Name: !Sub '${AWS::StackName}-PrivateSubnetIds'

  oWebSecurityGroupId:
    Description: Web security group ID
    Value: !Ref rWebSecurityGroup
    Export:
      Name: !Sub '${AWS::StackName}-WebSecurityGroupId'
```

**Key Patterns Demonstrated:**

- ✅ Security: Proper IAM, encryption, security groups
- ✅ Parameterization: Environment-specific configuration
- ✅ Conditions: Conditional resource creation
- ✅ Mappings: Environment-based resource sizing
- ✅ Dependencies: Explicit DependsOn where needed
- ✅ Outputs: Cross-stack references with exports
- ✅ Tagging: Consistent tagging strategy
- ✅ Best practices: Proper resource organization

## Review Checklist

- [ ] IAM roles use least privilege
- [ ] Encryption enabled where applicable
- [ ] Parameters used for environment-specific values
- [ ] Tags applied consistently
- [ ] Outputs defined for important resources
- [ ] Template validated before deployment
- [ ] No hardcoded secrets or credentials
- [ ] Conditions used for conditional resources
- [ ] Mappings used for environment-specific values
- [ ] Nested stacks for modularity
- [ ] Stack policies for protection
- [ ] Change sets used for review
- [ ] Custom resources when needed
- [ ] Intrinsic functions used appropriately
- [ ] Cross-stack references via exports
- [ ] Stack names include region suffix (e.g., `my-stack-${AWS_REGION}`)
- [ ] Consistent naming prefixes (r for resources, p for parameters, c for conditions, m for mappings, o for outputs)

## Testing & Validation Patterns

### Template Testing

```bash
# Validate syntax
aws cloudformation validate-template \
  --template-body file://template.yaml

# Validate with parameters
aws cloudformation validate-template \
  --template-body file://template.yaml \
  --parameters ParameterKey=Environment,ParameterValue=dev

# Dry-run with change set
aws cloudformation create-change-set \
  --stack-name test-stack-${AWS_REGION} \
  --change-set-name test-changes \
  --template-body file://template.yaml \
  --change-set-type CREATE

# Review changes without applying
aws cloudformation describe-change-set \
  --stack-name test-stack-${AWS_REGION} \
  --change-set-name test-changes
```

### Security Scanning

```bash
# Checkov scanning
checkov -f template.yaml --framework cloudformation

# cfn-nag scanning
cfn_nag_scan --input-path template.yaml

# cfn-lint validation
cfn-lint template.yaml
cfn-lint template.yaml --regions us-east-1
```

### Integration Testing

```bash
# Create test stack
aws cloudformation create-stack \
  --stack-name test-stack-${AWS_REGION} \
  --template-body file://template.yaml \
  --parameters ParameterKey=Environment,ParameterValue=dev

# Wait for completion
aws cloudformation wait stack-create-complete \
  --stack-name test-stack-${AWS_REGION}

# Verify resources
aws cloudformation describe-stack-resources \
  --stack-name test-stack-${AWS_REGION}

# Cleanup
aws cloudformation delete-stack \
  --stack-name test-stack-${AWS_REGION}
```

## Advanced Troubleshooting

### Stack Events Analysis

```bash
# Get recent events
aws cloudformation describe-stack-events \
  --stack-name my-stack-${AWS_REGION} \
  --max-items 50 \
  --query 'StackEvents[*].[Timestamp,ResourceStatus,ResourceType,LogicalResourceId,ResourceStatusReason]' \
  --output table

# Filter failed events
aws cloudformation describe-stack-events \
  --stack-name my-stack-${AWS_REGION} \
  --query 'StackEvents[?ResourceStatus==`CREATE_FAILED`]' \
  --output json
```

### Resource Inspection

```bash
# Get resource details
aws cloudformation describe-stack-resource \
  --stack-name my-stack-${AWS_REGION} \
  --logical-resource-id MyResource

# List all resources
aws cloudformation list-stack-resources \
  --stack-name my-stack-${AWS_REGION}

# Get resource physical ID
aws cloudformation describe-stack-resource \
  --stack-name my-stack-${AWS_REGION} \
  --logical-resource-id MyResource \
  --query 'StackResourceDetail.PhysicalResourceId' \
  --output text
```

### Stack Drift Detection

```bash
# Detect drift
DRIFT_ID=$(aws cloudformation detect-stack-drift \
  --stack-name my-stack-${AWS_REGION} \
  --query 'StackDriftDetectionId' \
  --output text)

# Check drift status
aws cloudformation describe-stack-drift-detection-status \
  --stack-drift-detection-id "$DRIFT_ID"

# Get drift details
aws cloudformation describe-stack-resource-drifts \
  --stack-name my-stack-${AWS_REGION} \
  --query 'StackResourceDrifts[?StackResourceDriftStatus==`MODIFIED`]'
```

## Performance Optimization Examples

### Stack Organization

```yaml
# BAD: Monolithic stack (slow updates)
Resources:
  VPC: ...
  Subnets: ...
  SecurityGroups: ...
  EC2Instances: ...
  RDS: ...
  Lambda: ...
  # 50+ resources in one stack

# GOOD: Separate stacks by change frequency
# networking-stack.yaml (VPC, subnets - changes rarely)
# security-stack.yaml (Security groups - moderate changes)
# compute-stack.yaml (EC2, ASG - moderate changes)
# database-stack.yaml (RDS - infrequent changes)
# application-stack.yaml (Lambda, API Gateway - frequent changes)
```

### Parameter Optimization

```yaml
# BAD: Too many parameters (hard to manage)
Parameters:
  Param1: ...
  Param2: ...
  # ... 30+ parameters

# GOOD: Use mappings and conditions
Mappings:
  EnvironmentMap:
    dev:
      InstanceType: t3.micro
      MinSize: 1
    prod:
      InstanceType: m5.large
      MinSize: 3

Parameters:
  Environment:
    Type: String
    AllowedValues: [dev, staging, prod]
```

### Change Set Optimization

```bash
# Create change set for review
aws cloudformation create-change-set \
  --stack-name my-stack-${AWS_REGION} \
  --change-set-name my-changes \
  --template-body file://template.yaml \
  --change-set-type UPDATE

# Review changes without applying
aws cloudformation describe-change-set \
  --stack-name my-stack-${AWS_REGION} \
  --change-set-name my-changes \
  --query 'Changes[*].[Action,LogicalResourceId,ResourceType]' \
  --output table

# Execute only after review
aws cloudformation execute-change-set \
  --stack-name my-stack-${AWS_REGION} \
  --change-set-name my-changes
```

---

