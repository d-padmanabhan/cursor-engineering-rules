---
title: JavaScript Engineering Ruleset
description: Secure-by-default, type-checked (JSDoc + @ts-check), performant, and testable JavaScript guidelines for generation and review.
priority: 220

alwaysApply: false
files:
  include:
    - "**/*.js"
    - "**/*.mjs"
    - "**/*.cjs"
    - "package.json"
    - "tsconfig.json"            # for JSDoc type-checking in JS
    - ".eslintrc.*"
    - ".prettierrc*"
    - "jest.config.*"
    - "vitest.config.*"
    - "jsdoc.json"
---

# JavaScript Engineering Ruleset - (December 2025)

**Audience**: engineers writing and reviewing JavaScript/Node.js code
**Goal**: secure-by-default, bug-resistant, performant, readable, well-documented, and testable JavaScript - without over-engineering

## JavaScript Principles (Core Philosophy)

**Core Principles:**

- **"JavaScript is forgiving, but that doesn't mean you should be"** - Use strict mode, validate inputs, handle errors explicitly
- **"Functions are first-class citizens"** - Leverage higher-order functions, closures, and functional patterns
- **"Prototypes over classes"** - Understand prototypal inheritance; use classes when they add clarity
- **"Async by default"** - Embrace asynchronous patterns; avoid blocking the event loop
- **"Composition over inheritance"** - Prefer small, composable functions over deep hierarchies
- **"Explicit over implicit"** - Use `===` not `==`, handle null/undefined explicitly, avoid type coercion
- **"Fail fast"** - Validate early, throw meaningful errors, don't silently fail
- **"Readability counts"** - Code is read more often than written; prefer clear over clever

**Applying JavaScript Principles:**

```js
// BAD: Implicit, forgiving, silent failures
function process(data) {
  return data.value * 2;  // What if data is null? What if value is undefined?
}

// GOOD: Explicit, validated, fail-fast
/**
 * @param {{ value: number }} data
 * @returns {number}
 * @throws {TypeError}
 */
function process(data) {
  if (!data || typeof data.value !== 'number') {
    throw new TypeError('data.value must be a number');
  }
  return data.value * 2;
}

// BAD: Blocking the event loop
function processLargeArray(arr) {
  arr.forEach(item => expensiveSyncOperation(item));  // Blocks everything
}

// GOOD: Async, non-blocking
async function processLargeArray(arr) {
  for (const item of arr) {
    await expensiveAsyncOperation(item);  // Yields to event loop
  }
}

// BAD: Implicit type coercion
if (value == 0) { }  // true for: 0, '0', false, '', []

// GOOD: Explicit comparison
if (value === 0) { }  // true only for: 0
```

---

## Quick Reference

### Essential Commands
```bash
npm ci                        # Clean install (CI)
npm audit                     # Check vulnerabilities
npm test -- --coverage        # Run tests with coverage
node --inspect app.js         # Start debugger
node --prof app.js            # Generate profiling data
```

### Critical Patterns
```js
// 1. Use strict equality
if (value === 0) { }        //  GOOD
if (value == 0) { }         //  BAD

// 2. Handle Promise rejections
fetchData().catch(err => console.error(err));  //  GOOD

// 3. Optional chaining and nullish coalescing
const name = user?.profile?.name ?? 'Guest';  //  GOOD

// 4. Use Set/Map for lookups
const seen = new Set();     //  GOOD (O(1))
const seen = [];            //  BAD (O(n))

// 5. Never use eval or new Function
eval(userInput);            //  NEVER DO THIS

// 6. Sanitize HTML
element.textContent = userInput;            //  GOOD
element.innerHTML = DOMPurify.sanitize(html);  //  GOOD
element.innerHTML = userInput;              //  BAD (XSS)
```

---

## 0) Agent Operating Mode

**For new code (hard requirements unless environment forbids):**

* **Package Manager:** Prefer `pnpm` (fast, efficient)
* **Module System:** Prefer **ES Modules**; add `// @ts-check`
* **Linting:** Must pass **ESLint** with **0 errors/warnings**
* **Formatting:** Must pass **Prettier**
* **Documentation:** Use **JSDoc** types for all exported APIs
* **Error Handling:** Add error handling around I/O (FS, network, JSON parse)
* **Testing:** Include tests for non-trivial logic

**For reviews:**

* Follow the **Impact-first flow** below
* Show **Before / After / Why** for each material change

---

## 1) Capture/Assume Context (before writing/reviewing)

* **Purpose** (what problem this solves)
* **Environment** (Browser, Node version, Worker/Lambda, bundler)
* **Constraints** (latency, memory, PII/PCI/HIPAA, SLOs)
* **Interfaces** (inputs/outputs, schemas, events)
* **Scale** (data size, QPS, concurrency)

*If something materially affects design and isn't provided, state assumptions clearly and proceed.*

---

## 2) Prioritized Review Flow (Impact-First)

1. **Security**
2. **Correctness**
3. **Performance**
4. **Readability/Maintainability**
5. **Modern JS best practices**
6. **Docs & Tests**
7. **Tooling/CI**

---

## 3) Core Principles

* **Naming:** `camelCase` (func/vars), `PascalCase` (classes), `UPPER_SNAKE_CASE` (constants)
* **DRY / KISS / YAGNI:** small, focused functions; early returns; avoid speculative abstractions
* **Composition over inheritance** unless a clear hierarchy exists

---

## 4) Modern Defaults

* **ESM** `import`/`export` (no CommonJS unless required)
* **const/let** (no `var`), **template literals**, **destructuring**, **spread/rest**
* **Optional chaining `?.`** and **nullish coalescing `??`**
* **Strict equality** `===`, `!==`
* Prefer **immutable patterns** where reasonable; avoid accidental mutation

---

## 5) Security Rules (Mandatory)

* Never use `eval`, `new Function`, or unsanitized `innerHTML`
* Use `textContent` for DOM insertion; if HTML is required, **sanitize** (e.g., DOMPurify)
* Validate and sanitize all external inputs (query/body/headers/params)
* Do not log secrets/tokens/PII
* Prefer **parameterized queries** / safe builders; no string-built queries
* Enforce HTTPS; secure cookies (HttpOnly, SameSite) and CSRF where applicable
* Pin third-party lib versions where risk matters

---

## 6) Correctness & Bug Avoidance

* Guard **null/undefined** and **array bounds**
* Ensure async flows `await` or return Promises correctly
* Use **exhaustive conditionals** (add `default`)
* Handle edge cases (empty arrays, zero, large inputs, timeouts)
* Be explicit about **time zones/locale** for dates/numbers (Prefer UTC ISO 8601)

---

## 7) Performance

**Golden Rule:** Profile first, optimize second. Use Chrome DevTools Performance tab or Node.js `--prof` to identify bottlenecks.

* Use **Set/Map** for frequent lookups; avoid `O(n²)` scans
* Batch independent async calls with **`Promise.all`**; for partial failure, **`allSettled` + retry**
* Debounce/throttle noisy UI events
* Prefer streaming/iterators for large data
* Avoid needless allocations in hot paths

**Example (unique):**

```js
//  BAD: O(n²)
const uniq = [];
for (const x of arr) if (!uniq.includes(x)) uniq.push(x);

//  GOOD: O(n)
const uniq = [...new Set(arr)];
```

### Performance Optimization Examples

**String Concatenation:**

```js
// BAD: Creates new strings each iteration (O(n²))
let result = '';
for (const item of items) {
  result += item;  // New string allocation each time
}

// GOOD: Use array join (O(n))
const parts = [];
for (const item of items) {
  parts.push(item);
}
const result = parts.join('');

// GOOD: Template literals for small concatenations
const result = `${prefix}-${suffix}-${id}`;
```

**Array Operations:**

```js
// BAD: Multiple iterations
const doubled = [];
const filtered = [];
for (const x of arr) {
  if (x > 0) {
    doubled.push(x * 2);
    filtered.push(x);
  }
}

// GOOD: Single pass with chaining
const doubled = arr
  .filter(x => x > 0)
  .map(x => x * 2);

// GOOD: For large arrays, use for...of (more memory efficient)
const doubled = [];
for (const x of arr) {
  if (x > 0) doubled.push(x * 2);
}
```

**Object Property Access:**

```js
// BAD: Repeated property access
function processUser(user) {
  return {
    id: user.id,
    name: user.name,
    email: user.email,
    display: `${user.name} (${user.email})`
  };
}

// GOOD: Destructure once
function processUser(user) {
  const { id, name, email } = user;
  return {
    id,
    name,
    email,
    display: `${name} (${email})`
  };
}
```

**Memoization:**

```js
// BAD: Recomputes expensive operation
function expensiveOperation(input) {
  return complexCalculation(input);  // Called every time
}

// GOOD: Memoize results
const cache = new Map();
function expensiveOperation(input) {
  if (cache.has(input)) {
    return cache.get(input);
  }
  const result = complexCalculation(input);
  cache.set(input, result);
  return result;
}

// GOOD: Using WeakMap for object keys (allows GC)
const cache = new WeakMap();
function expensiveOperation(obj) {
  if (cache.has(obj)) {
    return cache.get(obj);
  }
  const result = complexCalculation(obj);
  cache.set(obj, result);
  return result;
}
```

**Debouncing and Throttling:**

```js
// Debounce: Execute after delay, cancel if called again
function debounce(fn, delay) {
  let timeoutId;
  return function(...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn.apply(this, args), delay);
  };
}

// Throttle: Execute at most once per interval
function throttle(fn, interval) {
  let lastCall = 0;
  return function(...args) {
    const now = Date.now();
    if (now - lastCall >= interval) {
      lastCall = now;
      return fn.apply(this, args);
    }
  };
}

// Usage
const debouncedSearch = debounce((query) => {
  searchAPI(query);
}, 300);

const throttledScroll = throttle(() => {
  updateScrollPosition();
}, 100);
```

**Lazy Evaluation:**

```js
// BAD: Eager evaluation (processes all items)
function processAll(items) {
  return items
    .map(expensiveTransform)
    .filter(isValid)
    .slice(0, 10);  // Only need 10, but processed all
}

// GOOD: Lazy evaluation with generators
function* processLazy(items) {
  for (const item of items) {
    const transformed = expensiveTransform(item);
    if (isValid(transformed)) {
      yield transformed;
    }
  }
}

function processAll(items) {
  const generator = processLazy(items);
  const results = [];
  for (let i = 0; i < 10; i++) {
    const { value, done } = generator.next();
    if (done) break;
    results.push(value);
  }
  return results;
}
```

---

## 8) Error Handling & Logging

* **Standard Pattern:** Use a structured logging approach for services
* **Timestamps:** Use UTC ISO string `new Date().toISOString()`
* **Exceptions:**
    * Wrap risky I/O (FS/network/JSON) in `try/catch`
    * Catch **specific** errors (`TypeError`, `RangeError`) where helpful
    * Don't swallow errors; rethrow with context or log securely

**Logging Example:**

```js
const logger = {
  info: (msg, meta = {}) => console.log(JSON.stringify({ level: 'info', ts: new Date().toISOString(), msg, ...meta })),
  error: (msg, err) => console.error(JSON.stringify({ level: 'error', ts: new Date().toISOString(), msg, error: err?.message, stack: err?.stack }))
};
```

---

## 9) Imports & Organization

* Group imports: **std/core -> third-party -> local** (blank lines between)
* Keep modules cohesive; avoid "god" modules
* Export small, testable units
* Avoid circular deps; factor shared utilities lower

---

## 10) Advanced Features (use only if clearly helpful)

* **Array methods**: `map/filter/reduce` where they increase clarity
* **Async/await** over raw promises; use **timeouts** where relevant
* **Higher-order functions** for cross-cutting concerns (timing, retries, caching)
* **Generators/iterators** for lazy/streaming pipelines - document yield/close semantics
* **Decorators** only if the toolchain supports them; otherwise HOFs

*Plain-JS "decorator" alternative:*

```js
const timeIt = (fn) => async (...args) => {
  const t0 = performance.now();
  try { return await fn(...args); }
  finally { console.log(`${fn.name} took ${performance.now() - t0} ms`); }
};
```

---

## 11) Documentation (JSDoc + `// @ts-check`)

* Every exported function/class/module has JSDoc with `@param`, `@returns`, `@throws`, and an example
* Use typedefs/generics where shapes matter

```js
// @ts-check
/**
 * @module priceService
 * Utilities for computing prices and taxes.
 */

/** @typedef {{ id: string, price: number }} Item */

/**
 * Compute total including tax.
 * @param {Item[]} items
 * @param {number} taxRate
 * @returns {number}
 * @throws {TypeError} On invalid inputs.
 * @example
 * total([{id:'A', price:10}], 0.1) // 11
 */
export function total(items, taxRate) { /* ... */ }
```

---

## 12) Testing

* Use Jest (or Mocha/Vitest)
* Cover: happy path, edge cases, and error conditions
* For async: `async/await` or `resolves/rejects`

```js
import { total } from './priceService.js';

test('adds tax', () => {
  expect(total([{ id: 'A', price: 10 }], 0.1)).toBe(11);
});

test('throws on invalid items', () => {
  expect(() => total('nope', 0.1)).toThrow(TypeError);
});
```

### Advanced Testing Patterns

**Test Organization:**

```js
// GOOD: Group related tests
describe('PriceService', () => {
  describe('total()', () => {
    test('calculates total with tax', () => {
      expect(total([{ id: 'A', price: 10 }], 0.1)).toBe(11);
    });

    test('handles empty array', () => {
      expect(total([], 0.1)).toBe(0);
    });

    test('throws on invalid tax rate', () => {
      expect(() => total([], -1)).toThrow(RangeError);
    });
  });
});
```

**Mocking:**

```js
import { jest } from '@jest/globals';

// Mock module
jest.mock('./api.js', () => ({
  fetchUser: jest.fn(),
}));

// Mock function
const mockFetch = jest.fn();
global.fetch = mockFetch;

test('fetches user data', async () => {
  mockFetch.mockResolvedValueOnce({
    ok: true,
    json: async () => ({ id: '123', name: 'John' }),
  });

  const user = await fetchUser('123');
  expect(user.name).toBe('John');
  expect(mockFetch).toHaveBeenCalledWith('/api/users/123');
});

// Mock with implementation
const mockLogger = {
  info: jest.fn(),
  error: jest.fn(),
};

test('logs errors', () => {
  processWithLogging(mockLogger);
  expect(mockLogger.error).toHaveBeenCalled();
});
```

**Async Testing:**

```js
// GOOD: Using async/await
test('handles async operations', async () => {
  const result = await fetchData();
  expect(result).toBeDefined();
});

// GOOD: Testing promises
test('rejects on error', async () => {
  await expect(fetchData('invalid')).rejects.toThrow(Error);
});

// GOOD: Testing with timers
jest.useFakeTimers();
test('debounces correctly', () => {
  const fn = jest.fn();
  const debounced = debounce(fn, 100);

  debounced();
  debounced();
  debounced();

  jest.advanceTimersByTime(100);
  expect(fn).toHaveBeenCalledTimes(1);
});
```

**Snapshot Testing:**

```js
// GOOD: For UI components or complex objects
test('renders user card', () => {
  const user = { id: '123', name: 'John', email: 'john@acme.com' };
  const component = renderUserCard(user);
  expect(component).toMatchSnapshot();
});

// GOOD: Inline snapshots
test('formats date correctly', () => {
  const formatted = formatDate(new Date('2024-01-01'));
  expect(formatted).toMatchInlineSnapshot(`"January 1, 2024"`);
});
```

**Test Coverage:**

```js
// GOOD: Test edge cases
describe('Edge Cases', () => {
  test('handles null input', () => {
    expect(process(null)).toBe(null);
  });

  test('handles empty string', () => {
    expect(process('')).toBe('');
  });

  test('handles very large numbers', () => {
    expect(process(Number.MAX_SAFE_INTEGER)).toBeDefined();
  });

  test('handles special characters', () => {
    expect(process('!@#$%')).toBeDefined();
  });
});
```

**Integration Tests:**

```js
// GOOD: Test with real dependencies
import { createServer } from './server.js';
import { createClient } from './client.js';

test('server responds to requests', async () => {
  const server = await createServer();
  const client = createClient(server.url);

  const response = await client.get('/api/users');
  expect(response.status).toBe(200);
  expect(Array.isArray(response.data)).toBe(true);

  await server.close();
});
```

---

## 13) Tooling (copy-paste ready)

**ESLint** (JSDoc types; no TS build):

```json
{
  "env": { "es2022": true, "node": true, "browser": true, "jest": true },
  "extends": ["eslint:recommended"],
  "plugins": ["jsdoc"],
  "rules": {
    "no-var": "error",
    "prefer-const": "error",
    "eqeqeq": "error",
    "no-unused-vars": ["error", { "argsIgnorePattern": "^_" }],
    "jsdoc/check-alignment": "warn",
    "jsdoc/check-param-names": "warn",
    "jsdoc/check-tag-names": "warn",
    "jsdoc/check-types": "warn"
  }
}
```

**Prettier** (optional):

```json
{ "semi": true, "singleQuote": true, "printWidth": 100, "trailingComma": "es5" }
```

**Type-checking in plain JS (`// @ts-check`)**:

```json
{
  "compilerOptions": {
    "allowJs": true,
    "checkJs": true,
    "noEmit": true,
    "strict": true,
    "target": "ES2022",
    "module": "ES2022",
    "moduleResolution": "Bundler"
  },
  "include": ["src/**/*.js", "tests/**/*.js"]
}
```

---

## 14) Browser-Specific Patterns

### DOM Manipulation
```js
//  GOOD: Batch DOM updates
const fragment = document.createDocumentFragment();
items.forEach(item => {
  const li = document.createElement('li');
  li.textContent = item.name;
  fragment.appendChild(li);
});
list.appendChild(fragment);
```

### Event Listeners
```js
//  GOOD: Event delegation + cleanup
const controller = new AbortController();
element.addEventListener('click', handler, { signal: controller.signal });
// Later: controller.abort();
```

### Fetch with Timeout
```js
const controller = new AbortController();
const timeout = setTimeout(() => controller.abort(), 5000);
try {
  const response = await fetch(url, { signal: controller.signal });
  clearTimeout(timeout);
} catch (err) {
  if (err.name === 'AbortError') console.error('Request timed out');
}
```

---

## 15) Node.js-Specific Patterns

### Filesystem
```js
import fs from 'node:fs/promises';

try {
  const data = await fs.readFile('config.json', 'utf8');
} catch (err) {
  console.error('Failed to read config:', err);
}
```

### Streams
```js
import { pipeline } from 'node:stream/promises';
import { createReadStream, createWriteStream } from 'node:fs';
import { createGzip } from 'node:zlib';

await pipeline(
  createReadStream('input.txt'),
  createGzip(),
  createWriteStream('input.txt.gz')
);
```

### Child Processes (Safe)
```js
import { spawn } from 'node:child_process';

//  GOOD: Pass arguments separately (no shell injection)
spawn('cat', [userInput]);

//  BAD: Shell injection risk
exec(`cat ${userInput}`);
```

---

## 16) Serverless (AWS Lambda) Patterns

### Handler Structure
```js
//  GOOD: Initialize outside handler (reused across invocations)
import { DynamoDBClient } from '@aws-sdk/client-dynamodb';

const dynamoClient = new DynamoDBClient({ region: 'us-east-1' });

export const handler = async (event, context) => {
  try {
    // Business logic using pre-initialized client
    const result = await dynamoClient.send(command);
    return {
      statusCode: 200,
      body: JSON.stringify(result)
    };
  } catch (err) {
    console.error('Lambda failed:', err);
    return {
      statusCode: 500,
      body: JSON.stringify({ error: 'Internal server error' })
    };
  }
};
```

---

## 17) Common Mistakes & Anti-Patterns

### 1. Using `==` Instead of `===`
```js
//  BAD
if (value == 0) { }       // true for: 0, '0', false, '', []

//  GOOD
if (value === 0) { }      // true only for: 0
```

### 2. Mutating Arrays/Objects
```js
//  BAD: Mutates original
function addItem(arr, item) {
  arr.push(item);
  return arr;
}

//  GOOD: Returns new array
function addItem(arr, item) {
  return [...arr, item];
}
```

### 3. Not Handling Promise Rejections
```js
//  BAD: Unhandled rejection
fetchData();

//  GOOD: Handle errors
fetchData().catch(err => console.error(err));
```

### 4. Blocking the Event Loop
```js
//  BAD: Synchronous heavy computation blocks everything
function processLargeArray(arr) {
  arr.forEach(item => expensiveCalculation(item));
}

//  GOOD: Break into chunks
async function processLargeArray(arr, chunkSize = 1000) {
  for (let i = 0; i < arr.length; i += chunkSize) {
    const chunk = arr.slice(i, i + chunkSize);
    chunk.forEach(item => expensiveCalculation(item));
    await new Promise(resolve => setImmediate(resolve));  // Yield to event loop
  }
}
```

### 5. Memory Leaks (Event Listeners)
```js
//  BAD: Not cleaning up
button.addEventListener('click', handleClick);
// Component removed, but listener still exists!

//  GOOD: Cleanup
const controller = new AbortController();
button.addEventListener('click', handleClick, { signal: controller.signal });
// Later: controller.abort();
```

### 6. Incorrect `this` Binding
```js
//  BAD: Lost context
class Counter {
  count = 0;
  increment() { this.count++; }
}
const counter = new Counter();
btn.addEventListener('click', counter.increment);  // `this` is undefined!

//  GOOD: Use arrow function method
class Counter {
  count = 0;
  increment = () => { this.count++; }
}
```

### 7. Not Validating External Inputs
```js
//  BAD: No validation
app.post('/api/users', (req, res) => {
  db.insert('users', req.body);  // Injection risk!
});

//  GOOD: Validate with schema
import Joi from 'joi';

const userSchema = Joi.object({
  name: Joi.string().min(1).max(100).required(),
  email: Joi.string().email().required()
});

app.post('/api/users', (req, res) => {
  const { error, value } = userSchema.validate(req.body);
  if (error) return res.status(400).json({ error: error.details });
  db.insert('users', value);
});
```

### 8. Hardcoded Secrets
```js
//  BAD
const API_KEY = 'sk_live_1234567890abcdef';

//  GOOD
const API_KEY = process.env.API_KEY;
if (!API_KEY) throw new Error('API_KEY required');
```

---

## 18) Troubleshooting Guide

### Debug Logging

```bash
# Node.js debugging
node --inspect app.js
node --inspect-brk app.js     # Break on first line
NODE_ENV=production node app

# Performance profiling
node --prof app.js
node --prof-process isolate-*.log

# Chrome DevTools debugging
# 1. Start with --inspect
# 2. Open chrome://inspect
# 3. Click "inspect" under your Node.js process
```

**Structured Debug Logging:**

```js
// GOOD: Structured logging with levels
const logger = {
  debug: (msg, meta = {}) => {
    if (process.env.DEBUG === '1') {
      console.log(JSON.stringify({
        level: 'debug',
        ts: new Date().toISOString(),
        msg,
        ...meta
      }));
    }
  },
  info: (msg, meta = {}) => {
    console.log(JSON.stringify({
      level: 'info',
      ts: new Date().toISOString(),
      msg,
      ...meta
    }));
  },
  error: (msg, err, meta = {}) => {
    console.error(JSON.stringify({
      level: 'error',
      ts: new Date().toISOString(),
      msg,
      error: err?.message,
      stack: err?.stack,
      ...meta
    }));
  }
};

// Usage
logger.debug('Processing user', { userId: '123', step: 'validation' });
logger.error('Failed to process', err, { userId: '123' });
```

**Performance Profiling:**

```js
// GOOD: Measure execution time
function measureTime(fn, label) {
  return function(...args) {
    const start = performance.now();
    const result = fn.apply(this, args);
    const end = performance.now();
    console.log(`${label} took ${end - start}ms`);
    return result;
  };
}

// GOOD: Memory profiling
function logMemory(label) {
  if (global.gc) {
    global.gc();
  }
  const usage = process.memoryUsage();
  console.log(`${label}:`, {
    heapUsed: `${Math.round(usage.heapUsed / 1024 / 1024)}MB`,
    heapTotal: `${Math.round(usage.heapTotal / 1024 / 1024)}MB`,
    rss: `${Math.round(usage.rss / 1024 / 1024)}MB`
  });
}
```

### Common Errors & Solutions

**UnhandledPromiseRejectionWarning:**

```js
// BAD: Missing .catch()
fetchData();

// GOOD: Handle errors
fetchData().catch(err => {
  logger.error('Failed to fetch data', err);
});

// GOOD: Use async/await with try/catch
async function process() {
  try {
    const data = await fetchData();
    return data;
  } catch (err) {
    logger.error('Failed to process', err);
    throw err;  // Re-throw if needed
  }
}
```

**Maximum call stack size exceeded:**

```js
// BAD: Infinite recursion
function factorial(n) {
  return n * factorial(n - 1);  // No base case!
}

// GOOD: Add base case
function factorial(n) {
  if (n <= 1) return 1;
  return n * factorial(n - 1);
}

// GOOD: Use iterative approach for large numbers
function factorialIterative(n) {
  let result = 1;
  for (let i = 2; i <= n; i++) {
    result *= i;
  }
  return result;
}
```

**Memory Leaks:**

```js
// BAD: Keeping references to large objects
const cache = {};
function process(data) {
  cache[data.id] = data;  // Never cleaned up
}

// GOOD: Use WeakMap (allows GC)
const cache = new WeakMap();
function process(data) {
  cache.set(data, processed);  // GC can clean up
}

// GOOD: Limit cache size
class LRUCache {
  constructor(maxSize = 100) {
    this.cache = new Map();
    this.maxSize = maxSize;
  }

  get(key) {
    if (this.cache.has(key)) {
      const value = this.cache.get(key);
      this.cache.delete(key);
      this.cache.set(key, value);  // Move to end
      return value;
    }
  }

  set(key, value) {
    if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);  // Remove oldest
    }
    this.cache.set(key, value);
  }
}
```

**Event Listener Leaks:**

```js
// BAD: Not cleaning up
button.addEventListener('click', handleClick);
// Component removed, listener still exists

// GOOD: Use AbortController
const controller = new AbortController();
button.addEventListener('click', handleClick, {
  signal: controller.signal
});

// Cleanup
controller.abort();

// GOOD: Remove listener explicitly
function setup() {
  button.addEventListener('click', handleClick);
  return () => {
    button.removeEventListener('click', handleClick);
  };
}

const cleanup = setup();
// Later: cleanup();
```

**Undefined Behavior:**

```js
// BAD: Accessing properties on undefined
function process(user) {
  return user.profile.name;  // Crashes if user or profile is undefined
}

// GOOD: Optional chaining
function process(user) {
  return user?.profile?.name ?? 'Unknown';
}

// GOOD: Explicit checks
function process(user) {
  if (!user || !user.profile) {
    return 'Unknown';
  }
  return user.profile.name;
}
```

---

## 19) CI/CD Integration

### GitHub Actions Example
```yaml
name: Node.js CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [18, 20, 21]

    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'

      - run: npm ci
      - run: npm run lint
      - run: npx tsc --noEmit  # Type check
      - run: npm test -- --coverage
      - run: npm audit --audit-level=high
```

---

## 20) Security Deep Dive

### Prototype Pollution
```js
//  BAD: Vulnerable
function merge(target, source) {
  for (const key in source) target[key] = source[key];
  return target;
}

//  GOOD: Prevent prototype pollution
function safeMerge(target, source) {
  for (const key in source) {
    if (Object.hasOwnProperty.call(source, key) &&
        key !== '__proto__' && key !== 'constructor') {
      target[key] = source[key];
    }
  }
  return target;
}
```

### ReDoS (Regular Expression Denial of Service)
```js
//  BAD: Vulnerable to ReDoS
const regex = /^([a-zA-Z0-9]+)+@[a-zA-Z0-9]+\.[a-zA-Z]{2,}$/;

//  GOOD: Simpler regex or use validator library
const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
// Or: import validator from 'validator'; validator.isEmail(input);
```

---

## 21) Import Ordering Example

```js
// Node core / Web built-ins
import fs from 'node:fs';
import path from 'node:path';

// Third-party
import express from 'express';
import DOMPurify from 'dompurify';

// Local
import { total } from './priceService.js';
```

---

## 22) Review Output Template (Agent or Human)

**High-level:** purpose, environment, key flows.

**Findings (ordered by priority):**

1. **[Security] Title**
   **Before:** …
   **After:** …
   **Why:** impact/trade-offs.

2. **[Bug] Title** - Before / After / Why

3. **[Performance] Title** - Before / After / Why

4. **[Readability] Title** - Before / After / Why

5. **[Best Practice] Title** - Before / After / Why

**Tests to add/update:** bullets with small Jest snippets.
**Docs to add:** which exports need JSDoc/examples.
**Tooling:** lint/type-check/test config changes (if any).

---

## 23) Generation Output Template (Agent)

**Assumptions & Context:** purpose, env, inputs/outputs, constraints.
**API (JSDoc):** public surface documented.
**Implementation:** ESM, `// @ts-check`, JSDoc types, error handling.
**Tests:** happy path + edge + errors.
**Notes:** trade-offs/TODOs.

**Skeleton:**

```js
// @ts-check
/**
 * @module myFeature
 * Brief description and usage example.
 */

/** @typedef {{ id: string, value: number }} Item */

/**
 * Do an important thing.
 * @param {Item[]} items
 * @returns {number}
 * @throws {TypeError}
 * @example
 * doThing([{id:'x', value:1}]); // 1
 */
export function doThing(items) {
  if (!Array.isArray(items)) throw new TypeError('items must be an array');
  return items.reduce((s, it) => s + it.value, 0);
}
```

---

## 24) Appendix - JSDoc Cheatsheet

* **Union/optional/nullable**

```js
/** @param {string | number} id */
/** @param {string=} alias */   // optional
/** @param {?string} note */    // nullable
```

* **Record/Map**

```js
/** @type {Record<string, number>} */
const counts = {};
```

* **Generics**

```js
/** @template T @param {T[]} xs @returns {T} */
function first(xs) { return xs[0]; }
```

* **Async**

```js
/** @returns {Promise<Response>} */
async function ping(url) { return fetch(url); }
```

---

## 25) FAQ - "Type annotations can only be used in TS files"

Stay in `.js` with **JSDoc + `// @ts-check`** and a `tsconfig.json` that enables `"allowJs": true, "checkJs": true, "noEmit": true`. If you need inline TS syntax, rename to `.ts` and adopt a TS toolchain.

---

## 26) Comprehensive Example Application

Complete example demonstrating JavaScript best practices:

```js
// @ts-check
/**
 * @module userService
 * User management service with validation, error handling, and logging.
 */

/** @typedef {{ id: string, name: string, email: string, createdAt: Date }} User */
/** @typedef {{ name: string, email: string }} CreateUserInput */

const logger = {
  info: (msg, meta = {}) => console.log(JSON.stringify({
    level: 'info',
    ts: new Date().toISOString(),
    msg,
    ...meta
  })),
  error: (msg, err, meta = {}) => console.error(JSON.stringify({
    level: 'error',
    ts: new Date().toISOString(),
    msg,
    error: err?.message,
    stack: err?.stack,
    ...meta
  }))
};

class ValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = 'ValidationError';
  }
}

class NotFoundError extends Error {
  constructor(resource) {
    super(`${resource} not found`);
    this.name = 'NotFoundError';
  }
}

class UserRepository {
  constructor() {
    this.users = new Map();
  }

  /**
   * @param {string} id
   * @returns {Promise<User | null>}
   */
  async findById(id) {
    return this.users.get(id) ?? null;
  }

  /**
   * @param {CreateUserInput} data
   * @returns {Promise<User>}
   */
  async create(data) {
    if (!data.name || !data.email) {
      throw new ValidationError('Name and email are required');
    }

    if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(data.email)) {
      throw new ValidationError('Invalid email format');
    }

    const user = {
      id: crypto.randomUUID(),
      name: data.name,
      email: data.email,
      createdAt: new Date()
    };

    this.users.set(user.id, user);
    logger.info('User created', { userId: user.id });
    return user;
  }

  /**
   * @param {string} id
   * @param {Partial<CreateUserInput>} data
   * @returns {Promise<User>}
   */
  async update(id, data) {
    const user = await this.findById(id);
    if (!user) {
      throw new NotFoundError('User');
    }

    const updated = { ...user, ...data };
    this.users.set(id, updated);
    logger.info('User updated', { userId: id });
    return updated;
  }

  /**
   * @param {string} id
   * @returns {Promise<void>}
   */
  async delete(id) {
    if (!this.users.has(id)) {
      throw new NotFoundError('User');
    }
    this.users.delete(id);
    logger.info('User deleted', { userId: id });
  }
}

class UserService {
  constructor(repository) {
    this.repository = repository;
  }

  /**
   * @param {string} id
   * @returns {Promise<User>}
   */
  async getUser(id) {
    logger.info('Getting user', { userId: id });
    const user = await this.repository.findById(id);
    if (!user) {
      throw new NotFoundError('User');
    }
    return user;
  }

  /**
   * @param {CreateUserInput} data
   * @returns {Promise<User>}
   */
  async createUser(data) {
    logger.info('Creating user', { email: data.email });
    try {
      return await this.repository.create(data);
    } catch (error) {
      logger.error('Failed to create user', error, { email: data.email });
      throw error;
    }
  }
}

// API Handler
/**
 * @param {UserService} service
 * @returns {import('express').Router}
 */
function createUserRouter(service) {
  const router = (await import('express')).default.Router();

  router.get('/users/:id', async (req, res) => {
    try {
      const user = await service.getUser(req.params.id);
      res.json(user);
    } catch (error) {
      if (error instanceof NotFoundError) {
        return res.status(404).json({ error: error.message });
      }
      logger.error('API error', error, { path: req.path });
      res.status(500).json({ error: 'Internal server error' });
    }
  });

  router.post('/users', async (req, res) => {
    try {
      const user = await service.createUser(req.body);
      res.status(201).json(user);
    } catch (error) {
      if (error instanceof ValidationError) {
        return res.status(400).json({ error: error.message });
      }
      logger.error('API error', error, { path: req.path });
      res.status(500).json({ error: 'Internal server error' });
    }
  });

  return router;
}

// Application setup
async function createApp() {
  const express = (await import('express')).default;
  const app = express();

  app.use(express.json());

  const repository = new UserRepository();
  const service = new UserService(repository);
  app.use(createUserRouter(service));

  return app;
}

// Export for testing
export { UserService, UserRepository, ValidationError, NotFoundError, createApp };
```

**Key Patterns Demonstrated:**

- ✅ JSDoc type annotations with `// @ts-check`
- ✅ Error handling with custom error classes
- ✅ Structured logging
- ✅ Input validation
- ✅ Repository pattern
- ✅ Service layer separation
- ✅ Async/await patterns
- ✅ Type-safe API handlers
- ✅ Proper error responses

**Node.js Version**: 18+ (LTS)
**ES Version**: ES2022
