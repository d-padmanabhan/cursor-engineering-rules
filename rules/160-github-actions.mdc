---
title: GitHub Actions Engineering Ruleset
description: Secure, fast, maintainable workflows for this repo.
alwaysApply: false         # keep false so it only targets GHA files
priority: 160              # higher than your core.mdc (e.g., 100)
files:
  include:
    - ".github/workflows/**/*.yml"
    - ".github/workflows/**/*.yaml"
    - ".github/actions/**/*.yml"
    - ".github/actions/**/*.yaml"
---

# GitHub Actions Engineering Ruleset

**Audience**: engineers writing and reviewing GitHub Actions
**Goal**: secure, fast, maintainable workflows - without over-engineering

## GitHub Actions Philosophy (Core Principles)

**Core Principles:**

- **"Security by default"** - Start with zero permissions, grant only what's needed
- **"Fail fast, fail clearly"** - Use timeouts, clear error messages, proper exit codes
- **"Cache aggressively, invalidate wisely"** - Cache dependencies and artifacts, version keys properly
- **"Composition over duplication"** - Use reusable workflows and composite actions
- **"Explicit over implicit"** - Document everything, use clear naming, avoid magic
- **"Performance matters"** - Parallelize where possible, skip unnecessary runs, optimize caching
- **"Observability is essential"** - Use summaries, annotations, structured logging
- **"Trust but verify"** - Validate inputs, sanitize outputs, audit dependencies

**Applying GitHub Actions Principles:**

```yaml
# BAD: Implicit, insecure, slow
on: [push]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - run: npm install && npm test

# GOOD: Explicit, secure, optimized
name: CI Pipeline

on:
  push:
    branches: [main]
    paths:
      - 'src/**'
      - 'package*.json'

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions: {}

jobs:
  build:
    name: Build and Test
    runs-on: ubuntu-latest
    timeout-minutes: 30
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v4

      - name: Cache dependencies
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm test
```

> Note: where your original guidance conflicted with how Actions actually works, I kept your text and added a short **Note** immediately under it so the doc remains complete and correct.

---

##  Quick Reference

### Essential Checklist
- [ ] Workflows use minimal permissions (`permissions: {}` at root)
- [ ] Secrets never logged or exposed in artifacts
- [ ] Concurrency control configured for appropriate workflows
- [ ] Timeout values set on all jobs
- [ ] Shell scripts use `set -euo pipefail` or `set -uo pipefail` depending on context
- [ ] Environment variables quoted: `"$GITHUB_ENV"`
- [ ] PR workflows use `pull_request`, not `pull_request_target`
- [ ] Caching implemented for dependencies
- [ ] Job summaries provide actionable information

### Common Patterns Quick Links
- [Concurrency Control](#concurrency-control)
- [Matrix Builds](#matrix-builds)
- [Caching Strategy](#caching-strategy)
- [PR Comments](#pr-comment-with-deletion-support-when-necessary)
- [Workflow Summaries](#workflow-summary)
- [Troubleshooting Guide](#troubleshooting-guide)

---

## Core Objectives

- **Performance Optimization** - analyze and improve efficiency, speed, resource use while keeping functionality
- **Security & Quality** - review for bugs, inefficiencies, security gaps (details matter)
- **Modularity** - break into smaller reusable units where it makes sense

## Code Principles

- **DRY** - avoid duplication
- **KISS** - keep it simple
- **YAGNI** - do not add what you will not need
- **Fail Fast** - validate early, stop early

---

## Workflow Structure & Naming

- Use kebab-case for job names and step names
- Use descriptive, Title Case for workflow names (displayed in UI)
- Use kebab-case for workflow filenames

- Add descriptive documentation explaining purpose, inputs, outputs


  - `name:` (workflow plus each job)
  - `run-name:` for dynamic run titles
  - a header comment at the top of the YAML
  - repo docs like `GHA-RULESET.md` or `README.md`

- Pin actions to specific versions like `@v4`, `@v3` for stability

**For AI Agents Authoring Workflows:**

When initially creating GitHub Actions workflows, **for every action** you add, use `gh api` to fetch the latest release tag and extract the **major version** to pin:

```bash
# Get latest MAJOR version for any action (replace OWNER/REPO with the action's repository)
gh api repos/OWNER/REPO/releases/latest --jq '.tag_name | split(".")[0]'
# Returns: v4 (extracts major version from v4.2.2)

# Use in workflow with the major version
- uses: OWNER/REPO@v4
```

**Rationale:**
- AI agents should use the most current stable **major** version when initially authoring workflows
- Using major versions (e.g., `@v4`) allows automatic minor/patch updates while avoiding breaking changes
- This applies to **all actions**, not just common ones
- After initial creation, Dependabot will handle keeping actions updated automatically
- This ensures workflows start with recent versions while maintaining reproducibility

**Examples for common actions:**
```bash
# Checkout - get latest major version
gh api repos/actions/checkout/releases/latest --jq '.tag_name | split(".")[0]'
# Returns: v6 (as of Jan 2026)

# Setup Node - get latest major version
gh api repos/actions/setup-node/releases/latest --jq '.tag_name | split(".")[0]'
# Returns: v4

# GitHub Script - get latest major version
gh api repos/actions/github-script/releases/latest --jq '.tag_name | split(".")[0]'
# Returns: v7

# AWS Configure Credentials - get latest major version
gh api repos/aws-actions/configure-aws-credentials/releases/latest --jq '.tag_name | split(".")[0]'
# Returns: v5 (as of Jan 2026)

# Cache - get latest major version
gh api repos/actions/cache/releases/latest --jq '.tag_name | split(".")[0]'
# Returns: v4

# Upload Artifact - get latest major version
gh api repos/actions/upload-artifact/releases/latest --jq '.tag_name | split(".")[0]'
# Returns: v4
```

- Use `@main` only for experiments

- Review [https://docs.github.com/en/actions](https://docs.github.com/en/actions) and adopt relevant best practices

- **Documentation**: include purpose, inputs, outputs in comments and repo docs

### Example Workflow Header

**Important:** Add a description of what the workflow does as comments right after the workflow name.

```yaml
name: Deploy Infrastructure

# ================================================================
# Purpose: Manages Terraform deployments to AWS production
#
# Triggers:
#   - Push to main (auto-deploy)
#   - Manual workflow dispatch
#   - PR (plan only)
#
# Required Secrets:
#   - AWS_ROLE_ARN: OIDC role for AWS access
#   - SLACK_WEBHOOK: Notifications endpoint
#
# Dependencies:
#   - terraform/modules/* must be validated
#   - Requires approval from platform team for prod
# ================================================================

run-name: Deploy Infrastructure - ${{ github.event_name }} by @${{ github.actor }}
```

---

## Workflow-Level Configuration

### Concurrency Control

Where it makes sense, prevent overlapping runs:

```yaml
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true
```

- Use `cancel-in-progress: true` for CI and lint
- Use `cancel-in-progress: false` for deploys and applies

### Advanced Concurrency Patterns

```yaml
# For deployments - queue them instead of canceling
concurrency:
  group: deploy-${{ github.event.inputs.environment }}
  cancel-in-progress: false

# For PR builds - group by PR number
concurrency:
  group: pr-${{ github.event.pull_request.number }}
  cancel-in-progress: true

# For scheduled jobs - ensure single instance
concurrency:
  group: scheduled-cleanup
  cancel-in-progress: false
```

### Permissions (Principle of Least Privilege)

Start with minimum permissions and escalate per job:

```yaml
permissions: {}
```

- Grant only what is needed:

```yaml
permissions:
  contents: read
  pull-requests: write
```

**Notes**:

- There is no `actions: none`. Valid levels are `read` or `write`. Use `{}` to start at zero and add at job level.
- Commenting on PRs usually needs `issues: write` since PR comments go through the Issues API.

### Common Permission Patterns

```yaml
# For releases and tags
permissions:
  contents: write
  packages: write
  id-token: write  # For OIDC

# For dependency updates
permissions:
  contents: write
  pull-requests: write

# For security scanning
permissions:
  security-events: write
  actions: read
  contents: read
```

---

## Job-Level Configuration

- Add `timeout-minutes:` per job where it makes sense (for example 60), but skip for Terraform plan/apply if that clashes with your expectations
- Add documentation for each job using `name:` and a header comment near the job
- Use `needs:` to set dependencies and order
- Configure `continue-on-error: true` for non-critical steps
- For matrix builds, configure:

```yaml
strategy:
  fail-fast: true
```

**Note**: `fail-fast` exists under `strategy`, not at the job root.

### Job Environment Configuration

```yaml
jobs:
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-24.04
    timeout-minutes: 30
    environment:
      name: production
      url: https://app.acme.com
    permissions:
      id-token: write
      contents: read
```

---

## Conditional Execution

Where it makes sense:

- `if: github.event_name == 'pull_request'`
- `if: github.event_name == 'push'`
- `if: github.ref == 'refs/heads/main'`
- `if: startsWith(github.ref, 'refs/tags/')`

### Advanced Conditional Patterns

```yaml
# Skip CI on certain commits
if: ${{ !contains(github.event.head_commit.message, '[skip ci]') }}

# Only on specific PR labels
if: contains(github.event.pull_request.labels.*.name, 'deploy')

# Complex conditions
if: |
  github.event_name == 'push' &&
  github.ref == 'refs/heads/main' &&
  github.repository == 'myorg/main-repo'

# Check for secrets availability
if: ${{ secrets.DEPLOY_KEY != '' }}

# Only on successful previous job
if: ${{ needs.test.result == 'success' }}
```

---

## Environment Variables & Outputs

### Setting Environment Variables

Where it makes sense, use `GITHUB_ENV`:

```yaml
- name: set-environment-variables
  run: |
    {
      echo "VARIABLE_ONE=value"
      echo "VARIABLE_TWO<<EOF"
      echo "multiline"
      echo "value"
      echo "EOF"
    } >> "$GITHUB_ENV"
```

- When you set `env` for a step, put it **before** `run`, not after

### Using Outputs

Use `GITHUB_OUTPUT`:

```yaml
- name: generate-output
  id: output-step
  run: echo "result=success" >> "$GITHUB_OUTPUT"

- name: use-output
  run: echo "Previous step result: ${{ steps.output-step.outputs.result }}"
```

### Cross-Job Outputs

```yaml
jobs:
  setup:
    outputs:
      version: ${{ steps.get-version.outputs.version }}
      should-deploy: ${{ steps.check.outputs.should-deploy }}
    steps:
      - id: get-version
        run: echo "version=$(cat VERSION)" >> "$GITHUB_OUTPUT"
      - id: check
        run: echo "should-deploy=${{ github.ref == 'refs/heads/main' }}" >> "$GITHUB_OUTPUT"

  deploy:
    needs: setup
    if: ${{ needs.setup.outputs.should-deploy == 'true' }}
    steps:
      - run: echo "Deploying version ${{ needs.setup.outputs.version }}"
```

### GitHub Token Usage

Where it makes sense, use `GITHUB_TOKEN` for GitHub API and repo ops

### Git Configuration

Where it makes sense:

```yaml
env:
  GIT_COMMITTER_NAME: ${{ github.actor }}
  GIT_COMMITTER_EMAIL: ${{ github.actor }}@users.noreply.github.com
  GIT_AUTHOR_NAME: ${{ github.actor }}
  GIT_AUTHOR_EMAIL: ${{ github.actor }}@users.noreply.github.com
```

### Summary Reporting

Where it makes sense, use `GITHUB_STEP_SUMMARY` or `actions/github-script`:

```yaml
- name: write-summary
  if: always()
  run: |
    {
      echo "## Workflow Summary"
      echo "- Event: ${{ github.event_name }}"
      echo "- Ref:   ${{ github.ref_name }}"
    } >> "$GITHUB_STEP_SUMMARY"
```

### Enhanced Summary with Markdown

```yaml
- name: generate-test-summary
  if: always()
  run: |
    {
      echo "##  Test Results"
      echo ""
      echo "| Metric | Value |"
      echo "|--------|-------|"
      echo "| Total Tests | ${{ env.TOTAL_TESTS }} |"
      echo "| Passed |  ${{ env.PASSED_TESTS }} |"
      echo "| Failed |  ${{ env.FAILED_TESTS }} |"
      echo "| Coverage | ${{ env.COVERAGE }}% |"
      echo ""
      if [ "${{ env.FAILED_TESTS }}" -gt 0 ]; then
        echo "###  Failed Tests"
        echo '```'
        cat test-failures.txt
        echo '```'
      fi
      echo ""
      echo "**Duration:** ${{ env.TEST_DURATION }}s"
      echo "**Full report:** [View in artifacts]()"
    } >> "$GITHUB_STEP_SUMMARY"
```

---

## Advanced Features

### Matrix Builds

Where it makes sense, test across versions, OS, or configs. Cap parallelism with `max-parallel` for resource control.

```yaml
strategy:
  matrix:
    os: [ubuntu-latest, windows-latest, macos-latest]
    node: [18, 20, 22]
    exclude:
      - os: windows-latest
        node: 18
    include:
      - os: ubuntu-latest
        node: 22
        experimental: true
  max-parallel: 4
  fail-fast: false
```

### Dynamic Matrix Generation

```yaml
jobs:
  setup:
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - id: set-matrix
        run: |
          matrix=$(cat .github/matrix.json | jq -c .)
          echo "matrix=$matrix" >> "$GITHUB_OUTPUT"

  test:
    needs: setup
    strategy:
      matrix: ${{ fromJSON(needs.setup.outputs.matrix) }}
```

### Caching Strategy

Where it makes sense, cache:

- Dependencies (pip, npm, maven, etc.)
- Build artifacts
- Test results and coverage
- Docker layers

Use versioned keys and restore keys to balance hit rate vs freshness.

```yaml
- name: cache-node-modules
  uses: actions/cache@v4
  with:
    path: ~/.npm
    key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
    restore-keys: |
      ${{ runner.os }}-node-
      ${{ runner.os }}-

- name: cache-docker-layers
  uses: actions/cache@v4
  with:
    path: /tmp/.buildx-cache
    key: ${{ runner.os }}-buildx-${{ github.sha }}
    restore-keys: |
      ${{ runner.os }}-buildx-
```

### Reusability

Where appropriate:

- **Composite actions** for shared step sequences
- **Reusable workflows** via `workflow_call`
- Inputs, secrets, and outputs well defined

#### Composite Action Example

Create reusable step sequences without full workflow overhead.

**File:** `.github/actions/setup-node-cache/action.yml`

```yaml
name: 'Setup Node with Cache'
description: 'Install Node.js and restore npm cache'
inputs:
  node-version:
    description: 'Node.js version'
    required: false
    default: '20'
runs:
  using: 'composite'
  steps:
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ inputs.node-version }}

    - name: Cache npm dependencies
      uses: actions/cache@v4
      with:
        path: ~/.npm
        key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-node-

    - name: Install dependencies
      shell: bash
      run: npm ci
```

**Usage:**
```yaml
steps:
  - uses: actions/checkout@v4
  - uses: ./.github/actions/setup-node-cache
    with:
      node-version: '20'
  - run: npm test
```

#### Reusable Workflow Example

```yaml
# .github/workflows/reusable-deploy.yml
name: Reusable Deploy

on:
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
      version:
        required: false
        type: string
        default: latest
    secrets:
      deploy-key:
        required: true
    outputs:
      url:
        description: "Deployment URL"
        value: ${{ jobs.deploy.outputs.url }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    outputs:
      url: ${{ steps.deploy.outputs.url }}
    steps:
      - name: deploy
        id: deploy
        env:
          DEPLOY_KEY: ${{ secrets.deploy-key }}
        run: |
          # deployment logic
          echo "url=https://${{ inputs.environment }}.acme.com" >> "$GITHUB_OUTPUT"
```

---

## Common Mistakes & Anti-Patterns

### 1. Using `pull_request_target` Unsafely
```yaml
#  DANGER - Runs untrusted code with write permissions
on: pull_request_target
jobs:
  test:
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
      - run: npm test  # Attacker can inject malicious code!

#  Safe - Limit permissions, run trusted code only
on: pull_request_target
jobs:
  test:
    permissions:
      contents: read
```

### 2. Not Quoting Context Variables
```yaml
#  Wrong
- run: echo ${{ github.event.head_commit.message }}

#  Correct
- run: echo "${{ github.event.head_commit.message }}"
```

### 3. Secrets in Environment Variables
```yaml
#  Wrong - Secrets can leak in logs
- run: |
    export SECRET=${{ secrets.MY_SECRET }}
    ./script.sh

#  Correct - Use env block
- env:
    SECRET: ${{ secrets.MY_SECRET }}
  run: ./script.sh
```

### 4. Not Using Path Filters
```yaml
#  Wasteful - Runs on every push
on: [push]

#  Efficient - Only run when relevant files change
on:
  push:
    paths:
      - 'src/**'
      - 'package*.json'
```

### 5. Hardcoding Runner OS Commands
```yaml
#  Fragile - Breaks on Windows/macOS
- run: rm -rf dist/

#  Portable - Use actions or shell-agnostic commands
- run: |
    if [ -d dist ]; then rm -rf dist; fi
  shell: bash
```

### 6. Missing Timeout Protection
```yaml
#  Can run for 6 hours (GitHub default)
jobs:
  test:
    runs-on: ubuntu-latest

#  Fail fast on hangs
jobs:
  test:
    runs-on: ubuntu-latest
    timeout-minutes: 30
```

### 7. Not Handling Matrix Failures Gracefully
```yaml
#  One failure cancels all jobs
strategy:
  matrix:
    os: [ubuntu-latest, windows-latest, macos-latest]

#  Continue testing all combinations
strategy:
  fail-fast: false
  matrix:
    os: [ubuntu-latest, windows-latest, macos-latest]
```

### 8. Not Cleaning Up Artifacts
```yaml
#  Artifacts kept for 90 days (GitHub default)
- uses: actions/upload-artifact@v4
  with:
    name: logs

#  Set appropriate retention
- uses: actions/upload-artifact@v4
  with:
    name: logs
    retention-days: 7  # Adjust based on needs
```

---

# ARCHIVES

## Error Handling & Debugging

- Use strict shells in `run:`:

```yaml
- name: example-step-with-error-handling
  run: |
    set -euo pipefail
    echo "::debug::Starting operation with detailed logging"
    # your commands
    echo "::notice::Operation completed successfully"
    # if you need to surface a failure condition manually:
    # echo "::error::Something failed"
  continue-on-error: false
```

- Turn on debug only when needed:

  - `ACTIONS_RUNNER_DEBUG: true`
  - `ACTIONS_STEP_DEBUG: true`

### Advanced Error Handling

```yaml
- name: robust-error-handling
  id: critical-step
  run: |
    set -euo pipefail

    # Trap errors and provide context
    trap 'echo "::error file=deploy.sh,line=$LINENO::Command failed with exit code $?"' ERR

    # Validate prerequisites
    if [ ! -f "config.json" ]; then
      echo "::error file=config.json::Configuration file missing"
      exit 1
    fi

    # Execute with retry logic
    for i in {1..3}; do
      if ./deploy.sh; then
        echo "success=true" >> "$GITHUB_OUTPUT"
        break
      else
        echo "::warning::Attempt $i failed, retrying..."
        sleep 5
      fi
    done

    # Check final status
    if [ "${{ steps.critical-step.outputs.success }}" != "true" ]; then
      echo "::error::All retry attempts failed"
      exit 1
    fi
```

---

## Common Workflow Patterns

### Get Changed Files

```yaml
- name: get-changed-files
  id: changed_files
  uses: tj-actions/changed-files@ed68ef82c095e0d48ec87eccea555d944a631a4c # v46.0.5
  with:
    files: '**.py'
    write_output_files: true
```

### Monorepo Path Filtering

```yaml
- name: check-changes
  uses: dorny/paths-filter@v3
  id: changes
  with:
    filters: |
      backend:
        - 'backend/**'
        - 'shared/**'
      frontend:
        - 'frontend/**'
        - 'shared/**'
      docs:
        - '**.md'
        - 'docs/**'

# Later in the workflow
- name: test-backend
  if: steps.changes.outputs.backend == 'true'
  run: cd backend && npm test
```

---

## PR Comment with deletion support when necessary

```yaml
- name: update-pr-with-terraform-plan
  if: github.event_name == 'pull_request'
  uses: actions/github-script@v7
  with:
    github-token: ${{ secrets.GITHUB_TOKEN }}
    script: |
      // Retrieve existing comments
      const { data: comments } = await github.rest.issues.listComments({
        owner: context.repo.owner,
        repo: context.repo.repo,
        issue_number: context.issue.number,
      });

      // Find previous bot comment
      const botComment = comments.find(comment =>
        comment.user?.type === 'Bot' && comment.body?.includes('Terraform Plan Summary')
      );

      // Parse affected resources from plan output
      const resources = `${{ steps.plan.outputs.resources }}`.split('\n').filter(Boolean);
      const resourcesList = resources.length > 0 && resources[0] !== 'No changes'
        ? resources.map(r => `- ${r}`).join('\n')
        : 'No changes detected';

      const output = `#### Terraform Plan Summary
\`\`\`
Plan: ${{ steps.plan.outputs.add }} to add, ${{ steps.plan.outputs.change }} to change, ${{ steps.plan.outputs.destroy }} to destroy.
\`\`\`

**Affected Resources:**
\`\`\`
${resourcesList}
\`\`\`
`;

      // Delete previous comment
      if (botComment) {
        await github.rest.issues.deleteComment({
          owner: context.repo.owner,
          repo: context.repo.repo,
          comment_id: botComment.id,
        });
      }

      await github.rest.issues.createComment({
        issue_number: context.issue.number,
        owner: context.repo.owner,
        repo: context.repo.repo,
        body: output
      });
```

**Note**: this typically needs `permissions: { issues: write, contents: read }` on the job.

---

## Workflow Summary

Add a workflow summary when it makes sense:

```yaml
- name: generate-workflow-summary
  if: always()
  uses: actions/github-script@v8
  with:
    script: |
      let summary = `## Infrastructure Provisioning Summary\n\n`;
      summary += `- **Trigger:** ${{ github.event_name }}\n`;
      summary += `- **Branch:** ${{ github.ref_name }}\n`;
      summary += `- **Actor:** ${{ github.actor }}\n`;
      summary += `- **Terraform Version:** ${{ env.TF_VERSION }}\n\n`;

      if ('${{ github.event_name }}' === 'pull_request') {
        summary += `### Plan Results\n`;
        summary += `- **Add:** ${{ steps.plan.outputs.add }} resources\n`;
        summary += `- **Change:** ${{ steps.plan.outputs.change }} resources\n`;
        summary += `- **Destroy:** ${{ steps.plan.outputs.destroy }} resources\n\n`;
        summary += `Ready for review\n`;
      } else if ('${{ github.ref }}' === 'refs/heads/main') {
        summary += `### Apply Results\n`;
        if ('${{ job.status }}' === 'success') {
          summary += `Infrastructure changes applied successfully\n`;
        } else {
          summary += `Infrastructure deployment failed\n`;
        }
      }

      await core.summary.addRaw(summary).write();
```

---

## Documentation Standards

Include header comments in workflow files that cover:

- Workflow purpose and scope
- Required secrets and env vars
- Dependencies on external services or other workflows
- Expected triggers and execution conditions
- Manual intervention or approval gates
- Troubleshooting guidance

---

## Security Considerations

Where it makes sense:

- Use secrets management for sensitive data
- Prefer **OIDC** to cloud providers over static creds
- Validate inputs and sanitize user data
- Use **read-only** permissions by default
- Use the latest versions of actions unless pinned for stability
- Audit workflow dependencies regularly
- Avoid `pull_request_target` unless fully sandboxed
- Set explicit `retention-days` for artifacts and logs
- Mask secrets in logs and summaries

### OIDC Setup for AWS

```yaml
jobs:
  deploy:
    permissions:
      id-token: write
      contents: read
    steps:
      - name: configure-aws-credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: us-east-1
          role-session-name: GitHubActions-${{ github.run_id }}
```

### Input Validation

```yaml
on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        type: choice
        options:
          - development
          - staging
          - production
      version:
        description: 'Version to deploy (semver format)'
        required: true
        type: string

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - name: validate-inputs
        run: |
          # Validate version format
          if ! [[ "${{ inputs.version }}" =~ ^v?[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "::error::Invalid version format. Expected semver (e.g., 1.2.3 or v1.2.3)"
            exit 1
          fi

          # Validate environment permissions
          if [[ "${{ inputs.environment }}" == "production" ]] && [[ "${{ github.actor }}" != "approved-user" ]]; then
            echo "::error::User ${{ github.actor }} not authorized for production deployments"
            exit 1
          fi
```

### Security Scanning Integration

**CodeQL Analysis:**
```yaml
- name: Initialize CodeQL
  uses: github/codeql-action/init@v3
  with:
    languages: javascript, python

- name: Perform CodeQL Analysis
  uses: github/codeql-action/analyze@v3
```

**Dependency Scanning:**
```yaml
- name: Run Trivy vulnerability scanner
  uses: aquasecurity/trivy-action@master
  with:
    scan-type: 'fs'
    scan-ref: '.'
    format: 'sarif'
    output: 'trivy-results.sarif'

- name: Upload to Security tab
  uses: github/codeql-action/upload-sarif@v3
  with:
    sarif_file: 'trivy-results.sarif'
```

---

## Self-Hosted Runners

### When to Use

**GitHub-hosted runners for:**
- Standard CI/CD workflows
- Open source projects
- Moderate compute needs

**Self-hosted runners for:**
- Enterprise compliance requirements
- Custom hardware/GPU needs
- Private network access
- High-volume cost optimization

### Security Warning

** CRITICAL:** Never use self-hosted runners for public repositories!
- Attackers can fork and send malicious PRs
- Self-hosted runners access internal network
- GitHub-hosted runners are ephemeral and isolated

### Setup

```yaml
# Runner with labels
runs-on: [self-hosted, linux, x64, gpu]

# Runner group
runs-on:
  group: production-runners
  labels: linux
```

---

## GitHub Environments

### Protected Environments

**Settings -> Environments -> New environment**

Protection rules:
- Required reviewers (1-6 people/teams)
- Wait timer (0-43,200 minutes)
- Deployment branches restrictions

### Usage

```yaml
jobs:
  deploy-production:
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://app.acme.com
    steps:
      - run: ./deploy.sh production
```

**Environment-specific secrets:** Only available when deploying to that environment

### Dynamic Input Choices

Use `workflow_dispatch` with choice inputs for better UX:

```yaml
on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        type: choice
        options:
          - development
          - staging
          - production
      log-level:
        description: 'Log level'
        type: choice
        options:
          - debug
          - info
          - warning
          - error
        default: 'info'
      dry-run:
        description: 'Dry run mode'
        type: boolean
        default: false

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Deploy
        run: |
          echo "Deploying to ${{ inputs.environment }}"
          echo "Log level: ${{ inputs.log-level }}"
          echo "Dry run: ${{ inputs.dry-run }}"
```

---

## Performance Optimization

**Golden Rule:** Measure workflow run times, identify bottlenecks, optimize iteratively.

Where it makes sense:

- Minimize startup cost with efficient caching
- Parallelize independent operations with matrices
- Choose appropriate runners and pin images (for example `ubuntu-24.04`)
- Stop early on failing builds
- Optimize Docker builds with multi-stage patterns and layer caching
- Use GitHub-hosted runners efficiently or self-hosted for special workloads
- Use `paths` and `paths-ignore` to skip unnecessary runs
- Use `concurrency` to squash duplicate CI runs for the same ref

### Performance Optimization Examples

**Parallel Job Execution:**

```yaml
# BAD: Sequential jobs (slow)
jobs:
  lint:
    steps: [ ... ]
  test:
    needs: lint
    steps: [ ... ]
  build:
    needs: test
    steps: [ ... ]

# GOOD: Parallel independent jobs (fast)
jobs:
  lint:
    steps: [ ... ]
  test:
    steps: [ ... ]
  build:
    steps: [ ... ]

  deploy:
    needs: [lint, test, build]  # Only deploy after all pass
    steps: [ ... ]
```

**Efficient Caching:**

```yaml
# BAD: Cache key too specific (low hit rate)
- uses: actions/cache@v4
  with:
    path: ~/.npm
    key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}-${{ github.sha }}

# GOOD: Layered cache keys (high hit rate)
- uses: actions/cache@v4
  with:
    path: ~/.npm
    key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
    restore-keys: |
      ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}-
      ${{ runner.os }}-node-
      ${{ runner.os }}-
```

**Conditional Step Execution:**

```yaml
# BAD: Always runs expensive operations
- name: Build Docker image
  run: docker build -t app .
- name: Push to registry
  run: docker push app

# GOOD: Only build/push when needed
- name: Build Docker image
  if: github.event_name == 'push' && github.ref == 'refs/heads/main'
  run: docker build -t app .

- name: Push to registry
  if: github.event_name == 'push' && github.ref == 'refs/heads/main'
  run: docker push app
```

**Matrix Optimization:**

```yaml
# BAD: Tests all combinations sequentially
strategy:
  matrix:
    os: [ubuntu-latest, windows-latest, macos-latest]
    node: [18, 20, 22]
  max-parallel: 1  # Sequential

# GOOD: Parallel execution with limits
strategy:
  matrix:
    os: [ubuntu-latest, windows-latest, macos-latest]
    node: [18, 20, 22]
  max-parallel: 6  # Run 6 jobs in parallel
  fail-fast: false  # Don't cancel others on failure
```

**Artifact Optimization:**

```yaml
# BAD: Uploads everything including unnecessary files
- uses: actions/upload-artifact@v4
  with:
    path: dist/

# GOOD: Selective upload with compression
- uses: actions/upload-artifact@v4
  with:
    name: build-artifacts
    path: |
      dist/
      !dist/**/*.map  # Exclude source maps
      !dist/**/*.test.js  # Exclude test files
    retention-days: 7
    compression-level: 6  # Balance speed vs size
```

**Dependency Installation Optimization:**

```yaml
# BAD: Installs all dependencies including dev
- name: Install dependencies
  run: npm install

# GOOD: CI-specific install (faster, smaller)
- name: Install dependencies
  run: npm ci --omit=dev  # Skip dev dependencies in CI

# GOOD: Use lockfile for reproducible builds
- name: Install dependencies
  run: npm ci  # Uses package-lock.json, faster than npm install
```

### Path Filtering Examples

```yaml
on:
  push:
    paths:
      - 'src/**'
      - 'package*.json'
      - '.github/workflows/ci.yml'
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.gitignore'
```

### Docker Optimization

```yaml
- name: setup-docker-buildx
  uses: docker/setup-buildx-action@v3

- name: build-and-push
  uses: docker/build-push-action@v5
  with:
    context: .
    push: true
    tags: ${{ steps.meta.outputs.tags }}
    cache-from: type=gha
    cache-to: type=gha,mode=max
    platforms: linux/amd64,linux/arm64
```

---

## Testing & Validation

Where it makes sense:

- Use `act` or similar tools for local workflow testing
- Implement test workflows for critical paths
- Use canary deployments for production changes
- Review and update workflows regularly as requirements change
- Add feedback loops from users and stakeholders
- Lint workflows with `actionlint`
- Use dry-run modes when available
- Add smoke tests after deploy
- Use integration tests for cross-service validation
- Use end-to-end tests for the full path
- Add unit tests for individual components where applicable

### Workflow Testing Patterns

**Local Testing with Act:**

```bash
# Test specific workflow
act push -W .github/workflows/ci.yml

# Test with secrets
act push -s GITHUB_TOKEN=$GITHUB_TOKEN

# Test specific job
act -j test

# Dry run (list what would run)
act -l

# Test with matrix
act -j test --matrix os:ubuntu-latest,node:20
```

**Workflow Linting:**

```bash
# Install actionlint
brew install actionlint  # macOS
# or
go install github.com/rhymond/actionlint/cmd/actionlint@latest

# Lint workflow
actionlint .github/workflows/*.yml

# CI integration
- name: Lint workflows
  uses: reviewdog/action-actionlint@v1
  with:
    github_token: ${{ secrets.GITHUB_TOKEN }}
```

**Test Workflow Pattern:**

```yaml
# .github/workflows/test-workflow.yml
name: Test Workflow

on:
  workflow_dispatch:
    inputs:
      workflow_file:
        description: 'Workflow file to test'
        required: true
        type: string

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Validate workflow syntax
        run: |
          yamllint "${{ inputs.workflow_file }}"
          actionlint "${{ inputs.workflow_file }}"

      - name: Test with act
        run: |
          act push -W "${{ inputs.workflow_file }}" --dry-run
```

**Dry-Run Patterns:**

```yaml
# Terraform dry-run
- name: Terraform Plan
  run: terraform plan -out=tfplan
  if: github.event_name == 'pull_request'

- name: Terraform Apply
  run: terraform apply tfplan
  if: github.ref == 'refs/heads/main'

# Deployment dry-run
- name: Deploy (Dry Run)
  if: github.event_name == 'pull_request'
  run: |
    ./deploy.sh --dry-run --environment staging

- name: Deploy (Production)
  if: github.ref == 'refs/heads/main'
  run: |
    ./deploy.sh --environment production
```

**Smoke Tests:**

```yaml
- name: Deploy to Staging
  run: ./deploy.sh staging

- name: Smoke Tests
  run: |
    # Health check
    curl -f https://staging.acme.com/health || exit 1

    # API endpoint check
    curl -f https://staging.acme.com/api/v1/status || exit 1

    # Database connectivity
    ./scripts/check-db-connection.sh staging || exit 1
```

### Local Testing with Act

**Installation:**
```bash
brew install act  # macOS
# or
curl https://raw.githubusercontent.com/nektos/act/master/install.sh | sudo bash
```

**Usage:**
```bash
# List workflows
act -l

# Test workflow locally
act push -W .github/workflows/ci.yml

# Test specific job
act -j test

# Test with secrets
act -s MY_SECRET=value
```

**Skipping Steps for Local Runs:**
```yaml
- name: Deploy to Production
  if: ${{ !env.ACT && github.ref == 'refs/heads/main' }}
  run: ./scripts/deploy.sh
```

---

## Troubleshooting Guide

### Common Issues and Solutions

#### 1. Permission Denied Errors

**Problem**: `Error: HttpError: Resource not accessible by integration`

**Solution**: Check job permissions:
```yaml
permissions:
  contents: read
  issues: write  # For PR comments
  pull-requests: write
```

#### 2. Workflow Not Triggering

**Problem**: Workflow doesn't run on push/PR

**Solutions**:
- Check path filters match your changes
- Verify branch protection rules
- Ensure workflow file is in default branch for `workflow_dispatch`
- Check if workflows are disabled in repository settings

#### 3. Cache Miss Issues

**Problem**: Cache never hits despite same dependencies

**Solutions**:
```yaml
- uses: actions/cache@v4
  with:
    path: ~/.npm
    # Use both exact and restore keys
    key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}-${{ hashFiles('.github/workflows/*.yml') }}
    restore-keys: |
      ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}-
      ${{ runner.os }}-node-
```

#### 4. Secrets Not Available

**Problem**: `${{ secrets.MY_SECRET }}` is empty

**Solutions**:
- Check secret is defined at correct level (repo/org/environment)
- Verify secret name matches exactly (case-sensitive)
- For forks, secrets aren't available in `pull_request` events
- Use `if: ${{ secrets.MY_SECRET != '' }}` to check availability

#### 5. Matrix Job Failures

**Problem**: One matrix job fails, all others cancelled

**Solution**: Set `fail-fast: false`:
```yaml
strategy:
  fail-fast: false
  matrix:
    # your matrix config
```

#### 6. Artifact Upload Issues

**Problem**: Large artifacts fail or timeout

**Solutions**:
```yaml
- uses: actions/upload-artifact@v4
  with:
    name: my-artifact
    path: |
      dist/
      !dist/**/*.map
    retention-days: 5
    compression-level: 6  # Balance speed vs size
```

#### 7. Runner Out of Disk Space

**Problem**: `No space left on device`

**Solution**: Clean up before large operations:
```yaml
- name: free-disk-space
  run: |
    sudo rm -rf /usr/local/lib/android
    sudo rm -rf /usr/share/dotnet
    sudo rm -rf /opt/ghc
    sudo rm -rf /usr/local/share/boost
    sudo apt-get clean
    df -h
```

#### 8. GitHub API Rate Limiting

**Problem**: `API rate limit exceeded`

**Solution**: Use built-in token when possible:
```yaml
- uses: actions/github-script@v7
  with:
    github-token: ${{ secrets.GITHUB_TOKEN }}
    # Token automatically has higher rate limits
```

---
# DO NOT USE!!

## Deployment & Release Best Practices

Where it makes sense:

- Use environments and protection rules for deploys, so secrets and approvals are scoped

- For forks: never run untrusted code with write perms. Avoid `pull_request_target` unless you fetch a reviewed ref and gate all secrets

- Set artifact and cache retention lower by default, increase only where needed

### Release Automation Example

```yaml
name: Release

on:
  push:
    tags:
      - 'v*.*.*'

jobs:
  release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write
      id-token: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: validate-tag
        run: |
          if ! git describe --exact-match --tags HEAD; then
            echo "::error::Not on a tag"
            exit 1
          fi

      - name: generate-changelog
        id: changelog
        run: |
          # Generate changelog from commits
          git log --pretty=format:"- %s (%h)" $(git describe --tags --abbrev=0 HEAD^)..HEAD > CHANGELOG.md

      - name: create-release
        uses: softprops/action-gh-release@v1
        with:
          body_path: CHANGELOG.md
          draft: false
          prerelease: ${{ contains(github.ref, '-rc') || contains(github.ref, '-beta') }}
          generate_release_notes: true
```

### Notification Example

```yaml
- name: notify-slack
  if: always()
  uses: 8398a7/action-slack@v3
  with:
    status: ${{ job.status }}
    text: |
      Workflow: ${{ github.workflow }}
      Job: ${{ github.job }}
      Status: ${{ job.status }}
      Repo: ${{ github.repository }}
      Author: ${{ github.actor }}
    webhook_url: ${{ secrets.SLACK_WEBHOOK }}
    fields: repo,message,commit,author,action,eventName,ref,workflow
```

---

## Repository Structure Recommendations

```
.github/
 workflows/
    ci.yml                 # Continuous Integration
    cd.yml                 # Continuous Deployment
    security.yml           # Security scanning
    release.yml            # Release automation
    cleanup.yml            # Scheduled maintenance
 actions/
    custom-action/         # Composite actions
        action.yml
        README.md
 CODEOWNERS                 # Workflow approval requirements
 dependabot.yml             # Keep actions updated
```

---

## Final Notes

- **Start simple**: Don't implement every pattern at once
- **Measure impact**: Use workflow run analytics to identify bottlenecks
- **Iterate**: Workflows should evolve with your project needs
- **Share knowledge**: Document failures and solutions for your team
- **Stay updated**: GitHub Actions features evolve rapidly - review quarterly

Remember: The best workflow is one that's understood by your team, maintainable, and delivers value without unnecessary complexity.

## Comprehensive Example Workflow

Complete example demonstrating GitHub Actions best practices:

```yaml
name: CI/CD Pipeline

# ================================================================
# Purpose: Complete CI/CD pipeline with testing, building, and deployment
#
# Triggers:
#   - Push to main (full pipeline)
#   - Pull requests (test and lint only)
#   - Manual workflow dispatch
#
# Required Secrets:
#   - AWS_ROLE_ARN: OIDC role for AWS access
#   - DOCKER_USERNAME: Docker Hub username
#   - DOCKER_TOKEN: Docker Hub access token
#
# Dependencies:
#   - Node.js 20+ for application
#   - Docker for container builds
# ================================================================

on:
  push:
    branches: [main]
    paths:
      - 'src/**'
      - 'package*.json'
      - '.github/workflows/ci.yml'
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        type: choice
        options:
          - staging
          - production

env:
  NODE_VERSION: '20'
  REGISTRY: docker.io
  IMAGE_NAME: ${{ github.repository }}

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: write
  packages: write

jobs:
  lint:
    name: Lint Code
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run ESLint
        run: npm run lint

      - name: Run Prettier check
        run: npm run format:check

  test:
    name: Run Tests
    runs-on: ubuntu-latest
    timeout-minutes: 15
    strategy:
      matrix:
        node-version: [18, 20, 22]
      fail-fast: false
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm test -- --coverage

      - name: Upload coverage
        uses: codecov/codecov-action@v4
        with:
          files: ./coverage/lcov.info
          fail_ci_if_error: false

  build:
    name: Build Application
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [lint, test]
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-

      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: .
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: build
    if: |
      (github.ref == 'refs/heads/main' ||
       (github.event_name == 'workflow_dispatch' &&
        github.event.inputs.environment == 'staging'))
    environment:
      name: staging
      url: https://staging.acme.com
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: us-east-1
          role-session-name: GitHubActions-${{ github.run_id }}

      - name: Deploy to staging
        run: |
          ./scripts/deploy.sh staging

      - name: Run smoke tests
        run: |
          ./scripts/smoke-tests.sh staging

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: build
    if: |
      github.event_name == 'workflow_dispatch' &&
      github.event.inputs.environment == 'production'
    environment:
      name: production
      url: https://app.acme.com
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: us-east-1
          role-session-name: GitHubActions-${{ github.run_id }}

      - name: Deploy to production
        run: |
          ./scripts/deploy.sh production

      - name: Run smoke tests
        run: |
          ./scripts/smoke-tests.sh production

  summary:
    name: Generate Summary
    runs-on: ubuntu-latest
    needs: [lint, test, build]
    if: always()
    steps:
      - name: Generate workflow summary
        uses: actions/github-script@v7
        with:
          script: |
            const summary = `## CI/CD Pipeline Summary

            ### Workflow Information
            - **Event:** ${{ github.event_name }}
            - **Branch:** ${{ github.ref_name }}
            - **Actor:** ${{ github.actor }}
            - **Commit:** ${{ github.sha }}

            ### Job Results
            | Job | Status |
            |-----|--------|
            | Lint | ${{ needs.lint.result == 'success' && '✅ Passed' || '❌ Failed' }} |
            | Test | ${{ needs.test.result == 'success' && '✅ Passed' || '❌ Failed' }} |
            | Build | ${{ needs.build.result == 'success' && '✅ Passed' || '❌ Failed' }} |

            ### Next Steps
            ${{ needs.build.result == 'success' && github.ref == 'refs/heads/main' && '- Ready for deployment to staging' || '- Fix failing jobs before proceeding' }}
            `;

            await core.summary.addRaw(summary).write();
```

**Key Patterns Demonstrated:**

- ✅ Security: Minimal permissions, OIDC for AWS
- ✅ Performance: Caching, parallel jobs, path filters
- ✅ Reliability: Timeouts, error handling, smoke tests
- ✅ Observability: Workflow summaries, structured logging
- ✅ Reusability: Environment-based deployment
- ✅ Best practices: Proper concurrency, conditional execution

---

