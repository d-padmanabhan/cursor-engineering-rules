---
title: Bash Engineering Ruleset
description: Production-grade Bash standards for portability, safety, performance, and maintainability.
priority: 140
alwaysApply: false
files:
  include:
    - "**/*.sh"
---

#  Bash Engineering Ruleset

**Scope:** Guidance for writing robust, portable Bash scripts that are easy to read, test, and operate.
**Principles:** DRY • KISS • Fail Fast • Zero Warnings.

## Bash Philosophy (Core Principles)

**Core Principles:**

- **"Fail fast, fail clearly"** - Use strict mode, validate early, provide clear error messages
- **"Quotes are your friend"** - Always quote variables unless you explicitly want word splitting
- **"Explicit over implicit"** - Use `local`, `readonly`, clear function names, document assumptions
- **"Portability matters"** - Prefer POSIX-compliant code when possible, document Bash-specific features
- **"Security by default"** - Sanitize inputs, use `mktemp`, avoid `eval`, validate file paths
- **"Composition over complexity"** - Small functions, clear separation of concerns, reusable patterns
- **"Observability is essential"** - Structured logging, proper exit codes, error context
- **"Test what you write"** - Use shellcheck, test on multiple platforms, write BATS tests

**Applying Bash Principles:**

```bash
# BAD: Implicit, unsafe, unclear
#!/bin/bash
cd $DIR
rm -rf *
for file in $(ls *.txt); do
  process $file
done

# GOOD: Explicit, safe, clear
#!/usr/bin/env bash
set -euo pipefail

readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly TARGET_DIR="${1:-}"

if [[ -z "$TARGET_DIR" ]]; then
  echo "Usage: $0 <directory>" >&2
  exit 1
fi

if [[ ! -d "$TARGET_DIR" ]]; then
  echo "Error: Directory '$TARGET_DIR' does not exist" >&2
  exit 1
fi

cd "$TARGET_DIR" || { echo "Error: Failed to cd to '$TARGET_DIR'" >&2; exit 1; }

for file in *.txt; do
  [[ -f "$file" ]] || continue
  process "$file"
done
```

---

## Quick Reference

```bash
set -euo pipefail           # Strict mode (fail-fast)
set -uo pipefail            # Controlled mode (explicit error handling)
set -Euo pipefail           # Strict + ERR trap propagation to functions
command -v cmd >/dev/null   # Check if command exists (portable)
trap 'cleanup' EXIT         # Always cleanup
flock -n 200 || exit 1      # Prevent concurrent runs
readonly VAR="value"        # Immutable constant
local var="value"           # Function-local variable
```

---

## 1) Core Standards

- **Shebang:** `#!/usr/bin/env bash` (for portability) or `#!/bin/bash` (when bash-specific features required).
- **Safety Mode:** Choose based on context:
  - `set -euo pipefail` - Strict (fail-fast for simple scripts)
  - `set -uo pipefail` - Controlled (explicit error handling for complex scripts)
  - `set -Euo pipefail` - Strict + ERR trap propagation to functions
- **Linting:** Must pass **`shellcheck`** with **0 errors/warnings**.
- **Formatting:** Must pass **`shfmt -i 2 -ci -sr -bn`** (2-space indent, indent switch/case, simplify redirects, binary ops at line end).
- **Extension:** Use `.sh` for scripts, no extension for executables in `bin/` is acceptable if documented.
- **Variable Naming:**
  - **Uppercase** for constants and configuration: `readonly MAX_RETRIES=10`, `readonly CONFIG_FILE="/etc/app.conf"`
  - **Lowercase** for local variables: `local count=0`, `local file_name="data.txt"`
  - **Uppercase convention** helps distinguish constants from variables, avoids collisions with environment variables, and follows Bash conventions

---

## 2) Error Handling & Safety

### Error Handling Modes

** Strict Mode (Fail-Fast):**
```bash
set -euo pipefail  # Exit immediately on any error
```
Use for: Simple linear scripts, dependency installation, straightforward validation.

** Controlled Mode (Explicit):**
```bash
set -uo pipefail  # No -e: you handle errors explicitly
```
Use for: Diagnostics, cleanup operations, commands where failure is expected (grep, curl with retries).

** Strict + ERR Trap Propagation:**
```bash
set -Euo pipefail  # -E ensures ERR traps propagate to functions

trap 'echo "ERROR in ${FUNCNAME[0]:-main} at line $LINENO"' ERR

func1() {
  false  # Will trigger ERR trap even inside function
}
```
Use for: Production scripts with comprehensive error handling via ERR traps.

### Best Practices

- **Variables:** Always quote variables `"${VAR}"` to prevent word splitting (unless splitting is intended).
- **Unset Vars:** `set -u` ensures you don't use undefined variables.
- **Pipefail:** `set -o pipefail` catches errors in the middle of pipes.
- **Temporary Files:** Use `mktemp` and `trap 'rm ...' EXIT` to clean up.
- **Lockfiles:** Use `flock` to prevent concurrent runs:
  ```bash
  exec 200>"/tmp/${SCRIPT_NAME}.lock"
  flock -n 200 || { echo "Already running"; exit 1; }
  ```

---

## 3) Performance & Patterns

**Golden Rule:** Profile with `time` command, optimize hot paths, prefer builtins over external commands.

### Process Substitution (Avoid Subshells)

```bash
#  Wrong - subshell, variables don't persist
count=0
cat file.txt | while read -r line; do
  count=$((count + 1))
done
echo "$count"  # Empty! (subshell issue)

#  Correct - process substitution, no subshell
count=0
while read -r line; do
  count=$((count + 1))
done < <(cat file.txt)
echo "$count"  # Works! Variable persists
```

### Performance Optimization Examples

**String Operations:**

```bash
# BAD: External command (slow)
result=$(echo "$var" | sed 's/old/new/g')

# GOOD: Builtin parameter expansion (fast)
result="${var//old/new}"

# BAD: Multiple external commands
length=$(echo "$var" | wc -c)

# GOOD: Builtin expansion
length=${#var}

# BAD: External command for trimming
trimmed=$(echo "$var" | xargs)

# GOOD: Builtin expansion
trimmed="${var#"${var%%[![:space:]]*}"}"  # Trim leading
trimmed="${trimmed%"${trimmed##*[![:space:]]}"}"  # Trim trailing
```

**Array Operations:**

```bash
# BAD: String concatenation (slow, error-prone)
files=""
for file in *.txt; do
  files="$files $file"
done

# GOOD: Arrays (fast, safe)
files=()
for file in *.txt; do
  [[ -f "$file" ]] || continue
  files+=("$file")
done

# Process array
for file in "${files[@]}"; do
  process "$file"
done
```

**File Operations:**

```bash
# BAD: Multiple file operations
while read -r line; do
  echo "$line" >> output.txt
done < input.txt

# GOOD: Single redirection (faster)
while read -r line; do
  echo "$line"
done < input.txt > output.txt

# BAD: Reading file multiple times
grep "pattern1" file.txt
grep "pattern2" file.txt

# GOOD: Single pass
while read -r line; do
  [[ "$line" =~ pattern1 ]] && echo "$line"
  [[ "$line" =~ pattern2 ]] && echo "$line"
done < file.txt
```

**Command Substitution:**

```bash
# BAD: Multiple subshells
result=$(echo "$(process "$(get_value)")")

# GOOD: Single subshell
value=$(get_value)
result=$(process "$value")

# BAD: Command substitution in loop
for i in {1..100}; do
  value=$(expensive_command)
  process "$value"
done

# GOOD: Cache result if same
cached_value=$(expensive_command)
for i in {1..100}; do
  process "$cached_value"
done
```

**Builtin vs External Commands:**

```bash
# BAD: External command
if [ "$(echo "$var" | grep -q pattern)" ]; then

# GOOD: Builtin test
if [[ "$var" =~ pattern ]]; then

# BAD: External command for arithmetic
result=$(expr "$a" + "$b")

# GOOD: Builtin arithmetic
result=$((a + b))

# BAD: External command for basename
name=$(basename "$file")

# GOOD: Builtin parameter expansion
name="${file##*/}"
```

### Other Performance Tips

- **Builtins:** Prefer `[[ ... ]]` over `[ ... ]` (test) for Bash.
- **Subshells:** Avoid unnecessary `$(...)` or pipes if builtins work.
- **Dependencies:** Check for required tools (`command -v tool`) at startup.
- **Arrays:** Use arrays for lists of items instead of strings (Bash 4+).
- **Native Operations:** Prefer `${var//old/new}` over `echo "$var" | sed 's/old/new/g'`.
- **Caching:** Cache expensive command results, avoid repeated calls.
- **Early Returns:** Exit early to avoid unnecessary processing.

---

## 4) Logging & Observability

- **Standard Logging:** Use a helper function with UTC timestamps.
- **Level:** INFO, WARN, ERROR.
- **Output:** Stdout for info, Stderr for errors/logs.

```bash
log() {
  local level="$1"
  shift
  # UTC ISO-8601-like timestamp
  echo "$(date -u +'%Y-%m-%dT%H:%M:%SZ') [$level] $*" >&2
}
```

**Structured Error Logging:**
```bash
logmsg() {
  local level="${1:-INFO}"; shift
  local timestamp
  timestamp=$(date -u +"%Y-%m-%d %T,%3N" 2>/dev/null || date -u +"%Y-%m-%d %T")
  printf "%s: %s: %s\n" "$timestamp" "$level" "$*" | tee -a "$LOGFILE"
  # Optional: JSON error log
  [[ "$level" == "ERROR" ]] && printf '{"timestamp":"%s","level":"%s","message":"%s"}\n' \
    "$timestamp" "$level" "$*" >> "$LOGFILE.errors"
}
```

---

## 5) Structure & Modularity

- **Main Function:** Encapsulate logic in `main()` and call it at the end.
- **Functions:** Use `function_name() { ... }` style.
- **Locals:** Use `local` keyword for variables inside functions.
- **Usage:** Provide a `usage()` function for help text.

```bash
usage() {
  cat <<EOF
Usage: $(basename "${BASH_SOURCE[0]}") [-h] [-v]

Options:
  -h    Show help
  -v    Verbose mode
EOF
  exit 1
}
```

### Here-Documents (Here-Docs)

**Use here-docs for multiline strings, templates, and embedded content:**

```bash
# Basic here-doc
cat <<EOF > config.yaml
port: 8080
env: production
database:
  host: localhost
  port: 5432
EOF

# Here-doc with variable expansion
cat <<EOF > message.txt
Hello ${USER},
Your script completed at $(date).
EOF

# Indented here-doc (removes leading tabs)
cat <<-EOF
    This line has leading tabs removed
    So does this one
EOF

# Here-doc without variable expansion (literal)
cat <<'EOF'
This $VAR will not be expanded
Nor will $(command) be executed
EOF
```

**When to use here-docs:**
- Configuration file generation
- Template files (Dockerfiles, Kubernetes manifests)
- Multiline error messages
- Embedded SQL queries
- Inline documentation
- Cleaner than multiple `echo` statements

**Benefits:**
- Preserves formatting and whitespace
- More readable than concatenated strings
- Supports variable expansion (or literal with `'EOF'`)
- Reduces quoting complexity

---

## 6) Common Pitfalls (Avoid These)

### 1. Unquoted Variables
```bash
#  Wrong
if [ $var = "hello" ]; then  # Fails if var is empty or has spaces

#  Correct
if [ "$var" = "hello" ]; then
# Or use [[ (Bash-specific but safer)
if [[ $var = "hello" ]]; then
```

### 2. Parsing `ls` Output
```bash
#  Wrong
for file in $(ls *.txt); do

#  Correct
for file in *.txt; do
  [ -f "$file" ] || continue
```

### 3. Exit Code Checking
```bash
#  Wrong - only checks last command
cmd1 && cmd2 && cmd3
if [ $? -eq 0 ]; then  # Only checks cmd3!

#  Correct
if cmd1 && cmd2 && cmd3; then
  echo "All succeeded"
fi
```

### 4. `cd` Without Error Checking
```bash
#  Wrong
cd "$some_dir"
rm -rf *  # Disaster if cd failed!

#  Correct
cd "$some_dir" || { echo "Failed to cd"; exit 1; }
rm -rf *
```

### 5. Subshell Variable Scope
```bash
#  Wrong - subshell doesn't persist
echo "data" | while read -r line; do
  count=$((count + 1))
done
echo "$count"  # Empty!

#  Correct - use process substitution
while read -r line; do
  count=$((count + 1))
done < <(echo "data")
echo "$count"  # Works!
```

### 6. Using `$*` Instead of `"$@"`

**Always use `"$@"` for script arguments to preserve argument boundaries:**

```bash
#  WRONG - $* loses argument boundaries
my_script() {
  for arg in $*; do  # Breaks on spaces!
    echo "$arg"
  done
}

my_script "file one.txt" "file two.txt"
# Output: file (lost quotes!)
#         one.txt
#         file
#         two.txt

#  CORRECT - "$@" preserves boundaries
my_script() {
  for arg in "$@"; do  # Preserves spaces and quotes
    echo "$arg"
  done
}

my_script "file one.txt" "file two.txt"
# Output: file one.txt (preserved!)
#         file two.txt

#  WRONG - $* in command substitution
some_command $*  # Breaks on spaces

#  CORRECT - "$@" preserves all arguments
some_command "$@"

#  When to use $* (rare):
#  Only when you explicitly want word splitting
#  echo "All args: $*"  # Single string with spaces
```

**Why `"$@"` matters:**
- Preserves quoted arguments with spaces
- Handles filenames correctly
- Maintains argument count (`$#`)
- Prevents data loss and security issues
- Essential for wrapper scripts and functions

**Rule of thumb:** Always use `"$@"` unless you explicitly need word splitting (which is rare).

---

## 7) Security

- **Sanitize Inputs:** Use `read -r` (no backslash escaping).
- **Sensitive Data:** Use `read -s` for passwords.
- **Avoid `eval`:** Never use `eval` with unsanitized input.
- **Temp Files:** Use `mktemp` with `umask 077`:
  ```bash
  umask 077
  TEMP=$(mktemp) || { echo "Failed to create temp file"; exit 1; }
  trap 'rm -f "$TEMP"' EXIT
  ```
- **Validate Input:** Use `case` or regex:
  ```bash
  case "$input" in
    [0-9]*) echo "Valid" ;;
    *) echo "Invalid"; exit 1 ;;
  esac
  ```

---

## 8) Testing & Validation

```bash
# Static analysis
shellcheck script.sh

# Formatting
shfmt -w -i 2 -ci -sr -bn .

# Unit tests with BATS
@test "check_dependency detects missing tool" {
  run check_dependency "nonexistent_tool"
  [ "$status" -eq 3 ]
}
```

### Advanced Testing Patterns

**BATS Test Structure:**

```bash
#!/usr/bin/env bats

load test_helper

@test "function returns success on valid input" {
  run my_function "valid_input"
  [ "$status" -eq 0 ]
  [ "$output" = "expected_output" ]
}

@test "function fails on invalid input" {
  run my_function ""
  [ "$status" -eq 1 ]
  [[ "$output" =~ "Error" ]]
}

@test "function handles edge cases" {
  run my_function "edge_case_value"
  [ "$status" -eq 0 ]
}

@test "function is idempotent" {
  run my_function "input"
  first_output="$output"

  run my_function "input"
  [ "$output" = "$first_output" ]
}
```

**Test Helpers:**

```bash
# test_helper.bash
setup() {
  TEST_DIR=$(mktemp -d)
  cd "$TEST_DIR" || exit 1
}

teardown() {
  rm -rf "$TEST_DIR"
}

# Mock external commands
mock_command() {
  local cmd="$1"
  local output="$2"
  echo "$output" > "$TEST_DIR/$cmd"
  chmod +x "$TEST_DIR/$cmd"
  PATH="$TEST_DIR:$PATH"
}
```

**Integration Testing:**

```bash
#!/usr/bin/env bats

@test "script processes files correctly" {
  # Setup
  mkdir -p test_data
  echo "test content" > test_data/file.txt

  # Execute
  run ./script.sh test_data

  # Verify
  [ "$status" -eq 0 ]
  [ -f test_data/file.processed ]
  grep -q "processed" test_data/file.processed

  # Cleanup
  rm -rf test_data
}
```

**Performance Testing:**

```bash
@test "script completes within time limit" {
  start=$(date +%s)
  run ./script.sh
  end=$(date +%s)

  duration=$((end - start))
  [ "$duration" -lt 5 ]  # Should complete in under 5 seconds
}
```

**Error Handling Tests:**

```bash
@test "script handles missing dependencies" {
  PATH="/empty:$PATH"  # Remove all commands
  run ./script.sh
  [ "$status" -eq 1 ]
  [[ "$output" =~ "Missing dependency" ]]
}

@test "script handles permission errors" {
  chmod 000 test_file
  run ./script.sh test_file
  [ "$status" -eq 1 ]
  chmod 644 test_file
}
```

---

## 9) Example: Robust Script Template

```bash
#!/usr/bin/env bash
set -eEuo pipefail

# Constants
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly SCRIPT_NAME="$(basename "$0" .sh)"
readonly LOG_FILE="${HOME}/log/${SCRIPT_NAME}_$(date -u +%Y%m%d_%H%M%S).log"

# Logging Helper
log() {
  local level="$1"
  shift
  echo "$(date -u +'%Y-%m-%dT%H:%M:%SZ') [$level] $*" | tee -a "$LOG_FILE" >&2
}

# Cleanup Helper
cleanup() {
  log "INFO" "Cleaning up..."
  # Remove temp files, release locks, etc.
}
trap cleanup EXIT

# Lockfile
exec 200>"/tmp/${SCRIPT_NAME}.lock"
flock -n 200 || { log "ERROR" "Already running"; exit 1; }

# Dependency Check
check_deps() {
  for cmd in curl jq; do
    if ! command -v "$cmd" &> /dev/null; then
      log "ERROR" "Missing dependency: $cmd"
      exit 1
    fi
  done
}

# Retry with exponential backoff
retry_cmd() {
  local max_attempts=5 delay=1 attempt=1
  while ! "$@"; do
    ((attempt++ > max_attempts)) && { log "ERROR" "Failed after $max_attempts: $*"; return 1; }
    log "INFO" "Retry $attempt/$max_attempts in ${delay}s..."
    sleep "$delay"
    ((delay = delay * 2 > 32 ? 32 : delay * 2))
  done
}

# Main Logic
main() {
  check_deps

  local url="https://api.github.com"

  log "INFO" "Starting job..."

  retry_cmd curl -sfSL "$url" > /dev/null || { log "ERROR" "Connectivity check failed"; return 1; }
  log "INFO" "Connectivity check passed."

  log "INFO" "Job completed successfully."
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  main "$@"
fi
```

---

## 10) Anti-Patterns (Forbidden)

-  `eval` on user input.
-  Using unquoted variables in file paths.
-  Parsing `ls` output (use `find` or globs).
-  Swallowing errors (unless explicit `|| true`).
-  `echo` for logging (use specific log function targeting stderr).
-  `cd` without error checking before destructive operations.
-  Variables in pipes (use process substitution `< <(cmd)` instead).
-  Using aliases in scripts (use functions instead).

---

## 11) Cross-Platform Notes

- **macOS ships with Bash 3.2** - install Bash 4+ via Homebrew for modern features (associative arrays, `${var,,}`, etc.)
- **GNU vs BSD tools** - Provide fallbacks:
  ```bash
  # GNU (Linux)
  SCRIPT=$(readlink -f "$0")

  # BSD/macOS fallback
  SCRIPT=$(readlink -f "$0" 2>/dev/null || realpath "$0")
  ```
- **POSIX compliance** - For maximum portability, avoid `[[`, `${var,,}`, associative arrays
- **Test on target platforms** - Use `dash` or `sh` for POSIX testing

## 12) Troubleshooting & Debugging

### Debug Techniques

**Enable Debug Mode:**

```bash
# Enable debug output
set -x  # Print each command before execution
set -v  # Print each line as read
set -xv  # Both

# Disable debug
set +x
set +v
```

**Structured Debugging:**

```bash
# Debug function
debug() {
  if [[ "${DEBUG:-0}" == "1" ]]; then
    echo "[DEBUG] $*" >&2
  fi
}

# Usage
DEBUG=1 ./script.sh
```

**Error Tracing:**

```bash
# Enhanced error trap
trap 'echo "Error at line $LINENO in ${FUNCNAME[0]:-main}: $BASH_COMMAND"' ERR

# Function call stack
trap 'echo "Call stack: ${FUNCNAME[*]}"' ERR
```

**Common Issues & Solutions:**

**Issue: Variable not set**

```bash
# Problem: Unset variable causes script to exit
set -u
echo "$UNDEFINED_VAR"  # Exits with error

# Solution: Use default value
echo "${UNDEFINED_VAR:-default_value}"

# Solution: Check before use
if [[ -n "${UNDEFINED_VAR:-}" ]]; then
  echo "$UNDEFINED_VAR"
fi
```

**Issue: Command not found**

```bash
# Problem: Script fails if command missing
some_command

# Solution: Check first
if ! command -v some_command >/dev/null 2>&1; then
  echo "Error: some_command not found" >&2
  exit 1
fi
some_command
```

**Issue: Permission denied**

```bash
# Problem: Can't write to file
echo "data" > /protected/file.txt

# Solution: Check permissions first
if [[ ! -w "/protected" ]]; then
  echo "Error: No write permission" >&2
  exit 1
fi
echo "data" > /protected/file.txt
```

**Issue: Disk space**

```bash
# Problem: Out of disk space
dd if=/dev/zero of=large_file bs=1M count=1000

# Solution: Check available space
available=$(df -BG . | awk 'NR==2 {print $4}' | sed 's/G//')
if [[ $available -lt 10 ]]; then
  echo "Error: Insufficient disk space (need 10GB, have ${available}GB)" >&2
  exit 1
fi
```

**Performance Debugging:**

```bash
# Time command execution
time expensive_command

# Profile script
bash -x script.sh 2>&1 | ts '[%Y-%m-%d %H:%M:%.S]'

# Memory usage
/usr/bin/time -v ./script.sh
```

## 13) Advanced Patterns

### Retry with Exponential Backoff

```bash
retry_with_backoff() {
  local max_attempts="${1:-5}"
  local delay="${2:-1}"
  shift 2
  local attempt=1

  while ! "$@"; do
    if ((attempt >= max_attempts)); then
      echo "Failed after $max_attempts attempts" >&2
      return 1
    fi

    echo "Attempt $attempt/$max_attempts failed, retrying in ${delay}s..." >&2
    sleep "$delay"
    delay=$((delay * 2 > 60 ? 60 : delay * 2))  # Cap at 60s
    ((attempt++))
  done
}

# Usage
retry_with_backoff 5 2 curl -f https://api.acme.com/health
```

### Lock File Pattern

```bash
acquire_lock() {
  local lock_file="${1:-/tmp/script.lock}"
  local lock_fd=200

  exec "$lock_fd>$lock_file" || {
    echo "Failed to open lock file" >&2
    return 1
  }

  if ! flock -n "$lock_fd"; then
    echo "Another instance is running" >&2
    return 1
  fi

  echo "Lock acquired"
  trap "flock -u $lock_fd; rm -f $lock_file" EXIT
}
```

### Configuration Management

```bash
load_config() {
  local config_file="${1:-config.conf}"

  if [[ ! -f "$config_file" ]]; then
    echo "Error: Config file not found: $config_file" >&2
    return 1
  fi

  # Source config with validation
  while IFS='=' read -r key value; do
    # Skip comments and empty lines
    [[ "$key" =~ ^#.*$ ]] && continue
    [[ -z "$key" ]] && continue

    # Validate key format
    if [[ ! "$key" =~ ^[A-Z_][A-Z0-9_]*$ ]]; then
      echo "Warning: Invalid config key: $key" >&2
      continue
    fi

    # Export variable
    export "$key"="$value"
  done < "$config_file"
}
```

### Signal Handling

```bash
cleanup() {
  echo "Cleaning up..." >&2
  rm -f "$TEMP_FILE"
  # Release resources, close connections, etc.
}

trap cleanup EXIT INT TERM

# Handle specific signals
trap 'echo "Received SIGUSR1"' USR1
trap 'echo "Received SIGUSR2"' USR2
```

## 14) Comprehensive Example Script

Complete example demonstrating Bash best practices:

```bash
#!/usr/bin/env bash
set -eEuo pipefail

# ================================================================
# Script: process-users.sh
# Purpose: Process user data files with validation and error handling
# Usage: ./process-users.sh [OPTIONS] <input_file>
# ================================================================

readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly SCRIPT_NAME="$(basename "$0" .sh)"
readonly VERSION="1.0.0"

# Configuration
readonly MAX_RETRIES=3
readonly RETRY_DELAY=2
readonly LOCK_FILE="/tmp/${SCRIPT_NAME}.lock"
readonly LOG_FILE="${HOME}/log/${SCRIPT_NAME}_$(date -u +%Y%m%d_%H%M%S).log"

# Colors for output (if terminal supports it)
if [[ -t 1 ]]; then
  readonly RED='\033[0;31m'
  readonly GREEN='\033[0;32m'
  readonly YELLOW='\033[1;33m'
  readonly NC='\033[0m'  # No Color
else
  readonly RED=''
  readonly GREEN=''
  readonly YELLOW=''
  readonly NC=''
fi

# Logging
log() {
  local level="$1"
  shift
  local timestamp
  timestamp=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
  echo -e "${timestamp} [${level}] $*" | tee -a "$LOG_FILE" >&2
}

log_info() { log "INFO" "$@"; }
log_warn() { log "WARN" "$@"; }
log_error() { log "ERROR" "$@"; }
log_debug() {
  [[ "${DEBUG:-0}" == "1" ]] && log "DEBUG" "$@"
}

# Cleanup
cleanup() {
  log_info "Cleaning up..."
  rm -f "$LOCK_FILE"
  [[ -n "${TEMP_FILE:-}" ]] && rm -f "$TEMP_FILE"
}

trap cleanup EXIT INT TERM

# Lock file
acquire_lock() {
  exec 200>"$LOCK_FILE" || {
    log_error "Failed to create lock file"
    exit 1
  }

  if ! flock -n 200; then
    log_error "Another instance is running"
    exit 1
  fi

  log_debug "Lock acquired"
}

# Dependency check
check_dependencies() {
  local deps=("jq" "curl")
  local missing=()

  for dep in "${deps[@]}"; do
    if ! command -v "$dep" >/dev/null 2>&1; then
      missing+=("$dep")
    fi
  done

  if [[ ${#missing[@]} -gt 0 ]]; then
    log_error "Missing dependencies: ${missing[*]}"
    exit 1
  fi
}

# Validate input file
validate_input() {
  local file="$1"

  if [[ ! -f "$file" ]]; then
    log_error "Input file not found: $file"
    return 1
  fi

  if [[ ! -r "$file" ]]; then
    log_error "Input file not readable: $file"
    return 1
  fi

  if [[ ! -s "$file" ]]; then
    log_error "Input file is empty: $file"
    return 1
  fi

  # Validate JSON format
  if ! jq empty "$file" 2>/dev/null; then
    log_error "Invalid JSON format: $file"
    return 1
  fi

  return 0
}

# Process user
process_user() {
  local user_data="$1"
  local user_id
  user_id=$(jq -r '.id' <<< "$user_data")

  log_info "Processing user: $user_id"

  # Simulate processing
  sleep 1

  log_info "User processed: $user_id"
  return 0
}

# Retry wrapper
retry() {
  local max_attempts="$1"
  local delay="$2"
  shift 2
  local attempt=1

  while ! "$@"; do
    if ((attempt >= max_attempts)); then
      log_error "Failed after $max_attempts attempts: $*"
      return 1
    fi

    log_warn "Attempt $attempt/$max_attempts failed, retrying in ${delay}s..."
    sleep "$delay"
    delay=$((delay * 2 > 60 ? 60 : delay * 2))
    ((attempt++))
  done
}

# Usage
usage() {
  cat <<EOF
Usage: $SCRIPT_NAME [OPTIONS] <input_file>

Options:
  -h, --help      Show this help message
  -v, --version   Show version
  -d, --debug     Enable debug output
  -q, --quiet     Suppress info messages

Arguments:
  input_file      JSON file containing user data

Examples:
  $SCRIPT_NAME users.json
  $SCRIPT_NAME --debug users.json
EOF
  exit 0
}

# Parse arguments
parse_args() {
  local input_file=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h|--help)
        usage
        ;;
      -v|--version)
        echo "$SCRIPT_NAME version $VERSION"
        exit 0
        ;;
      -d|--debug)
        export DEBUG=1
        shift
        ;;
      -q|--quiet)
        export QUIET=1
        shift
        ;;
      -*)
        log_error "Unknown option: $1"
        usage
        ;;
      *)
        input_file="$1"
        shift
        ;;
    esac
  done

  if [[ -z "$input_file" ]]; then
    log_error "Input file required"
        usage
  fi

  echo "$input_file"
}

# Main function
main() {
  local input_file
  input_file=$(parse_args "$@")

  log_info "Starting $SCRIPT_NAME v$VERSION"
  log_debug "Script directory: $SCRIPT_DIR"
  log_debug "Input file: $input_file"

  acquire_lock
  check_dependencies

  if ! validate_input "$input_file"; then
    exit 1
  fi

  local processed=0
  local failed=0

  # Process users
  while IFS= read -r user_data; do
    if retry "$MAX_RETRIES" "$RETRY_DELAY" process_user "$user_data"; then
      ((processed++))
    else
      ((failed++))
      log_error "Failed to process user"
    fi
  done < <(jq -c '.[]' "$input_file")

  log_info "Processing complete: $processed succeeded, $failed failed"

  if [[ $failed -gt 0 ]]; then
    exit 1
  fi
}

# Run main if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  main "$@"
fi
```

**Key Patterns Demonstrated:**

- ✅ Strict error handling (`set -eEuo pipefail`)
- ✅ Lock file for concurrency control
- ✅ Dependency checking
- ✅ Input validation
- ✅ Structured logging with levels
- ✅ Retry logic with exponential backoff
- ✅ Cleanup on exit
- ✅ Argument parsing
- ✅ Usage documentation
- ✅ Cross-platform compatibility

---

