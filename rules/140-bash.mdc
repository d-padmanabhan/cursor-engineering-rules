---
title: Bash Engineering Ruleset
description: Production-grade Bash standards for portability, safety, performance, and maintainability.
priority: 140
alwaysApply: false
files:
  include:
    - "**/*.sh"
---

#  Bash Engineering Ruleset

**Scope:** Guidance for writing robust, portable Bash scripts that are easy to read, test, and operate.
**Principles:** DRY • KISS • Fail Fast • Zero Warnings.

## Bash Philosophy (Core Principles)

**Core Principles:**

- **"Fail fast, fail clearly"** - Use strict mode, validate early, provide clear error messages
- **"Quotes are your friend"** - Always quote variables unless you explicitly want word splitting
- **"Explicit over implicit"** - Use `local`, `readonly`, clear function names, document assumptions
- **"Portability matters"** - Prefer POSIX-compliant code when possible, document Bash-specific features
- **"Security by default"** - Sanitize inputs, use `mktemp`, avoid `eval`, validate file paths
- **"Composition over complexity"** - Small functions, clear separation of concerns, reusable patterns
- **"Prefer `case` for branching"** - When matching on a single value/pattern, prefer `case` over long `if/elif/else` chains
- **"Observability is essential"** - Structured logging, proper exit codes, error context
- **"Test what you write"** - Use shellcheck, test on multiple platforms, write BATS tests

**Applying Bash Principles:**

```bash
# BAD: Implicit, unsafe, unclear
#!/bin/bash
cd $DIR
rm -rf *
for file in $(ls *.txt); do
  process $file
done

# GOOD: Explicit, safe, clear
#!/usr/bin/env bash
set -euo pipefail

readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly TARGET_DIR="${1:-}"

if [[ -z "$TARGET_DIR" ]]; then
  echo "Usage: $0 <directory>" >&2
  exit 1
fi

if [[ ! -d "$TARGET_DIR" ]]; then
  echo "Error: Directory '$TARGET_DIR' does not exist" >&2
  exit 1
fi

cd "$TARGET_DIR" || { echo "Error: Failed to cd to '$TARGET_DIR'" >&2; exit 1; }

for file in *.txt; do
  [[ -f "$file" ]] || continue
  process "$file"
done
```

---

## Quick Reference

```bash
set -euo pipefail           # Strict mode (fail-fast)
set -uo pipefail            # Controlled mode (explicit error handling)
set -Euo pipefail           # Strict + ERR trap propagation to functions
command -v cmd >/dev/null   # Check if command exists (portable)
trap 'cleanup' EXIT         # Always cleanup
flock -n 200 || exit 1      # Prevent concurrent runs
readonly VAR="value"        # Immutable constant
local var="value"           # Function-local variable
```

---

## 1) Core Standards

- **Shebang:** `#!/usr/bin/env bash` (for portability) or `#!/bin/bash` (when bash-specific features required).
- **Safety Mode:** Choose based on context:
  - `set -euo pipefail` - Strict (fail-fast for simple scripts)
  - `set -uo pipefail` - Controlled (explicit error handling for complex scripts)
  - `set -Euo pipefail` - Strict + ERR trap propagation to functions
- **Linting:** Must pass **`shellcheck`** with **0 errors/warnings**.
- **Formatting:** Must pass **`shfmt -i 2 -ci -sr -bn`** (2-space indent, indent switch/case, simplify redirects, binary ops at line end).
- **Extension:** Use `.sh` for scripts, no extension for executables in `bin/` is acceptable if documented.
- **Variable Naming:**
  - **Uppercase** for constants and configuration: `readonly MAX_RETRIES=10`, `readonly CONFIG_FILE="/etc/app.conf"`
  - **Lowercase** for local variables: `local count=0`, `local file_name="data.txt"`
  - **Uppercase convention** helps distinguish constants from variables, avoids collisions with environment variables, and follows Bash conventions

---

## 2) Error Handling & Safety

### Error Handling Modes

** Strict Mode (Fail-Fast):**
```bash
set -euo pipefail  # Exit immediately on any error
```
Use for: Simple linear scripts, dependency installation, straightforward validation.

** Controlled Mode (Explicit):**
```bash
set -uo pipefail  # No -e: you handle errors explicitly
```
Use for: Diagnostics, cleanup operations, commands where failure is expected (grep, curl with retries).

** Strict + ERR Trap Propagation:**
```bash
set -Euo pipefail  # -E ensures ERR traps propagate to functions

trap 'echo "ERROR in ${FUNCNAME[0]:-main} at line $LINENO"' ERR

func1() {
  false  # Will trigger ERR trap even inside function
}
```
Use for: Production scripts with comprehensive error handling via ERR traps.

### Best Practices

- **Variables:** Always quote variables `"${VAR}"` to prevent word splitting (unless splitting is intended).
- **Unset Vars:** `set -u` ensures you don't use undefined variables.
- **Pipefail:** `set -o pipefail` catches errors in the middle of pipes.
- **Temporary Files:** Use `mktemp` and `trap 'rm ...' EXIT` to clean up.
- **Lockfiles:** Use `flock` to prevent concurrent runs:
  ```bash
  exec 200>"/tmp/${SCRIPT_NAME}.lock"
  flock -n 200 || { echo "Already running"; exit 1; }
  ```

---

## 3) Performance & Patterns

**Golden Rule:** Profile with `time` command, optimize hot paths, prefer builtins over external commands.

### Process Substitution (Avoid Subshells)

```bash
#  Wrong - subshell, variables don't persist
count=0
cat file.txt | while read -r line; do
  count=$((count + 1))
done
echo "$count"  # Empty! (subshell issue)

#  Correct - process substitution, no subshell
count=0
while read -r line; do
  count=$((count + 1))
done < <(cat file.txt)
echo "$count"  # Works! Variable persists
```

### Performance Optimization Examples

**String Operations:**

```bash
# BAD: External command (slow)
result=$(echo "$var" | sed 's/old/new/g')

# GOOD: Builtin parameter expansion (fast)
result="${var//old/new}"

# BAD: Multiple external commands
length=$(echo "$var" | wc -c)

# GOOD: Builtin expansion
length=${#var}

# BAD: External command for trimming
trimmed=$(echo "$var" | xargs)

# GOOD: Builtin expansion
trimmed="${var#"${var%%[![:space:]]*}"}"  # Trim leading
trimmed="${trimmed%"${trimmed##*[![:space:]]}"}"  # Trim trailing
```

**Array Operations:**

```bash
# BAD: String concatenation (slow, error-prone)
files=""
for file in *.txt; do
  files="$files $file"
done

# GOOD: Arrays (fast, safe)
files=()
for file in *.txt; do
  [[ -f "$file" ]] || continue
  files+=("$file")
done

# Process array
for file in "${files[@]}"; do
  process "$file"
done
```

**File Operations:**

```bash
# BAD: Multiple file operations
while read -r line; do
  echo "$line" >> output.txt
done < input.txt

# GOOD: Single redirection (faster)
while read -r line; do
  echo "$line"
done < input.txt > output.txt

# BAD: Reading file multiple times
grep "pattern1" file.txt
grep "pattern2" file.txt

# GOOD: Single pass
while read -r line; do
  [[ "$line" =~ pattern1 ]] && echo "$line"
  [[ "$line" =~ pattern2 ]] && echo "$line"
done < file.txt
```

**Command Substitution:**

```bash
# BAD: Multiple subshells
result=$(echo "$(process "$(get_value)")")

# GOOD: Single subshell
value=$(get_value)
result=$(process "$value")

# BAD: Command substitution in loop
for i in {1..100}; do
  value=$(expensive_command)
  process "$value"
done

# GOOD: Cache result if same
cached_value=$(expensive_command)
for i in {1..100}; do
  process "$cached_value"
done
```

**Builtin vs External Commands:**

```bash
# BAD: External command
if [ "$(echo "$var" | grep -q pattern)" ]; then

# GOOD: Builtin test
if [[ "$var" =~ pattern ]]; then

# BAD: External command for arithmetic
result=$(expr "$a" + "$b")

# GOOD: Builtin arithmetic
result=$((a + b))

# BAD: External command for basename
name=$(basename "$file")

# GOOD: Builtin parameter expansion
name="${file##*/}"
```

### Other Performance Tips

- **Builtins:** Prefer `[[ ... ]]` over `[ ... ]` (test) for Bash.
- **Subshells:** Avoid unnecessary `$(...)` or pipes if builtins work.
- **Dependencies:** Check for required tools (`command -v tool`) at startup.
- **Arrays:** Use arrays for lists of items instead of strings (Bash 4+).
- **Native Operations:** Prefer `${var//old/new}` over `echo "$var" | sed 's/old/new/g'`.
- **Caching:** Cache expensive command results, avoid repeated calls.
- **Early Returns:** Exit early to avoid unnecessary processing.

---

## 4) Logging & Observability

- **Standard Logging:** Use a helper function with UTC timestamps.
- **Level:** INFO, WARN, ERROR.
- **Output:** Stdout for info, Stderr for errors/logs.

```bash
log() {
  local level="$1"
  shift
  # UTC ISO-8601-like timestamp
  echo "$(date -u +'%Y-%m-%dT%H:%M:%SZ') [$level] $*" >&2
}
```

**Structured Error Logging:**
```bash
logmsg() {
  local level="${1:-INFO}"; shift
  local timestamp
  timestamp=$(date -u +"%Y-%m-%d %T,%3N" 2>/dev/null || date -u +"%Y-%m-%d %T")
  printf "%s: %s: %s\n" "$timestamp" "$level" "$*" | tee -a "$LOGFILE"
  command -v logger >/dev/null && logger -t "$SCRIPT_NAME" "$level: $*"

  # Structured JSON error reporting for post-mortem analysis
  if [[ "$level" == "ERROR" ]]; then
    printf '{"timestamp":"%s","level":"%s","message":"%s","source":"%s","line":%d,"function":"%s"}\n' \
      "$timestamp" "$level" "$*" "${BASH_SOURCE[1]}" "${BASH_LINENO[0]}" "${FUNCNAME[1]:-main}" \
      >> "${LOGFILE}.errors"
  fi
}
```

**Error Log File Management:**
```bash
# Separate error log for structured analysis
readonly ERROR_LOG="${LOGFILE}.errors"

# Rotate error logs if they get too large
if [[ -f "$ERROR_LOG" ]] && [[ $(stat -f%z "$ERROR_LOG" 2>/dev/null || stat -c%s "$ERROR_LOG" 2>/dev/null || echo 0) -gt 10485760 ]]; then
  mv "$ERROR_LOG" "${ERROR_LOG}.old"
fi
```

---

## 5) Structure & Modularity

- **Main Function:** Encapsulate logic in `main()` and call it at the end.
- **Functions:** Use `function_name() { ... }` style.
- **Locals:** Use `local` keyword for variables inside functions.
- **Usage:** Provide a `usage()` function for help text.

### Variable Declaration: `local`, `declare`/`typeset`, `readonly`, `export`

**Goal:** Use the right primitive for scope, attributes, and intent without sacrificing portability.

**Guidelines:**

* **Scope**
  * Use `local` **inside functions** for locals.
  * At top-level, simple assignments create globals.

* **Attributes (Bash/ksh/zsh only)**
  * Use `declare` **or** `typeset` to add attributes:
    * `-i` integer, `-a` array, `-A` assoc array, `-l` lower, `-u` upper, `-r` readonly, `-x` export, `-g` global (bash/zsh).
  * In **bash**, `typeset` ≈ `declare`. Prefer `declare` for clarity in bash; use `typeset` if targeting ksh/zsh too.

* **Intent**
  * Use **`readonly`** for constants.
  * Use **`export`** only if a child process needs the value.

* **Portability**
  * `typeset`/`declare` are **not POSIX**. For `/bin/sh` portability, avoid them (and arrays) and stick to plain assignments + `export`/`readonly`.

**Examples:**

```bash
# Top-level constants & environment
readonly SCRIPT_NAME="$(basename "$0" .sh)"
readonly DEFAULT_TIMEOUT=60
export PATH="/usr/local/bin:$PATH"   # Export only when needed by children

# Function locals with attributes (bash)
do_work() {
  local -i retries=0 max=5
  local -A meta=()                  # bash 4+
  local -a files=()
  local -l env="${ENVIRONMENT:-dev}"  # always-lowercased on assignment
}

# Same using declare/typeset
do_work2() {
  declare -i retries=0 max=5
  declare -A meta=()
  typeset -a files=()
}

# Make a global from inside a function (rare):
set_flag() { declare -g BUILD_FLAG=1; }
```

```bash
usage() {
  cat <<EOF
Usage: $(basename "${BASH_SOURCE[0]}") [-h] [-v]

Options:
  -h    Show help
  -v    Verbose mode
EOF
  exit 1
}
```

### Here-Documents (Here-Docs)

**Use here-docs for multiline strings, templates, and embedded content:**

```bash
# Basic here-doc
cat <<EOF > config.yaml
port: 8080
env: production
database:
  host: localhost
  port: 5432
EOF

# Here-doc with variable expansion
cat <<EOF > message.txt
Hello ${USER},
Your script completed at $(date).
EOF

# Indented here-doc (removes leading tabs)
cat <<-EOF
    This line has leading tabs removed
    So does this one
EOF

# Here-doc without variable expansion (literal)
cat <<'EOF'
This $VAR will not be expanded
Nor will $(command) be executed
EOF
```

**When to use here-docs:**
- Configuration file generation
- Template files (Dockerfiles, Kubernetes manifests)
- Multiline error messages
- Embedded SQL queries
- Inline documentation
- Cleaner than multiple `echo` statements

**Benefits:**
- Preserves formatting and whitespace
- More readable than concatenated strings
- Supports variable expansion (or literal with `'EOF'`)
- Reduces quoting complexity

---

## 6) Common Pitfalls (Avoid These)

### 1. Unquoted Variables
```bash
#  Wrong
if [ $var = "hello" ]; then  # Fails if var is empty or has spaces

#  Correct
if [ "$var" = "hello" ]; then
# Or use [[ (Bash-specific but safer)
if [[ $var = "hello" ]]; then
```

### 2. Parsing `ls` Output
```bash
#  Wrong
for file in $(ls *.txt); do

#  Correct
for file in *.txt; do
  [ -f "$file" ] || continue
```

### 3. Exit Code Checking
```bash
#  Wrong - only checks last command
cmd1 && cmd2 && cmd3
if [ $? -eq 0 ]; then  # Only checks cmd3!

#  Correct
if cmd1 && cmd2 && cmd3; then
  echo "All succeeded"
fi
```

### 4. `cd` Without Error Checking
```bash
#  Wrong
cd "$some_dir"
rm -rf *  # Disaster if cd failed!

#  Correct
cd "$some_dir" || { echo "Failed to cd"; exit 1; }
rm -rf *
```

### 5. Subshell Variable Scope
```bash
#  Wrong - subshell doesn't persist
echo "data" | while read -r line; do
  count=$((count + 1))
done
echo "$count"  # Empty!

#  Correct - use process substitution
while read -r line; do
  count=$((count + 1))
done < <(echo "data")
echo "$count"  # Works!
```

### 6. Using `$*` Instead of `"$@"`

**Always use `"$@"` for script arguments to preserve argument boundaries:**

```bash
#  WRONG - $* loses argument boundaries
my_script() {
  for arg in $*; do  # Breaks on spaces!
    echo "$arg"
  done
}

my_script "file one.txt" "file two.txt"
# Output: file (lost quotes!)
#         one.txt
#         file
#         two.txt

#  CORRECT - "$@" preserves boundaries
my_script() {
  for arg in "$@"; do  # Preserves spaces and quotes
    echo "$arg"
  done
}

my_script "file one.txt" "file two.txt"
# Output: file one.txt (preserved!)
#         file two.txt

#  WRONG - $* in command substitution
some_command $*  # Breaks on spaces

#  CORRECT - "$@" preserves all arguments
some_command "$@"

#  When to use $* (rare):
#  Only when you explicitly want word splitting
#  echo "All args: $*"  # Single string with spaces
```

**Why `"$@"` matters:**
- Preserves quoted arguments with spaces
- Handles filenames correctly
- Maintains argument count (`$#`)
- Prevents data loss and security issues
- Essential for wrapper scripts and functions

**Rule of thumb:** Always use `"$@"` unless you explicitly need word splitting (which is rare).

---

## 7) Security

- **Sanitize Inputs:** Use `read -r` (no backslash escaping).
- **Sensitive Data:** Use `read -s` for passwords.
- **Avoid `eval`:** Never use `eval` with unsanitized input.
- **Temp Files:** Use `mktemp` with `umask 077`:
  ```bash
  umask 077
  TEMP=$(mktemp) || { echo "Failed to create temp file"; exit 1; }
  trap 'rm -f "$TEMP"' EXIT
  ```
- **Validate Input:** Use `case` or regex:
  ```bash
  case "$input" in
    [0-9]*) echo "Valid" ;;
    *) echo "Invalid"; exit 1 ;;
  esac
  ```

---

## 8) Documentation

### Goal

Ensure usability and clarity.

### Guidelines

* Include a header with purpose, usage, dependencies, prompt behavior, exit codes, etc.
* Add inline comments for complex logic.
* Document debugging and testing instructions.
* Use here-documents for multiline documentation blocks.

### Example

```bash
#!/bin/bash
#
# Script Name         : my_script.sh
#
# Purpose             : This script automates the processing of files and makes network requests.
#
#
# Usage               : ./script.sh [-d] [-h] <provider> <module> [path]
#
# Dependencies        : curl, tar, jq, nc, parallel
#
# Prompt Behavior     : Prompts use green for questions, red for errors.
#
#
# Exit Codes          : 0 (success), 1 (error), 2 (cancel), 3 (dependency missing)
#
#
# ----------------------------------------------------------------------------------------
# Turn debug on or off
# set -x
# ----------------------------------------------------------------------------------------

set -euo pipefail
```

### Usage Function Pattern

```bash
usage() {
  cat <<EOF
Usage: $(basename "${BASH_SOURCE[0]}") [OPTIONS] <arguments>

Description:
  Brief description of what the script does.

Options:
  -h, --help      Show this help message
  -v, --version   Show version information
  -d, --debug     Enable debug output
  -q, --quiet     Suppress non-error output

Arguments:
  <arguments>     Description of required arguments

Examples:
  $(basename "${BASH_SOURCE[0]}") --debug input.txt
  $(basename "${BASH_SOURCE[0]}") -q output.txt

Exit Codes:
  0  Success
  1  General error
  2  Invalid arguments
  3  Missing dependency

See also:
  man $(basename "${BASH_SOURCE[0]}")
EOF
  exit "${1:-1}"
}
```

### Inline Documentation Best Practices

```bash
# BAD: No comments, unclear intent
process_files() {
  for f in $*; do
    do_something $f
  done
}

# GOOD: Clear comments explaining why, not what
process_files() {
  # Process files in parallel to reduce total execution time
  # Use process substitution to avoid subshell variable scope issues
  while IFS= read -r file; do
    [[ -f "$file" ]] || continue  # Skip if file doesn't exist
    do_something "$file"
  done < <(find . -type f -name "*.txt")
}
```

---

## 9) Testing & Validation

```bash
# Static analysis
shellcheck script.sh

# Formatting
shfmt -w -i 2 -ci -sr -bn .

# Unit tests with BATS
@test "check_dependency detects missing tool" {
  run check_dependency "nonexistent_tool"
  [ "$status" -eq 3 ]
}
```

### Advanced Testing Patterns

**BATS Test Structure:**

```bash
#!/usr/bin/env bats

load test_helper

@test "function returns success on valid input" {
  run my_function "valid_input"
  [ "$status" -eq 0 ]
  [ "$output" = "expected_output" ]
}

@test "function fails on invalid input" {
  run my_function ""
  [ "$status" -eq 1 ]
  [[ "$output" =~ "Error" ]]
}

@test "function handles edge cases" {
  run my_function "edge_case_value"
  [ "$status" -eq 0 ]
}

@test "function is idempotent" {
  run my_function "input"
  first_output="$output"

  run my_function "input"
  [ "$output" = "$first_output" ]
}
```

**Test Helpers:**

```bash
# test_helper.bash
setup() {
  TEST_DIR=$(mktemp -d)
  cd "$TEST_DIR" || exit 1
}

teardown() {
  rm -rf "$TEST_DIR"
}

# Mock external commands
mock_command() {
  local cmd="$1"
  local output="$2"
  echo "$output" > "$TEST_DIR/$cmd"
  chmod +x "$TEST_DIR/$cmd"
  PATH="$TEST_DIR:$PATH"
}
```

**Integration Testing:**

```bash
#!/usr/bin/env bats

@test "script processes files correctly" {
  # Setup
  mkdir -p test_data
  echo "test content" > test_data/file.txt

  # Execute
  run ./script.sh test_data

  # Verify
  [ "$status" -eq 0 ]
  [ -f test_data/file.processed ]
  grep -q "processed" test_data/file.processed

  # Cleanup
  rm -rf test_data
}
```

**Performance Testing:**

```bash
@test "script completes within time limit" {
  start=$(date +%s)
  run ./script.sh
  end=$(date +%s)

  duration=$((end - start))
  [ "$duration" -lt 5 ]  # Should complete in under 5 seconds
}
```

**Error Handling Tests:**

```bash
@test "script handles missing dependencies" {
  PATH="/empty:$PATH"  # Remove all commands
  run ./script.sh
  [ "$status" -eq 1 ]
  [[ "$output" =~ "Missing dependency" ]]
}

@test "script handles permission errors" {
  chmod 000 test_file
  run ./script.sh test_file
  [ "$status" -eq 1 ]
  chmod 644 test_file
}
```

---

## 10) Example: Robust Script Template

```bash
#!/usr/bin/env bash
set -eEuo pipefail

# Constants
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly SCRIPT_NAME="$(basename "$0" .sh)"
readonly LOG_FILE="${HOME}/log/${SCRIPT_NAME}_$(date -u +%Y%m%d_%H%M%S).log"

# Logging Helper
log() {
  local level="$1"
  shift
  echo "$(date -u +'%Y-%m-%dT%H:%M:%SZ') [$level] $*" | tee -a "$LOG_FILE" >&2
}

# Cleanup Helper
cleanup() {
  log "INFO" "Cleaning up..."
  # Remove temp files, release locks, etc.
}
trap cleanup EXIT

# Lockfile
exec 200>"/tmp/${SCRIPT_NAME}.lock"
flock -n 200 || { log "ERROR" "Already running"; exit 1; }

# Dependency Check
check_deps() {
  for cmd in curl jq; do
    if ! command -v "$cmd" &> /dev/null; then
      log "ERROR" "Missing dependency: $cmd"
      exit 1
    fi
  done
}

# Retry with exponential backoff
retry_cmd() {
  local max_attempts=5 delay=1 attempt=1
  while ! "$@"; do
    ((attempt++ > max_attempts)) && { log "ERROR" "Failed after $max_attempts: $*"; return 1; }
    log "INFO" "Retry $attempt/$max_attempts in ${delay}s..."
    sleep "$delay"
    ((delay = delay * 2 > 32 ? 32 : delay * 2))
  done
}

# Main Logic
main() {
  check_deps

  local url="https://api.github.com"

  log "INFO" "Starting job..."

  retry_cmd curl -sfSL "$url" > /dev/null || { log "ERROR" "Connectivity check failed"; return 1; }
  log "INFO" "Connectivity check passed."

  log "INFO" "Job completed successfully."
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  main "$@"
fi
```

---

## 11) Anti-Patterns (Forbidden)

-  `eval` on user input.
-  Using unquoted variables in file paths.
-  Parsing `ls` output (use `find` or globs).
-  Swallowing errors (unless explicit `|| true`).
-  `echo` for logging (use specific log function targeting stderr).
-  `cd` without error checking before destructive operations.
-  Variables in pipes (use process substitution `< <(cmd)` instead).
-  Using aliases in scripts (use functions instead).

---

## 12) Cross-Platform Notes

- **macOS ships with Bash 3.2** - install Bash 4+ via Homebrew for modern features (associative arrays, `${var,,}`, etc.)
- **GNU vs BSD tools** - Provide fallbacks:
  ```bash
  # GNU (Linux)
  SCRIPT=$(readlink -f "$0")

  # BSD/macOS fallback
  SCRIPT=$(readlink -f "$0" 2>/dev/null || realpath "$0")
  ```
- **POSIX compliance** - For maximum portability, avoid `[[`, `${var,,}`, associative arrays
- **Test on target platforms** - Use `dash` or `sh` for POSIX testing

## 13) Troubleshooting & Debugging

### Debug Techniques

**Enable Debug Mode:**

```bash
# Enable debug output
set -x  # Print each command before execution
set -v  # Print each line as read
set -xv  # Both

# Disable debug
set +x
set +v
```

**Structured Debugging:**

```bash
# Debug function
debug() {
  if [[ "${DEBUG:-0}" == "1" ]]; then
    echo "[DEBUG] $*" >&2
  fi
}

# Usage
DEBUG=1 ./script.sh
```

**Error Tracing:**

```bash
# Enhanced error trap
trap 'echo "Error at line $LINENO in ${FUNCNAME[0]:-main}: $BASH_COMMAND"' ERR

# Function call stack
trap 'echo "Call stack: ${FUNCNAME[*]}"' ERR
```

**Common Issues & Solutions:**

**Issue: Variable not set**

```bash
# Problem: Unset variable causes script to exit
set -u
echo "$UNDEFINED_VAR"  # Exits with error

# Solution: Use default value
echo "${UNDEFINED_VAR:-default_value}"

# Solution: Check before use
if [[ -n "${UNDEFINED_VAR:-}" ]]; then
  echo "$UNDEFINED_VAR"
fi
```

**Issue: Command not found**

```bash
# Problem: Script fails if command missing
some_command

# Solution: Check first
if ! command -v some_command >/dev/null 2>&1; then
  echo "Error: some_command not found" >&2
  exit 1
fi
some_command
```

**Issue: Permission denied**

```bash
# Problem: Can't write to file
echo "data" > /protected/file.txt

# Solution: Check permissions first
if [[ ! -w "/protected" ]]; then
  echo "Error: No write permission" >&2
  exit 1
fi
echo "data" > /protected/file.txt
```

**Issue: Disk space**

```bash
# Problem: Out of disk space
dd if=/dev/zero of=large_file bs=1M count=1000

# Solution: Check available space
available=$(df -BG . | awk 'NR==2 {print $4}' | sed 's/G//')
if [[ $available -lt 10 ]]; then
  echo "Error: Insufficient disk space (need 10GB, have ${available}GB)" >&2
  exit 1
fi
```

**Performance Debugging:**

```bash
# Time command execution
time expensive_command

# Profile script
bash -x script.sh 2>&1 | ts '[%Y-%m-%d %H:%M:%.S]'

# Memory usage
/usr/bin/time -v ./script.sh
```

## 14) Advanced Patterns

### Retry with Exponential Backoff

```bash
retry_with_backoff() {
  local max_attempts="${1:-5}"
  local delay="${2:-1}"
  shift 2
  local attempt=1

  while ! "$@"; do
    if ((attempt >= max_attempts)); then
      echo "Failed after $max_attempts attempts" >&2
      return 1
    fi

    echo "Attempt $attempt/$max_attempts failed, retrying in ${delay}s..." >&2
    sleep "$delay"
    delay=$((delay * 2 > 60 ? 60 : delay * 2))  # Cap at 60s
    ((attempt++))
  done
}

# Usage
retry_with_backoff 5 2 curl -f https://api.acme.com/health
```

### Lock File Pattern

```bash
acquire_lock() {
  local lock_file="${1:-/tmp/script.lock}"
  local lock_fd=200

  exec "$lock_fd>$lock_file" || {
    echo "Failed to open lock file" >&2
    return 1
  }

  if ! flock -n "$lock_fd"; then
    echo "Another instance is running" >&2
    return 1
  fi

  echo "Lock acquired"
  trap "flock -u $lock_fd; rm -f $lock_file" EXIT
}
```

### Configuration Management

```bash
load_config() {
  local config_file="${1:-config.conf}"

  if [[ ! -f "$config_file" ]]; then
    echo "Error: Config file not found: $config_file" >&2
    return 1
  fi

  # Source config with validation
  while IFS='=' read -r key value; do
    # Skip comments and empty lines
    [[ "$key" =~ ^#.*$ ]] && continue
    [[ -z "$key" ]] && continue

    # Validate key format
    if [[ ! "$key" =~ ^[A-Z_][A-Z0-9_]*$ ]]; then
      echo "Warning: Invalid config key: $key" >&2
      continue
    fi

    # Export variable
    export "$key"="$value"
  done < "$config_file"
}
```

### Signal Handling

```bash
cleanup() {
  echo "Cleaning up..." >&2
  rm -f "$TEMP_FILE"
  # Release resources, close connections, etc.
}

trap cleanup EXIT INT TERM

# Handle specific signals
trap 'echo "Received SIGUSR1"' USR1
trap 'echo "Received SIGUSR2"' USR2
```

## 15) Prompting & User Interaction

### Goal

Provide efficient, user-friendly, and visually enhanced interaction.

### Guidelines

* Use `read` for prompts: simple (`-p`), single-key (`-n 1`), with defaults (`-t 5`).
* Validate responses with `case` or regex.
* Support Yes/No/Cancel with a reusable function.
* Use colors sparingly (green for prompts, red for errors).
* Support advanced prompting with `select` or `dialog`.
* **Adapt prompts to user locale** (e.g., `locale LC_MESSAGES`).
* Log responses for auditability.
* Test prompts with edge cases (e.g., empty input, Ctrl+C).

### Basic Prompting Patterns

```bash
# Simple prompt
read -p "Enter your name: " name

# Single-key prompt
read -n 1 -p "Continue? [y/n] " yn
echo
[[ "$yn" =~ ^[Yy]$ ]] && proceed

# Prompt with timeout
read -t 5 -p "Press Enter to continue (timeout in 5s): " || echo "Timeout"
```

### Yes/No/Cancel Function

```bash
prompt_ync() {
  local yn
  while true; do
    read -n 1 -p "${GREEN}$1 [y/n/c]${NC} " yn
    echo
    case "$yn" in
      [Yy]*) logmsg "INFO" "User chose Yes"; return 0 ;;
      [Nn]*) logmsg "INFO" "User chose No"; return 1 ;;
      [Cc]*) logmsg "INFO" "User canceled"; exit 2 ;;
      *) logmsg "${RED}Invalid (y/n/c)${NC}" ;;
    esac
  done
}
```

### Locale-Aware Prompting

```bash
# Detect locale for Yes/No prompts
get_locale_yes_no() {
  local locale_msg
  locale_msg=$(locale LC_MESSAGES 2>/dev/null || echo "yes;no")
  IFS=';' read -r yes_pattern no_pattern <<< "$locale_msg"
  echo "$yes_pattern|$no_pattern"
}

# Use locale-aware prompts
prompt_locale() {
  local prompt_text="$1"
  local yes_no_pattern
  yes_no_pattern=$(get_locale_yes_no)

  read -p "${GREEN}${prompt_text} (${yes_no_pattern})${NC} " response
  if [[ "$response" =~ $yes_no_pattern ]]; then
    return 0
  else
    return 1
  fi
}

# Alternative: Use locale directly
set -- $(locale LC_MESSAGES)
read -p "${GREEN}Proceed? ($3/$4)${NC} " yn
[[ "$yn" =~ $1 ]] && logmsg "Yes chosen"
```

### Advanced Prompting with `select`

```bash
# Interactive menu
select region in "us-east-1" "us-west-2" "eu-west-1" "Cancel"; do
  case "$region" in
    "Cancel")
      logmsg "INFO" "User canceled"
      exit 0
      ;;
    "")
      logmsg "${RED}Invalid selection${NC}"
      ;;
    *)
      logmsg "INFO" "Selected region: $region"
      break
      ;;
  esac
done
```

### Secure Password Prompting

```bash
# Prompt for password without echoing
read -r -s -p "${GREEN}Enter password:${NC} " password
echo  # Newline after hidden input

# Validate password strength
if [[ ${#password} -lt 8 ]]; then
  logmsg "${RED}Password must be at least 8 characters${NC}"
  exit 1
fi
```

### Prompt Validation Patterns

```bash
# Validate email
prompt_email() {
  local email
  while true; do
    read -p "${GREEN}Enter email:${NC} " email
    if [[ "$email" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]; then
      echo "$email"
      return 0
    else
      logmsg "${RED}Invalid email format${NC}"
    fi
  done
}

# Validate numeric input
prompt_number() {
  local min="${1:-0}"
  local max="${2:-100}"
  local number

  while true; do
    read -p "${GREEN}Enter number [$min-$max]:${NC} " number
    if [[ "$number" =~ ^[0-9]+$ ]] && [[ "$number" -ge "$min" ]] && [[ "$number" -le "$max" ]]; then
      echo "$number"
      return 0
    else
      logmsg "${RED}Invalid number (must be $min-$max)${NC}"
    fi
  done
}
```

---

## 16) Version Compatibility Matrix

| Feature | Bash 3.2 | Bash 4.x | Bash 5.x | POSIX sh |
|---------|----------|----------|----------|----------|
| `[[...]]` | ✅ | ✅ | ✅ | ❌ |
| `${var,,}` (lowercase) | ❌ | ✅ | ✅ | ❌ |
| `${var^^}` (uppercase) | ❌ | ✅ | ✅ | ❌ |
| `readlink -f` | ✅ (GNU) | ✅ (GNU) | ✅ (GNU) | ❌ (BSD) |
| Associative arrays `-A` | ❌ | ✅ | ✅ | ❌ |
| `&>>` redirect | ✅ | ✅ | ✅ | ❌ |
| `mapfile`/`readarray` | ❌ | ✅ | ✅ | ❌ |
| `${var@Q}` (quoted) | ❌ | ✅ | ✅ | ❌ |
| `${var@A}` (declare) | ❌ | ✅ | ✅ | ❌ |
| `local -g` (global in func) | ❌ | ❌ | ✅ | ❌ |
| Process substitution `<()` | ✅ | ✅ | ✅ | ❌ |
| `[...]` test | ✅ | ✅ | ✅ | ✅ |
| `getopts` | ✅ | ✅ | ✅ | ✅ |
| `readonly` | ✅ | ✅ | ✅ | ✅ |
| `local` | ✅ | ✅ | ✅ | ❌ |
| `declare`/`typeset` | ✅ | ✅ | ✅ | ❌ |
| `$RANDOM` | ✅ | ✅ | ✅ | ❌ |
| `$SECONDS` | ✅ | ✅ | ✅ | ❌ |
| `$BASH_SOURCE` | ✅ | ✅ | ✅ | ❌ |
| `$BASH_LINENO` | ✅ | ✅ | ✅ | ❌ |
| `$FUNCNAME` | ✅ | ✅ | ✅ | ❌ |

**Notes:**
- **macOS ships with Bash 3.2 by default** (GPLv2 license). For modern Bash features (4.x+), install via Homebrew: `brew install bash`
- For maximum portability (POSIX sh), avoid Bash-specific features and test with `dash` or `sh`
- GNU tools (`readlink -f`, `date -d`, `find -printf`) have different syntax on BSD/macOS - provide fallbacks
- When targeting Bash 3.2 (macOS default), avoid associative arrays, `${var,,}`, `${var^^}`, and `mapfile`
- Use `command -v` instead of `which` for portability (POSIX-compliant)
- Test scripts with `dash` or `sh` to verify POSIX compliance when needed

**Platform-Specific Considerations:**

```bash
# Detect Bash version
BASH_VERSION_MAJOR="${BASH_VERSION%%.*}"
if [[ "$BASH_VERSION_MAJOR" -lt 4 ]]; then
  echo "Warning: Bash 4+ recommended for full feature support"
fi

# Feature detection instead of version checking
if declare -A test_array 2>/dev/null; then
  # Associative arrays supported
  declare -A config
else
  # Fallback for Bash 3.2
  echo "Associative arrays not supported"
fi
```

---

## 17) Comprehensive Example Script

Complete example demonstrating Bash best practices:

```bash
#!/usr/bin/env bash
set -eEuo pipefail

# ================================================================
# Script: process-users.sh
# Purpose: Process user data files with validation and error handling
# Usage: ./process-users.sh [OPTIONS] <input_file>
# ================================================================

readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly SCRIPT_NAME="$(basename "$0" .sh)"
readonly VERSION="1.0.0"

# Configuration
readonly MAX_RETRIES=3
readonly RETRY_DELAY=2
readonly LOCK_FILE="/tmp/${SCRIPT_NAME}.lock"
readonly LOG_FILE="${HOME}/log/${SCRIPT_NAME}_$(date -u +%Y%m%d_%H%M%S).log"

# Colors for output (if terminal supports it)
if [[ -t 1 ]]; then
  readonly RED='\033[0;31m'
  readonly GREEN='\033[0;32m'
  readonly YELLOW='\033[1;33m'
  readonly NC='\033[0m'  # No Color
else
  readonly RED=''
  readonly GREEN=''
  readonly YELLOW=''
  readonly NC=''
fi

# Logging
log() {
  local level="$1"
  shift
  local timestamp
  timestamp=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
  echo -e "${timestamp} [${level}] $*" | tee -a "$LOG_FILE" >&2
}

log_info() { log "INFO" "$@"; }
log_warn() { log "WARN" "$@"; }
log_error() { log "ERROR" "$@"; }
log_debug() {
  [[ "${DEBUG:-0}" == "1" ]] && log "DEBUG" "$@"
}

# Cleanup
cleanup() {
  log_info "Cleaning up..."
  rm -f "$LOCK_FILE"
  [[ -n "${TEMP_FILE:-}" ]] && rm -f "$TEMP_FILE"
}

trap cleanup EXIT INT TERM

# Lock file
acquire_lock() {
  exec 200>"$LOCK_FILE" || {
    log_error "Failed to create lock file"
    exit 1
  }

  if ! flock -n 200; then
    log_error "Another instance is running"
    exit 1
  fi

  log_debug "Lock acquired"
}

# Dependency check
check_dependencies() {
  local deps=("jq" "curl")
  local missing=()

  for dep in "${deps[@]}"; do
    if ! command -v "$dep" >/dev/null 2>&1; then
      missing+=("$dep")
    fi
  done

  if [[ ${#missing[@]} -gt 0 ]]; then
    log_error "Missing dependencies: ${missing[*]}"
    exit 1
  fi
}

# Validate input file
validate_input() {
  local file="$1"

  if [[ ! -f "$file" ]]; then
    log_error "Input file not found: $file"
    return 1
  fi

  if [[ ! -r "$file" ]]; then
    log_error "Input file not readable: $file"
    return 1
  fi

  if [[ ! -s "$file" ]]; then
    log_error "Input file is empty: $file"
    return 1
  fi

  # Validate JSON format
  if ! jq empty "$file" 2>/dev/null; then
    log_error "Invalid JSON format: $file"
    return 1
  fi

  return 0
}

# Process user
process_user() {
  local user_data="$1"
  local user_id
  user_id=$(jq -r '.id' <<< "$user_data")

  log_info "Processing user: $user_id"

  # Simulate processing
  sleep 1

  log_info "User processed: $user_id"
  return 0
}

# Retry wrapper
retry() {
  local max_attempts="$1"
  local delay="$2"
  shift 2
  local attempt=1

  while ! "$@"; do
    if ((attempt >= max_attempts)); then
      log_error "Failed after $max_attempts attempts: $*"
      return 1
    fi

    log_warn "Attempt $attempt/$max_attempts failed, retrying in ${delay}s..."
    sleep "$delay"
    delay=$((delay * 2 > 60 ? 60 : delay * 2))
    ((attempt++))
  done
}

# Usage
usage() {
  cat <<EOF
Usage: $SCRIPT_NAME [OPTIONS] <input_file>

Options:
  -h, --help      Show this help message
  -v, --version   Show version
  -d, --debug     Enable debug output
  -q, --quiet     Suppress info messages

Arguments:
  input_file      JSON file containing user data

Examples:
  $SCRIPT_NAME users.json
  $SCRIPT_NAME --debug users.json
EOF
  exit 0
}

# Parse arguments
parse_args() {
  local input_file=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h|--help)
        usage
        ;;
      -v|--version)
        echo "$SCRIPT_NAME version $VERSION"
        exit 0
        ;;
      -d|--debug)
        export DEBUG=1
        shift
        ;;
      -q|--quiet)
        export QUIET=1
        shift
        ;;
      -*)
        log_error "Unknown option: $1"
        usage
        ;;
      *)
        input_file="$1"
        shift
        ;;
    esac
  done

  if [[ -z "$input_file" ]]; then
    log_error "Input file required"
        usage
  fi

  echo "$input_file"
}

# Main function
main() {
  local input_file
  input_file=$(parse_args "$@")

  log_info "Starting $SCRIPT_NAME v$VERSION"
  log_debug "Script directory: $SCRIPT_DIR"
  log_debug "Input file: $input_file"

  acquire_lock
  check_dependencies

  if ! validate_input "$input_file"; then
    exit 1
  fi

  local processed=0
  local failed=0

  # Process users
  while IFS= read -r user_data; do
    if retry "$MAX_RETRIES" "$RETRY_DELAY" process_user "$user_data"; then
      ((processed++))
    else
      ((failed++))
      log_error "Failed to process user"
    fi
  done < <(jq -c '.[]' "$input_file")

  log_info "Processing complete: $processed succeeded, $failed failed"

  if [[ $failed -gt 0 ]]; then
    exit 1
  fi
}

# Run main if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  main "$@"
fi
```

**Key Patterns Demonstrated:**

- ✅ Strict error handling (`set -eEuo pipefail`)
- ✅ Lock file for concurrency control
- ✅ Dependency checking
- ✅ Input validation
- ✅ Structured logging with levels
- ✅ Retry logic with exponential backoff
- ✅ Cleanup on exit
- ✅ Argument parsing
- ✅ Usage documentation
- ✅ Cross-platform compatibility

---

