---
title: Go Engineering Ruleset
description: Secure, idiomatic, maintainable Go with evidence-based performance; applies to generation and review.
priority: 210
alwaysApply: false
files:
  include:
    - "**/*.go"
    - "go.mod"
    - "go.sum"
    - ".golangci.yml"
    - "Makefile"
    - ".github/workflows/go.yml"
---

# Go Engineering Ruleset - (December 2025)

**Audience**: engineers writing and reviewing Go code
**Goal**: secure, idiomatic, efficient, and highly maintainable Go - without over-engineering

**Core Philosophy**: Correctness & Safety  Simplicity & Maintainability  Evidence-Based Performance

**Essential Reading:**
- [Go Proverbs](https://go-proverbs.github.io/) - Simple, poetic, pithy principles from Rob Pike
- [Effective Go](https://go.dev/doc/effective_go) - Official idiomatic Go guide (note: written in 2009, still valuable for language idioms)

---

## Go Proverbs (Core Principles)

These proverbs from Rob Pike guide idiomatic Go:

- **"Don't communicate by sharing memory, share memory by communicating"** - Use channels for coordination
- **"Concurrency is not parallelism"** - Concurrency is about structure, parallelism is about execution
- **"Channels orchestrate; mutexes serialize"** - Use channels for coordination, mutexes for mutual exclusion
- **"The bigger the interface, the weaker the abstraction"** - Keep interfaces small and focused
- **"Make the zero value useful"** - Types should work correctly when zero-initialized
- **"interface{} says nothing"** - Prefer specific types; use generics or type assertions when needed
- **"Gofmt's style is no one's favorite, yet gofmt is everyone's favorite"** - Always use `gofmt`
- **"A little copying is better than a little dependency"** - Prefer copying small code over adding dependencies
- **"Clear is better than clever"** - Readability over cleverness
- **"Reflection is never clear"** - Avoid reflection unless necessary
- **"Errors are values"** - Handle errors explicitly; don't ignore them
- **"Don't just check errors, handle them gracefully"** - Provide context and recovery paths
- **"Don't panic"** - Use errors, not panics, for normal error handling

---

## Quick Reference

### Essential Commands
```bash
# Module Management
go mod init <module>          # Initialize new module
go mod tidy                   # Add missing, remove unused
go test -race ./...          # Run with race detector
go test -cover ./...         # Show coverage
go test -bench=. -benchmem   # Benchmark with memory stats

# Quality & Linting
gofmt -s -w .                # Simplify and format
go vet ./...                 # Vet for suspicious constructs
staticcheck ./...            # Advanced static analysis
golangci-lint run            # Run all linters
govulncheck ./...            # Check vulnerabilities

# Profiling
go test -cpuprofile=cpu.prof -bench=.  # CPU profile
go tool pprof cpu.prof                  # Analyze profile
dlv debug                               # Start delve debugger
```

### Hot reload (Air) for local dev

Use **Air** to rebuild/restart on file changes during local development. This is a **developer convenience**, not a production or CI tool.

**Install (macOS):**

```bash
brew install air
```

**Install (Go toolchain, portable):**

```bash
go install github.com/air-verse/air@latest
```

**Initialize config (recommended):**

```bash
air init
```

**Run:**

```bash
air
# or:
air -c .air.toml
```

**Keep build output out of git:**
- Add `tmp/` (or whatever Air uses) to `.gitignore`

Minimal example `.air.toml` (adjust paths to your app layout; `air init` will generate a version-correct baseline):

```toml
root = "."
tmp_dir = "tmp"

[build]
cmd = "go build -o ./tmp/app ./cmd/server"
bin = "tmp/app"
include_ext = ["go"]
exclude_dir = ["tmp", "vendor", ".git"]
```

### Critical Patterns
```go
// 1. Always check errors
result, err := someFunc()
if err != nil {
    return fmt.Errorf("operation failed: %w", err)  //  Wrap with context
}

// 2. Use context for cancellation
func processData(ctx context.Context, data []string) error {
    for _, item := range data {
        select {
        case <-ctx.Done():
            return ctx.Err()  //  Respect cancellation
        default:
            // Process item
        }
    }
    return nil
}

// 3. Always manage goroutine lifecycle
var wg sync.WaitGroup
wg.Add(1)
go func() {
    defer wg.Done()  //  Always defer Done()
    // work here
}()
wg.Wait()

// 4. Defer cleanup immediately
file, err := os.Open("file.txt")
if err != nil {
    return err
}
defer file.Close()  //  Defer right after open

// 5. Use table-driven tests
func TestAdd(t *testing.T) {
    tests := []struct {
        name string
        a, b int
        want int
    }{
        {"positive", 1, 2, 3},
        {"negative", -1, -2, -3},
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            if got := Add(tt.a, tt.b); got != tt.want {
                t.Errorf("Add() = %v, want %v", got, tt.want)
            }
        })
    }
}
```

---

## 1. Correctness & Safety First

### Error Handling

**Proverb**: "Errors are values" and "Don't just check errors, handle them gracefully"

```go
//  GOOD: Sentinel errors
var ErrNotFound = errors.New("not found")

//  GOOD: Custom error types
type ValidationError struct {
    Field string
    Issue string
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("validation failed on %s: %s", e.Field, e.Issue)
}

//  GOOD: Error wrapping with context
func processUser(id string) error {
    user, err := fetchUser(id)
    if err != nil {
        return fmt.Errorf("failed to process user %s: %w", id, err)
    }
    // ...
}

//  GOOD: Error checking and handling
if errors.Is(err, ErrNotFound) {
    return nil  // Handle gracefully, don't just check
}
var valErr *ValidationError
if errors.As(err, &valErr) {
    log.Printf("validation error on %s: %s", valErr.Field, valErr.Issue)
    return fmt.Errorf("invalid input: %w", valErr)
}

//  GOOD: Errors as values - can be stored, passed, and composed
type ErrorHandler func(error) error

func withRetry(maxAttempts int) ErrorHandler {
    return func(err error) error {
        // Retry logic here
        return err
    }
}

//  BAD: Ignoring errors
result, _ := someFunc()  // Never ignore errors

//  BAD: Panic for normal errors
if err != nil {
    panic(err)  // Use errors, not panics
}
```

### Don't Panic

**Proverb**: "Don't panic"

Panics are for truly exceptional, unrecoverable situations (programming errors). Use errors for normal error handling.

```go
//  BAD: Panic for normal errors
func GetUser(id string) *User {
    user, err := fetchUser(id)
    if err != nil {
        panic(err)  // Wrong! Use errors
    }
    return user
}

//  GOOD: Return errors
func GetUser(id string) (*User, error) {
    user, err := fetchUser(id)
    if err != nil {
        return nil, fmt.Errorf("failed to get user %s: %w", id, err)
    }
    return user, nil
}

//  GOOD: Panic only for programming errors (unrecoverable)
func MustGetUser(id string) *User {
    user, err := fetchUser(id)
    if err != nil {
        panic(fmt.Sprintf("programming error: user %s must exist", id))
    }
    return user
}

//  GOOD: Recover only at package boundaries (main, HTTP handlers)
func httpHandler(w http.ResponseWriter, r *http.Request) {
    defer func() {
        if r := recover(); r != nil {
            log.Printf("panic recovered: %v", r)
            http.Error(w, "internal server error", http.StatusInternalServerError)
        }
    }()
    // Handler logic
}

//  BAD: Recover in library code
func libraryFunction() {
    defer func() {
        recover()  // Libraries should return errors, not recover
    }()
}
```

### Context & Cancellation

```go
//  GOOD: Context as first parameter
func fetchUser(ctx context.Context, id string) (*User, error) {
    req, err := http.NewRequestWithContext(ctx, "GET", "/users/"+id, nil)
    // ...
}

//  GOOD: Check context in loops
func processItems(ctx context.Context, items []Item) error {
    for _, item := range items {
        select {
        case <-ctx.Done():
            return ctx.Err()
        default:
            if err := processItem(item); err != nil {
                return err
            }
        }
    }
    return nil
}
```

### Security

```go
//  GOOD: Input validation
func CreateUser(email string) error {
    if !isValidEmail(email) {
        return fmt.Errorf("invalid email: %w", ErrInvalidInput)
    }
}

//  GOOD: TLS configuration
tlsConfig := &tls.Config{
    MinVersion: tls.VersionTLS13,
}

//  GOOD: Parameterized queries
_, err := db.ExecContext(ctx, "INSERT INTO users (email) VALUES ($1)", email)
```

---

## 2. Simplicity & Idiomatic Go

### Design Principles

- **KISS/DRY/YAGNI**: Avoid speculative abstractions
- **Small Functions**: Do one thing well
- **Small Interfaces**: Define at the consumer ("The bigger the interface, the weaker the abstraction")
- **Composition First**: Prefer composing types
- **Make the Zero Value Useful**: Types should work correctly when zero-initialized
- **A Little Copying is Better Than a Little Dependency**: Prefer copying small, stable code over adding dependencies

### Dependency Management

**Proverb**: "A little copying is better than a little dependency"

```go
//  BAD: Adding dependency for simple utility
import "github.com/some/lib/stringutils"

func process(s string) string {
    return stringutils.TrimAndLower(s)  // Dependency for 10 lines of code
}

//  GOOD: Copy small, stable utility code
func trimAndLower(s string) string {
    return strings.ToLower(strings.TrimSpace(s))
}

func process(s string) string {
    return trimAndLower(s)
}

//  GOOD: Use stdlib when possible
import (
    "strings"
    "fmt"
    "time"
)

//  BAD: External dependency for what stdlib provides
import "github.com/lib/timeutils"  // When time package works fine

//  GOOD: Add dependency only when:
//  - Functionality is complex (crypto, networking, parsing)
//  - Maintenance burden is high
//  - Code is large (>100 lines)
//  - It's a well-maintained, stable library
```

### Make the Zero Value Useful

**Proverb**: "Make the zero value useful"

```go
//  GOOD: Zero value is useful
type Buffer struct {
    data []byte
}

func (b *Buffer) Write(p []byte) (int, error) {
    b.data = append(b.data, p...)
    return len(p), nil
}

// Can use without initialization:
var buf Buffer
buf.Write([]byte("hello"))  // Works!

//  GOOD: Zero value for sync primitives
var mu sync.Mutex
mu.Lock()  // Zero value mutex is ready to use

//  GOOD: Zero value for slices and maps
var users []User  // nil slice, safe to append
var cache map[string]int  // nil map, but must initialize before use

//  BAD: Zero value requires initialization to be safe
type Server struct {
    port int  // Zero value (0) is invalid!
}

func NewServer(port int) *Server {
    if port == 0 {
        panic("port required")  // Zero value not useful
    }
    return &Server{port: port}
}

//  GOOD: Zero value is safe
type Server struct {
    port int
}

func NewServer() *Server {
    return &Server{port: 8080}  // Sensible default
}

func (s *Server) SetPort(port int) {
    s.port = port
}
```

```go
//  GOOD: Small interface at consumer
type UserStore interface {
    GetUser(ctx context.Context, id string) (*User, error)
}

//  GOOD: Function options pattern
type ServerOption func(*ServerOptions)

func WithPort(port int) ServerOption {
    return func(o *ServerOptions) { o.Port = port }
}

func NewServer(opts ...ServerOption) *Server {
    cfg := ServerOptions{Port: 8080, Host: "localhost"}
    for _, opt := range opts {
        opt(&cfg)
    }
    return &Server{/* initialize */}
}
```

### Clear is Better Than Clever

**Proverb**: "Clear is better than clever"

```go
//  BAD: Clever but unclear
func process(data interface{}) interface{} {
    switch v := data.(type) {
    case int:
        return v * 2
    case string:
        return len(v)
    default:
        return nil
    }
}

//  GOOD: Clear and explicit
func DoubleInt(n int) int {
    return n * 2
}

func StringLength(s string) int {
    return len(s)
}

//  BAD: Clever one-liner
result := strings.Join([]string{strings.TrimSpace(s1), strings.TrimSpace(s2)}, ",")

//  GOOD: Clear and readable
s1Trimmed := strings.TrimSpace(s1)
s2Trimmed := strings.TrimSpace(s2)
result := strings.Join([]string{s1Trimmed, s2Trimmed}, ",")

//  BAD: Clever but confusing
func find(items []Item, fn func(Item) bool) *Item {
    for i := range items {
        if fn(items[i]) {
            return &items[i]
        }
    }
    return nil
}

//  GOOD: Clear intent
func FindItem(items []Item, predicate func(Item) bool) *Item {
    for i := range items {
        if predicate(items[i]) {
            return &items[i]
        }
    }
    return nil
}
```

### Avoid interface{} When Possible

**Proverb**: "interface{} says nothing"

```go
//  BAD: interface{} loses type safety
func Process(data interface{}) error {
    // Must use type assertions everywhere
    switch v := data.(type) {
    case string:
        // ...
    case int:
        // ...
    }
}

//  GOOD: Use generics (Go 1.18+)
func Process[T any](data T) error {
    // Type-safe, no assertions needed
    // ...
}

//  GOOD: Use specific types
func ProcessString(s string) error { /* ... */ }
func ProcessInt(n int) error { /* ... */ }

//  GOOD: Use type constraints for flexibility
type Numeric interface {
    ~int | ~int64 | ~float64
}

func Sum[T Numeric](items []T) T {
    var sum T
    for _, item := range items {
        sum += item
    }
    return sum
}
```

### Project Layout

```
project/
 cmd/
    server/main.go
    cli/main.go
 internal/
    auth/
    handler/
 pkg/
    models/
 go.mod
 go.sum
```

### Naming

**Effective Go**: Names are important and have semantic effect (visibility).

- **`gofmt -s`**: Required ("Gofmt's style is no one's favorite, yet gofmt is everyone's favorite")
- **Imports**: Group as stdlib | third-party | internal
- **Exported**: PascalCase; unexported: camelCase
- **Acronyms**: Uppercase (`HTTPServer`, `UserID`)
- **Interfaces**: `-er` suffix (`Reader`, `Hasher`) - keep interfaces small ("The bigger the interface, the weaker the abstraction")
- **Package names**: Lowercase, single-word, concise (`bytes`, `ring`, not `bytesPackage` or `ringPackage`)
- **Getters**: Don't use `Get` prefix (`Owner()`, not `GetOwner()`)

```go
//  GOOD: Package name is concise
package user  // Not userPackage or userManagement

//  GOOD: Exported type uses package name context
type User struct {  // Users see it as user.User
    name string  // unexported field
}

//  GOOD: Getter without "Get" prefix (Effective Go)
func (u *User) Name() string {  // Not GetName()
    return u.name
}

//  GOOD: Setter can use "Set" prefix
func (u *User) SetName(name string) {
    u.name = name
}

//  GOOD: Small interface at consumer
type Reader interface {  // Small, focused
    Read([]byte) (int, error)
}

//  BAD: Large interface ("The bigger the interface, the weaker the abstraction")
type Everything interface {
    Read([]byte) (int, error)
    Write([]byte) (int, error)
    Close() error
    Flush() error
    Seek(int64, int) (int64, error)
    // ... too many methods
}

//  GOOD: Avoid interface{} - use generics or specific types
func Process[T any](items []T) {  // Generic, type-safe
    // ...
}

//  BAD: interface{} says nothing
func Process(items []interface{}) {  // No type safety
    // ...
}
```

---

## 3. Concurrency

**Proverbs**:
- "Don't communicate by sharing memory, share memory by communicating"
- "Channels orchestrate; mutexes serialize"
- "Concurrency is not parallelism"

### Advanced Concurrency Patterns

**Worker Pool Pattern:**

```go
func ProcessWithWorkerPool(ctx context.Context, jobs []Job, numWorkers int) ([]Result, error) {
    jobChan := make(chan Job, len(jobs))
    resultChan := make(chan Result, len(jobs))

    // Start workers
    var wg sync.WaitGroup
    for i := 0; i < numWorkers; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for job := range jobChan {
                select {
                case <-ctx.Done():
                    return
                default:
                    result := processJob(job)
                    resultChan <- result
                }
            }
        }()
    }

    // Send jobs
    go func() {
        defer close(jobChan)
        for _, job := range jobs {
            select {
            case <-ctx.Done():
                return
            case jobChan <- job:
            }
        }
    }()

    // Wait for workers and close results
    go func() {
        wg.Wait()
        close(resultChan)
    }()

    // Collect results
    var results []Result
    for result := range resultChan {
        results = append(results, result)
    }

    return results, nil
}
```

**Pipeline Pattern:**

```go
func ProcessPipeline(ctx context.Context, input <-chan Item) <-chan Result {
    stage1 := transformStage(ctx, input)
    stage2 := filterStage(ctx, stage1)
    stage3 := aggregateStage(ctx, stage2)
    return stage3
}

func transformStage(ctx context.Context, input <-chan Item) <-chan Transformed {
    output := make(chan Transformed)
    go func() {
        defer close(output)
        for item := range input {
            select {
            case <-ctx.Done():
                return
            case output <- transform(item):
            }
        }
    }()
    return output
}
```

**Semaphore Pattern:**

```go
type Semaphore struct {
    ch chan struct{}
}

func NewSemaphore(limit int) *Semaphore {
    return &Semaphore{
        ch: make(chan struct{}, limit),
    }
}

func (s *Semaphore) Acquire(ctx context.Context) error {
    select {
    case s.ch <- struct{}{}:
        return nil
    case <-ctx.Done():
        return ctx.Err()
    }
}

func (s *Semaphore) Release() {
    <-s.ch
}

// Usage
sem := NewSemaphore(10) // Max 10 concurrent operations
for _, item := range items {
    if err := sem.Acquire(ctx); err != nil {
        return err
    }
    go func(item Item) {
        defer sem.Release()
        process(item)
    }(item)
}
```

**Timeout Pattern:**

```go
func ProcessWithTimeout(ctx context.Context, duration time.Duration, fn func() error) error {
    ctx, cancel := context.WithTimeout(ctx, duration)
    defer cancel()

    done := make(chan error, 1)
    go func() {
        done <- fn()
    }()

    select {
    case err := <-done:
        return err
    case <-ctx.Done():
        return fmt.Errorf("operation timed out: %w", ctx.Err())
    }
}
```

**Bounded Channel Pattern:**

```go
func ProcessWithBackpressure(ctx context.Context, items []Item, bufferSize int) error {
    // Bounded channel prevents unbounded memory growth
    itemChan := make(chan Item, bufferSize)

    go func() {
        defer close(itemChan)
        for _, item := range items {
            select {
            case <-ctx.Done():
                return
            case itemChan <- item:
            }
        }
    }()

    for item := range itemChan {
        if err := process(item); err != nil {
            return err
        }
    }
    return nil
}
```

### Choose the Simplest Correct Primitive

**Rule**: Use channels for coordination/orchestration, mutexes for mutual exclusion.

```go
//  GOOD: Mutex for protecting shared state (serialization)
type SafeCounter struct {
    mu    sync.Mutex
    count int
}

func (c *SafeCounter) Increment() {
    c.mu.Lock()
    defer c.mu.Unlock()  // Always use defer
    c.count++
}

//  GOOD: Channel for communication/orchestration
func worker(jobs <-chan Job, results chan<- Result) {
    for job := range jobs {
        results <- process(job)
    }
}

//  GOOD: Channel for coordination (orchestration)
func processWithCoordination(ctx context.Context, items []Item) error {
    done := make(chan error, 1)
    go func() {
        // Process items
        done <- nil
    }()

    select {
    case err := <-done:
        return err
    case <-ctx.Done():
        return ctx.Err()
    }
}

//  BAD: Using channel for simple mutual exclusion
type Counter struct {
    ch chan int  // Overkill for simple counter
}

//  GOOD: Mutex for simple mutual exclusion
type Counter struct {
    mu sync.Mutex
    count int
}

//  GOOD: sync.Once for one-time initialization
var (
    instance *Singleton
    once     sync.Once
)

func GetInstance() *Singleton {
    once.Do(func() {
        instance = &Singleton{}
    })
    return instance
}
```

### Goroutine Management

```go
//  GOOD: errgroup for error propagation
import "golang.org/x/sync/errgroup"

func processFiles(ctx context.Context, files []string) error {
    g, ctx := errgroup.WithContext(ctx)
    g.SetLimit(10)  // Max 10 concurrent goroutines

    for _, file := range files {
        file := file
        g.Go(func() error {
            return processFile(ctx, file)
        })
    }

    return g.Wait()
}
```

### Race Safety

- **Required**: Code must pass `go test -race`
- **No Data Races**: Even "benign" ones

---

## 4. Performance (Evidence-Based Only)

**Golden Rule:** Measure first, optimize second. Use benchmarks and profiling to guide optimization.

### Measurement Required

```go
func BenchmarkProcessData(b *testing.B) {
    data := generateTestData()
    b.ResetTimer()
    b.ReportAllocs()

    for i := 0; i < b.N; i++ {
        ProcessData(data)
    }
}
```

### Performance Optimization Examples

**Slice Pre-allocation:**

```go
// BAD: Grows slice dynamically
var result []int
for i := 0; i < 1000; i++ {
    result = append(result, i*2)  // May cause multiple allocations
}

// GOOD: Pre-allocate with known capacity
result := make([]int, 0, 1000)
for i := 0; i < 1000; i++ {
    result = append(result, i*2)  // No reallocation
}

// GOOD: Pre-allocate with known length
result := make([]int, 1000)
for i := 0; i < 1000; i++ {
    result[i] = i * 2
}
```

**String Building:**

```go
// BAD: String concatenation (creates new strings)
var result string
for _, part := range parts {
    result += part  // O(n²) complexity
}

// GOOD: strings.Builder
var sb strings.Builder
sb.Grow(estimatedSize)  // Pre-allocate if size known
for _, part := range parts {
    sb.WriteString(part)
}
result := sb.String()

// GOOD: For small, known strings, use fmt.Sprintf
result := fmt.Sprintf("%s-%s-%s", part1, part2, part3)
```

**Map Pre-allocation:**

```go
// BAD: Map grows dynamically
cache := make(map[string]int)
for _, key := range keys {
    cache[key] = process(key)
}

// GOOD: Pre-allocate if size known
cache := make(map[string]int, len(keys))
for _, key := range keys {
    cache[key] = process(key)
}
```

**Avoid Unnecessary Allocations:**

```go
// BAD: Unnecessary allocation in hot path
func process(items []Item) {
    for _, item := range items {
        data := make(map[string]interface{})  // Allocated each iteration
        data["key"] = item.Value
        processData(data)
    }
}

// GOOD: Reuse allocation
func process(items []Item) {
    data := make(map[string]interface{})  // Allocated once
    for _, item := range items {
        data["key"] = item.Value
        processData(data)
        // Clear for next iteration if needed
        for k := range data {
            delete(data, k)
        }
    }
}
```

**Efficient Lookups:**

```go
// BAD: Linear search
func findUser(users []User, id string) *User {
    for _, user := range users {
        if user.ID == id {
            return &user
        }
    }
    return nil
}

// GOOD: Use map for O(1) lookup
type UserIndex map[string]*User

func buildIndex(users []User) UserIndex {
    index := make(UserIndex, len(users))
    for i := range users {
        index[users[i].ID] = &users[i]
    }
    return index
}
```

**Memory Management:**

```go
// GOOD: Preallocate slice
users := make([]User, 0, expectedCount)

// GOOD: strings.Builder for concatenation
var sb strings.Builder
sb.Grow(estimatedSize)
for _, part := range parts {
    sb.WriteString(part)
}
result := sb.String()

// GOOD: Use sync.Pool for frequently allocated objects
var bufferPool = sync.Pool{
    New: func() interface{} {
        return new(bytes.Buffer)
    },
}

func getBuffer() *bytes.Buffer {
    return bufferPool.Get().(*bytes.Buffer)
}

func putBuffer(buf *bytes.Buffer) {
    buf.Reset()
    bufferPool.Put(buf)
}
```

**CPU Optimization:**

```go
// BAD: Inefficient algorithm
func findDuplicates(items []int) []int {
    var duplicates []int
    for i, item1 := range items {
        for j, item2 := range items {
            if i != j && item1 == item2 {
                duplicates = append(duplicates, item1)
                break
            }
        }
    }
    return duplicates  // O(n²)
}

// GOOD: Efficient algorithm with map
func findDuplicates(items []int) []int {
    seen := make(map[int]bool, len(items))
    duplicates := make([]int, 0)

    for _, item := range items {
        if seen[item] {
            duplicates = append(duplicates, item)
        } else {
            seen[item] = true
        }
    }
    return duplicates  // O(n)
}
```

**Avoid Interface Conversions:**

```go
// BAD: Interface conversion in hot path
func process(items []interface{}) {
    for _, item := range items {
        switch v := item.(type) {
        case int:
            processInt(v)
        case string:
            processString(v)
        }
    }
}

// GOOD: Use generics or specific types
func processInts(items []int) {
    for _, item := range items {
        processInt(item)
    }
}
```

---

## 5. Testing & Quality

### Test Structure

```go
//  GOOD: Table-driven test
func TestAdd(t *testing.T) {
    tests := []struct {
        name string
        a, b int
        want int
    }{
        {"positive", 1, 2, 3},
        {"negative", -1, -2, -3},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            t.Parallel()

            got := Add(tt.a, tt.b)
            if got != tt.want {
                t.Errorf("Add(%d, %d) = %d, want %d", tt.a, tt.b, got, tt.want)
            }
        })
    }
}

//  GOOD: Fuzz test
func FuzzParseURL(f *testing.F) {
    f.Add("https://acme.com")

    f.Fuzz(func(t *testing.T, url string) {
        _, err := ParseURL(url)
        _ = err  // Must not panic
    })
}
```

### Advanced Testing Patterns

**Test Helpers:**

```go
func setupTestDB(t *testing.T) *sql.DB {
    t.Helper()  // Marks this as a test helper

    db, err := sql.Open("sqlite3", ":memory:")
    if err != nil {
        t.Fatalf("failed to open test DB: %v", err)
    }

    // Setup schema
    if _, err := db.Exec("CREATE TABLE users (id TEXT PRIMARY KEY, name TEXT)"); err != nil {
        t.Fatalf("failed to create table: %v", err)
    }

    t.Cleanup(func() {
        db.Close()
    })

    return db
}

func TestUserService(t *testing.T) {
    db := setupTestDB(t)
    service := NewUserService(db)
    // Test implementation...
}
```

**Mocking with Interfaces:**

```go
type UserRepository interface {
    GetUser(ctx context.Context, id string) (*User, error)
}

type MockUserRepository struct {
    GetUserFunc func(ctx context.Context, id string) (*User, error)
}

func (m *MockUserRepository) GetUser(ctx context.Context, id string) (*User, error) {
    if m.GetUserFunc != nil {
        return m.GetUserFunc(ctx, id)
    }
    return nil, ErrNotFound
}

func TestUserService_GetUser(t *testing.T) {
    mockRepo := &MockUserRepository{
        GetUserFunc: func(ctx context.Context, id string) (*User, error) {
            if id == "test-id" {
                return &User{ID: "test-id", Name: "Test"}, nil
            }
            return nil, ErrNotFound
        },
    }

    service := NewUserService(mockRepo)
    user, err := service.GetUser(context.Background(), "test-id")

    if err != nil {
        t.Fatalf("unexpected error: %v", err)
    }
    if user.Name != "Test" {
        t.Errorf("got name %q, want %q", user.Name, "Test")
    }
}
```

**Integration Tests:**

```go
// +build integration

package integration

import (
    "testing"
    "context"
)

func TestUserService_Integration(t *testing.T) {
    if testing.Short() {
        t.Skip("skipping integration test")
    }

    // Use real database
    db := setupRealDB(t)
    service := NewUserService(db)

    // Test with real dependencies
    user, err := service.CreateUser(context.Background(), &User{Name: "Test"})
    if err != nil {
        t.Fatalf("failed to create user: %v", err)
    }

    retrieved, err := service.GetUser(context.Background(), user.ID)
    if err != nil {
        t.Fatalf("failed to get user: %v", err)
    }

    if retrieved.Name != "Test" {
        t.Errorf("got name %q, want %q", retrieved.Name, "Test")
    }
}
```

**Concurrent Test Safety:**

```go
func TestConcurrentAccess(t *testing.T) {
    service := NewUserService(setupTestDB(t))

    t.Run("concurrent writes", func(t *testing.T) {
        const numGoroutines = 100
        var wg sync.WaitGroup
        wg.Add(numGoroutines)

        for i := 0; i < numGoroutines; i++ {
            go func(id int) {
                defer wg.Done()
                _, err := service.CreateUser(context.Background(), &User{
                    ID:   fmt.Sprintf("user-%d", id),
                    Name: fmt.Sprintf("User %d", id),
                })
                if err != nil {
                    t.Errorf("failed to create user: %v", err)
                }
            }(i)
        }

        wg.Wait()
    })
}
```

**Benchmark Tests:**

```go
func BenchmarkProcessItems(b *testing.B) {
    items := generateTestItems(1000)

    b.ResetTimer()
    b.ReportAllocs()

    for i := 0; i < b.N; i++ {
        ProcessItems(items)
    }
}

func BenchmarkProcessItemsParallel(b *testing.B) {
    items := generateTestItems(1000)

    b.ResetTimer()
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            ProcessItems(items)
        }
    })
}

// Compare implementations
func BenchmarkOldImplementation(b *testing.B) {
    // Old code
}

func BenchmarkNewImplementation(b *testing.B) {
    // New optimized code
}
```

### CI Gates (Non-Negotiable)

```bash
gofmt -s -w .
go vet ./...
staticcheck ./...
golangci-lint run
go test -race ./...
govulncheck ./...
```

---

## 6. Common Mistakes & Anti-Patterns

### 1. Using Goroutines Without WaitGroup

```go
//  BAD: Fire-and-forget
func processItems(items []Item) {
    for _, item := range items {
        go process(item)  // No way to wait!
    }
}

//  GOOD: Use WaitGroup
func processItems(items []Item) {
    var wg sync.WaitGroup
    for _, item := range items {
        wg.Add(1)
        go func(item Item) {
            defer wg.Done()
            process(item)
        }(item)
    }
    wg.Wait()
}
```

### 2. Not Checking Error Returns

```go
//  BAD: Ignoring errors
result, _ := someFunc()

//  GOOD: Check errors
result, err := someFunc()
if err != nil {
    return fmt.Errorf("someFunc failed: %w", err)
}
```

### 3. Shadowing Variables with `:=`

```go
//  BAD: Shadowing err
result, err := step1()
if result.NeedsStep2 {
    result, err := step2()  // Shadows outer err!
}

//  GOOD: Reuse err
result, err := step1()
if result.NeedsStep2 {
    result, err = step2()  // Reuses outer err
}
```

### 4. Closing Channels from Receiver Side

```go
//  BAD: Receiver closes channel
func receiver(ch <-chan int) {
    for v := range ch {
        process(v)
    }
    close(ch)  // WRONG! Only sender should close
}

//  GOOD: Sender closes channel
func sender(ch chan<- int, values []int) {
    defer close(ch)
    for _, v := range values {
        ch <- v
    }
}
```

### 5. Global Mutable State

```go
//  BAD: Global mutable state
var cache = make(map[string]interface{})

func Get(key string) interface{} {
    return cache[key]  // Race!
}

//  GOOD: Encapsulated with mutex
type Cache struct {
    mu    sync.RWMutex
    items map[string]interface{}
}

func (c *Cache) Get(key string) (interface{}, bool) {
    c.mu.RLock()
    defer c.mu.RUnlock()
    val, ok := c.items[key]
    return val, ok
}
```

---

## 7. Troubleshooting Guide

### Debug Logging

```go
import "log/slog"

logger := slog.New(slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{
    Level: slog.LevelDebug,
}))

logger.Debug("processing user", "user_id", userID, "step", "validation")
```

**Structured Logging Best Practices:**

```go
// GOOD: Include context in logs
logger.Info("user created",
    "user_id", userID,
    "email", email,
    "duration_ms", duration.Milliseconds(),
)

// GOOD: Use different log levels appropriately
logger.Debug("detailed debug info", "internal_state", state)
logger.Info("important events", "event", "user_login")
logger.Warn("recoverable issues", "warning", "rate_limit_approaching")
logger.Error("errors that need attention", "error", err)

// GOOD: Log errors with context
logger.Error("failed to process request",
    "error", err,
    "request_id", requestID,
    "user_id", userID,
)
```

### Using Delve

```bash
dlv debug ./cmd/myapp
dlv test ./pkg/mypackage
dlv attach <PID>

# Delve commands
(dlv) break main.main
(dlv) continue
(dlv) next
(dlv) print variable
(dlv) goroutines
(dlv) goroutine <id>
(dlv) stack
(dlv) locals
(dlv) args
```

**Debugging Goroutines:**

```go
// Add debug logging to track goroutines
import (
    "runtime"
    "log/slog"
)

func debugGoroutines(logger *slog.Logger) {
    buf := make([]byte, 1<<20)
    stackSize := runtime.Stack(buf, true)
    logger.Debug("goroutines", "stack", string(buf[:stackSize]))
}
```

### CPU Profiling

```bash
go test -cpuprofile=cpu.prof -bench=.
go tool pprof cpu.prof

# pprof commands
(pprof) top          # Top functions by CPU time
(pprof) top10        # Top 10 functions
(pprof) list func    # Show source code for function
(pprof) web          # Generate SVG graph
(pprof) png          # Generate PNG graph
(pprof) peek func    # Show callers and callees
```

**Memory Profiling:**

```bash
go test -memprofile=mem.prof -bench=.
go tool pprof mem.prof

# Memory-specific commands
(pprof) top -alloc_space    # Top allocators
(pprof) top -inuse_space   # Top memory users
(pprof) list func          # Show allocations in function
```

**HTTP Profiling:**

```go
import _ "net/http/pprof"

func main() {
    go func() {
        log.Println(http.ListenAndServe("localhost:6060", nil))
    }()
    // Application code...
}

// Then profile:
// go tool pprof http://localhost:6060/debug/pprof/profile
// go tool pprof http://localhost:6060/debug/pprof/heap
```

### Common Errors & Solutions

**Nil Pointer:**

```go
// BAD: Potential nil pointer dereference
func process(user *User) {
    fmt.Println(user.Name)  // Panic if user is nil
}

// GOOD: Check nil first
func process(user *User) error {
    if user == nil {
        return fmt.Errorf("user is nil")
    }
    fmt.Println(user.Name)
    return nil
}
```

**Index Out of Range:**

```go
// BAD: No bounds checking
func getFirst(items []Item) Item {
    return items[0]  // Panic if slice is empty
}

// GOOD: Check length
func getFirst(items []Item) (Item, error) {
    if len(items) == 0 {
        return Item{}, fmt.Errorf("items is empty")
    }
    return items[0], nil
}
```

**Deadlock Detection:**

```go
// BAD: Potential deadlock
func process() {
    ch := make(chan int)
    ch <- 1  // Blocks forever if no receiver
    <-ch
}

// GOOD: Use buffered channel or ensure receiver exists
func process() {
    ch := make(chan int, 1)  // Buffered
    ch <- 1
    <-ch
}

// Or use context for timeout
func processWithTimeout(ctx context.Context) error {
    ch := make(chan int)
    select {
    case ch <- 1:
        return nil
    case <-ctx.Done():
        return ctx.Err()
    }
}
```

**Race Condition Detection:**

```bash
# Run tests with race detector
go test -race ./...

# Build with race detector
go build -race ./cmd/myapp

# Race detector will report:
# WARNING: DATA RACE
# Read at 0x00c00001a0f0 by goroutine 7:
#   main.func1()
#     /path/to/file.go:10 +0x3a
# Previous write at 0x00c00001a0f0 by goroutine 6:
#   main.func2()
#     /path/to/file.go:15 +0x47
```

**Goroutine Leaks:**

```go
// BAD: Goroutine leak
func process() {
    go func() {
        for {
            // Infinite loop, never exits
            doWork()
        }
    }()
}

// GOOD: Use context for cancellation
func process(ctx context.Context) {
    go func() {
        for {
            select {
            case <-ctx.Done():
                return  // Exit when cancelled
            default:
                doWork()
            }
        }
    }()
}
```

**Memory Leaks:**

```go
// BAD: Keeping references to large objects
var globalCache = make(map[string]*LargeObject)

func process(key string) {
    obj := &LargeObject{Data: make([]byte, 1000000)}
    globalCache[key] = obj  // Never cleaned up
}

// GOOD: Use weak references or cleanup
type Cache struct {
    mu    sync.RWMutex
    items map[string]*LargeObject
    maxSize int
}

func (c *Cache) Set(key string, obj *LargeObject) {
    c.mu.Lock()
    defer c.mu.Unlock()

    if len(c.items) >= c.maxSize {
        // Evict oldest or least recently used
        c.evict()
    }
    c.items[key] = obj
}
```

---

## 8. CI/CD Integration

### GitHub Actions Example

```yaml
name: Go CI

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        go-version: ['1.24', '1.25']

    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version: ${{ matrix.go-version }}
          cache: true

      - run: go mod download
      - run: gofmt -s -l . | tee /dev/stderr | test -z "$(cat)"
      - run: go vet ./...
      - run: staticcheck ./...
      - run: golangci-lint run
      - run: go test -race -coverprofile=coverage.out ./...
      - run: govulncheck ./...
```

---

## 9. Advanced Patterns

### Fan-Out, Fan-In

```go
func fanOutFanIn(ctx context.Context, inputs []Input) ([]Result, error) {
    jobs := make(chan Input, len(inputs))
    results := make(chan Result, len(inputs))

    // Start workers
    var wg sync.WaitGroup
    for i := 0; i < runtime.NumCPU(); i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for input := range jobs {
                select {
                case results <- process(input):
                case <-ctx.Done():
                    return
                }
            }
        }()
    }

    // Send jobs and close
    go func() {
        for _, input := range inputs {
            jobs <- input
        }
        close(jobs)
    }()

    // Wait and close results
    go func() {
        wg.Wait()
        close(results)
    }()

    // Collect results
    var collected []Result
    for result := range results {
        collected = append(collected, result)
    }

    return collected, nil
}
```

### Rate Limiting

```go
type RateLimiter struct {
    rate     int
    tokens   chan struct{}
}

func NewRateLimiter(rate int) *RateLimiter {
    rl := &RateLimiter{
        rate:   rate,
        tokens: make(chan struct{}, rate),
    }
    for i := 0; i < rate; i++ {
        rl.tokens <- struct{}{}
    }
    return rl
}

func (rl *RateLimiter) Wait(ctx context.Context) error {
    select {
    case <-rl.tokens:
        return nil
    case <-ctx.Done():
        return ctx.Err()
    }
}
```

---

## 10. AWS & Cloud Integration

### AWS SDK for Go (v2)

**Client Initialization:**

```go
import (
    "context"
    "github.com/aws/aws-sdk-go-v2/config"
    "github.com/aws/aws-sdk-go-v2/service/s3"
    "github.com/aws/aws-sdk-go-v2/aws"
)

// GOOD: Create clients in global scope (Lambda) or at application startup
var s3Client *s3.Client

func init() {
    cfg, err := config.LoadDefaultConfig(context.TODO(),
        config.WithRegion("us-east-1"),
    )
    if err != nil {
        panic(fmt.Errorf("failed to load AWS config: %w", err))
    }
    s3Client = s3.NewFromConfig(cfg)
}

// GOOD: Client factory with retry configuration
func NewS3Client(ctx context.Context, region string) (*s3.Client, error) {
    cfg, err := config.LoadDefaultConfig(ctx,
        config.WithRegion(region),
        config.WithRetryMaxAttempts(5),
    )
    if err != nil {
        return nil, fmt.Errorf("failed to load AWS config: %w", err)
    }
    return s3.NewFromConfig(cfg), nil
}
```

**Error Handling:**

```go
import (
    "github.com/aws/aws-sdk-go-v2/service/s3"
    "github.com/aws/aws-sdk-go-v2/service/s3/types"
    "github.com/aws/smithy-go"
)

func GetObject(ctx context.Context, client *s3.Client, bucket, key string) ([]byte, error) {
    result, err := client.GetObject(ctx, &s3.GetObjectInput{
        Bucket: aws.String(bucket),
        Key:    aws.String(key),
    })
    if err != nil {
        var nsk *types.NoSuchKey
        if errors.As(err, &nsk) {
            return nil, fmt.Errorf("object not found: %w", ErrNotFound)
        }

        var apiErr smithy.APIError
        if errors.As(err, &apiErr) {
            return nil, fmt.Errorf("AWS API error: %s - %s", apiErr.ErrorCode(), apiErr.ErrorMessage())
        }

        return nil, fmt.Errorf("failed to get object: %w", err)
    }
    defer result.Body.Close()

    return io.ReadAll(result.Body)
}
```

**Pagination:**

```go
import "github.com/aws/aws-sdk-go-v2/service/s3"

func ListObjects(ctx context.Context, client *s3.Client, bucket string) ([]string, error) {
    var keys []string
    paginator := s3.NewListObjectsV2Paginator(client, &s3.ListObjectsV2Input{
        Bucket: aws.String(bucket),
    })

    for paginator.HasMorePages() {
        page, err := paginator.NextPage(ctx)
        if err != nil {
            return nil, fmt.Errorf("failed to list objects: %w", err)
        }

        for _, obj := range page.Contents {
            keys = append(keys, aws.ToString(obj.Key))
        }
    }

    return keys, nil
}
```

**Lambda Handler Pattern:**

```go
import (
    "context"
    "github.com/aws/aws-lambda-go/lambda"
    "github.com/aws/aws-sdk-go-v2/service/dynamodb"
)

var dynamoClient *dynamodb.Client

func init() {
    cfg, _ := config.LoadDefaultConfig(context.TODO())
    dynamoClient = dynamodb.NewFromConfig(cfg)
}

type Event struct {
    UserID string `json:"user_id"`
}

type Response struct {
    StatusCode int    `json:"status_code"`
    Body       string `json:"body"`
}

func handler(ctx context.Context, event Event) (Response, error) {
    // Use global client
    result, err := dynamoClient.GetItem(ctx, &dynamodb.GetItemInput{
        TableName: aws.String("users"),
        Key: map[string]types.AttributeValue{
            "id": &types.AttributeValueMemberS{Value: event.UserID},
        },
    })
    if err != nil {
        return Response{StatusCode: 500, Body: "Internal error"}, err
    }

    return Response{StatusCode: 200, Body: "Success"}, nil
}

func main() {
    lambda.Start(handler)
}
```

**Context Propagation:**

```go
func ProcessWithTimeout(ctx context.Context, client *s3.Client, bucket, key string) error {
    // Create context with timeout
    ctx, cancel := context.WithTimeout(ctx, 30*time.Second)
    defer cancel()

    // Context automatically propagates cancellation
    _, err := client.GetObject(ctx, &s3.GetObjectInput{
        Bucket: aws.String(bucket),
        Key:    aws.String(key),
    })
    if err != nil {
        if errors.Is(err, context.DeadlineExceeded) {
            return fmt.Errorf("operation timed out: %w", err)
        }
        return fmt.Errorf("failed to get object: %w", err)
    }

    return nil
}
```

**Region Validation:**

```go
var allowedRegions = map[string]bool{
    "us-east-1": true,
    "us-west-2": true,
    "eu-west-1": true,
}

func ValidateRegion(region string) error {
    if !allowedRegions[region] {
        return fmt.Errorf("invalid region: %s", region)
    }
    return nil
}
```

## 11. CLI Development

### Using cobra (Recommended)

**Installation:**

```bash
go get -u github.com/spf13/cobra/cobra
```

**Basic CLI Structure:**

```go
package main

import (
    "fmt"
    "github.com/spf13/cobra"
)

var rootCmd = &cobra.Command{
    Use:   "myapp",
    Short: "My application description",
    Long:  "Long description of my application",
    Run: func(cmd *cobra.Command, args []string) {
        fmt.Println("Hello from myapp")
    },
}

var versionCmd = &cobra.Command{
    Use:   "version",
    Short: "Print version",
    Run: func(cmd *cobra.Command, args []string) {
        fmt.Println("v1.0.0")
    },
}

var processCmd = &cobra.Command{
    Use:   "process [file]",
    Short: "Process a file",
    Args:  cobra.ExactArgs(1),
    RunE: func(cmd *cobra.Command, args []string) error {
        file := args[0]
        dryRun, _ := cmd.Flags().GetBool("dry-run")

        if dryRun {
            fmt.Printf("Would process: %s\n", file)
            return nil
        }

        return processFile(file)
    },
}

func init() {
    rootCmd.AddCommand(versionCmd)
    rootCmd.AddCommand(processCmd)

    processCmd.Flags().BoolP("dry-run", "d", false, "Preview without executing")
}

func main() {
    if err := rootCmd.Execute(); err != nil {
        fmt.Fprintf(os.Stderr, "Error: %v\n", err)
        os.Exit(1)
    }
}
```

### Using urfave/cli (Alternative)

```go
package main

import (
    "fmt"
    "os"
    "github.com/urfave/cli/v2"
)

func main() {
    app := &cli.App{
        Name:  "myapp",
        Usage: "My application",
        Commands: []*cli.Command{
            {
                Name:  "process",
                Usage: "Process a file",
                Flags: []cli.Flag{
                    &cli.StringFlag{
                        Name:     "file",
                        Aliases:  []string{"f"},
                        Usage:    "File to process",
                        Required: true,
                    },
                    &cli.BoolFlag{
                        Name:  "dry-run",
                        Usage: "Preview without executing",
                    },
                },
                Action: func(c *cli.Context) error {
                    file := c.String("file")
                    dryRun := c.Bool("dry-run")

                    if dryRun {
                        fmt.Printf("Would process: %s\n", file)
                        return nil
                    }

                    return processFile(file)
                },
            },
        },
    }

    if err := app.Run(os.Args); err != nil {
        fmt.Fprintf(os.Stderr, "Error: %v\n", err)
        os.Exit(1)
    }
}
```

### CLI Best Practices

```go
// GOOD: Validate inputs early
func validateInput(file string) error {
    if file == "" {
        return fmt.Errorf("file is required")
    }
    if _, err := os.Stat(file); os.IsNotExist(err) {
        return fmt.Errorf("file does not exist: %s", file)
    }
    return nil
}

// GOOD: Use context for cancellation
func processWithContext(ctx context.Context, file string) error {
    select {
    case <-ctx.Done():
        return ctx.Err()
    default:
        return processFile(file)
    }
}

// GOOD: Structured output (JSON flag)
func outputResult(result interface{}, format string) error {
    switch format {
    case "json":
        enc := json.NewEncoder(os.Stdout)
        enc.SetIndent("", "  ")
        return enc.Encode(result)
    case "yaml":
        data, err := yaml.Marshal(result)
        if err != nil {
            return err
        }
        fmt.Print(string(data))
        return nil
    default:
        fmt.Printf("%+v\n", result)
        return nil
    }
}
```

## 12. Design Patterns (Expanded)

### Factory Pattern

```go
// Database connection factory
type DatabaseType string

const (
    Postgres DatabaseType = "postgres"
    MySQL    DatabaseType = "mysql"
)

type Database interface {
    Query(ctx context.Context, sql string) ([]map[string]interface{}, error)
    Close() error
}

type PostgresDB struct {
    conn *sql.DB
}

func (p *PostgresDB) Query(ctx context.Context, sql string) ([]map[string]interface{}, error) {
    rows, err := p.conn.QueryContext(ctx, sql)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    // Process rows...
    return nil, nil
}

func (p *PostgresDB) Close() error {
    return p.conn.Close()
}

type MySQLDB struct {
    conn *sql.DB
}

func (m *MySQLDB) Query(ctx context.Context, sql string) ([]map[string]interface{}, error) {
    // MySQL-specific implementation
    return nil, nil
}

func (m *MySQLDB) Close() error {
    return m.conn.Close()
}

func NewDatabase(dbType DatabaseType, dsn string) (Database, error) {
    switch dbType {
    case Postgres:
        conn, err := sql.Open("postgres", dsn)
        if err != nil {
            return nil, err
        }
        return &PostgresDB{conn: conn}, nil
    case MySQL:
        conn, err := sql.Open("mysql", dsn)
        if err != nil {
            return nil, err
        }
        return &MySQLDB{conn: conn}, nil
    default:
        return nil, fmt.Errorf("unsupported database type: %s", dbType)
    }
}
```

### Strategy Pattern

```go
// Deployment strategy
type DeploymentStrategy interface {
    Deploy(ctx context.Context, app string) error
}

type DevelopmentDeployment struct{}

func (d *DevelopmentDeployment) Deploy(ctx context.Context, app string) error {
    fmt.Printf("Deploying %s to dev (single instance)\n", app)
    return nil
}

type ProductionDeployment struct{}

func (p *ProductionDeployment) Deploy(ctx context.Context, app string) error {
    fmt.Printf("Deploying %s to prod (multi-AZ, auto-scaling)\n", app)
    return nil
}

type DeploymentContext struct {
    strategy DeploymentStrategy
}

func NewDeploymentContext(strategy DeploymentStrategy) *DeploymentContext {
    return &DeploymentContext{strategy: strategy}
}

func (dc *DeploymentContext) Execute(ctx context.Context, app string) error {
    return dc.strategy.Deploy(ctx, app)
}
```

### Observer Pattern

```go
type Event string

const (
    UserCreated Event = "user.created"
    UserUpdated Event = "user.updated"
)

type EventHandler interface {
    Handle(ctx context.Context, event Event, data interface{}) error
}

type EventBus struct {
    handlers map[Event][]EventHandler
    mu       sync.RWMutex
}

func NewEventBus() *EventBus {
    return &EventBus{
        handlers: make(map[Event][]EventHandler),
    }
}

func (eb *EventBus) Subscribe(event Event, handler EventHandler) {
    eb.mu.Lock()
    defer eb.mu.Unlock()
    eb.handlers[event] = append(eb.handlers[event], handler)
}

func (eb *EventBus) Publish(ctx context.Context, event Event, data interface{}) error {
    eb.mu.RLock()
    handlers := eb.handlers[event]
    eb.mu.RUnlock()

    for _, handler := range handlers {
        if err := handler.Handle(ctx, event, data); err != nil {
            return fmt.Errorf("handler failed: %w", err)
        }
    }
    return nil
}
```

## 13. Generics (Expanded Coverage)

### Generic Functions

```go
// GOOD: Generic function for any comparable type
func Find[T comparable](slice []T, value T) (int, bool) {
    for i, v := range slice {
        if v == value {
            return i, true
        }
    }
    return -1, false
}

// Usage
idx, found := Find([]string{"a", "b", "c"}, "b")
idx, found := Find([]int{1, 2, 3}, 2)
```

### Generic Types

```go
// Generic stack
type Stack[T any] struct {
    items []T
    mu    sync.Mutex
}

func NewStack[T any]() *Stack[T] {
    return &Stack[T]{items: make([]T, 0)}
}

func (s *Stack[T]) Push(item T) {
    s.mu.Lock()
    defer s.mu.Unlock()
    s.items = append(s.items, item)
}

func (s *Stack[T]) Pop() (T, bool) {
    s.mu.Lock()
    defer s.mu.Unlock()

    if len(s.items) == 0 {
        var zero T
        return zero, false
    }

    item := s.items[len(s.items)-1]
    s.items = s.items[:len(s.items)-1]
    return item, true
}

// Usage
stringStack := NewStack[string]()
stringStack.Push("hello")
stringStack.Push("world")

intStack := NewStack[int]()
intStack.Push(1)
intStack.Push(2)
```

### Type Constraints

```go
// Numeric constraint
type Numeric interface {
    ~int | ~int64 | ~float64
}

func Sum[T Numeric](items []T) T {
    var sum T
    for _, item := range items {
        sum += item
    }
    return sum
}

// Comparable constraint
func Max[T comparable](a, b T) T {
    // Note: comparable doesn't support < or >
    // Use constraints.Ordered for comparisons
}

import "golang.org/x/exp/constraints"

func Max[T constraints.Ordered](a, b T) T {
    if a > b {
        return a
    }
    return b
}
```

### Generic Interfaces

```go
// Generic repository pattern
type Repository[T any, ID comparable] interface {
    Get(ctx context.Context, id ID) (*T, error)
    Create(ctx context.Context, entity *T) error
    Update(ctx context.Context, id ID, entity *T) error
    Delete(ctx context.Context, id ID) error
}

type UserRepository struct {
    db *sql.DB
}

func (r *UserRepository) Get(ctx context.Context, id string) (*User, error) {
    // Implementation
}

func (r *UserRepository) Create(ctx context.Context, user *User) error {
    // Implementation
}
```

## 14. Deployment & Distribution

### Building Binaries

```bash
# Build for current platform
go build -o myapp ./cmd/myapp

# Build for specific OS/architecture
GOOS=linux GOARCH=amd64 go build -o myapp-linux-amd64 ./cmd/myapp
GOOS=windows GOARCH=amd64 go build -o myapp-windows-amd64.exe ./cmd/myapp
GOOS=darwin GOARCH=arm64 go build -o myapp-darwin-arm64 ./cmd/myapp

# Build with version info
go build -ldflags "-X main.Version=$(git describe --tags)" -o myapp ./cmd/myapp

# Build optimized binary (smaller, faster)
go build -ldflags "-s -w" -o myapp ./cmd/myapp
# -s: omit symbol table and debug info
# -w: omit DWARF symbol table
```

### Docker Multi-Stage Build

```dockerfile
# Build stage
FROM golang:1.25-alpine AS builder

WORKDIR /build

# Copy go mod files
COPY go.mod go.sum ./
RUN go mod download

# Copy source
COPY . .

# Build binary
RUN CGO_ENABLED=0 GOOS=linux go build -ldflags="-s -w" -o myapp ./cmd/myapp

# Runtime stage
FROM alpine:latest

RUN apk --no-cache add ca-certificates

WORKDIR /app

# Copy binary from builder
COPY --from=builder /build/myapp .

# Run as non-root user
RUN addgroup -g 1000 appuser && \
    adduser -D -u 1000 -G appuser appuser
USER appuser

EXPOSE 8080

CMD ["./myapp"]
```

### CI/CD with GitHub Actions

```yaml
name: Build and Test

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version: '1.25'
          cache: true

      - run: go mod download
      - run: go test -race -coverprofile=coverage.out ./...
      - run: go vet ./...
      - run: golangci-lint run
      - run: govulncheck ./...

  build:
    needs: test
    runs-on: ubuntu-latest
    strategy:
      matrix:
        os: [linux, windows, darwin]
        arch: [amd64, arm64]
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version: '1.25'

      - name: Build
        env:
          GOOS: ${{ matrix.os }}
          GOARCH: ${{ matrix.arch }}
        run: |
          go build -ldflags "-s -w" -o myapp-${{ matrix.os }}-${{ matrix.arch }} ./cmd/myapp

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: myapp-${{ matrix.os }}-${{ matrix.arch }}
          path: myapp-${{ matrix.os }}-${{ matrix.arch }}
```

### Version Management

```go
package main

import (
    "fmt"
    "runtime"
)

var (
    Version   = "dev"
    BuildTime = "unknown"
    GitCommit = "unknown"
)

func printVersion() {
    fmt.Printf("Version: %s\n", Version)
    fmt.Printf("Build Time: %s\n", BuildTime)
    fmt.Printf("Git Commit: %s\n", GitCommit)
    fmt.Printf("Go Version: %s\n", runtime.Version())
    fmt.Printf("OS/Arch: %s/%s\n", runtime.GOOS, runtime.GOARCH)
}
```

## 15. Documentation

- **Package Docs**: Capture purpose in `doc.go`
- **Exported Items**: Every exported item gets a comment
- **Concurrency Contracts**: Document goroutine-safety

```go
// Package user provides user management functionality.
package user

// User represents a user in the system.
type User struct {
    ID   string
    Name string
}

// GetUser retrieves a user by ID.
// It returns ErrNotFound if the user doesn't exist.
func GetUser(ctx context.Context, id string) (*User, error) {
    // ...
}
```

---

## 16. Comprehensive Example Application

Complete example demonstrating idiomatic Go patterns:

```go
package main

import (
    "context"
    "encoding/json"
    "errors"
    "flag"
    "fmt"
    "log"
    "log/slog"
    "net/http"
    "os"
    "os/signal"
    "sync"
    "syscall"
    "time"
)

// Domain models
type User struct {
    ID    string    `json:"id"`
    Name  string    `json:"name"`
    Email string    `json:"email"`
    CreatedAt time.Time `json:"created_at"`
}

// Repository interface (small, focused)
type UserRepository interface {
    GetUser(ctx context.Context, id string) (*User, error)
    CreateUser(ctx context.Context, user *User) error
}

// In-memory implementation
type InMemoryUserRepo struct {
    mu    sync.RWMutex
    users map[string]*User
}

func NewInMemoryUserRepo() *InMemoryUserRepo {
    return &InMemoryUserRepo{
        users: make(map[string]*User),
    }
}

func (r *InMemoryUserRepo) GetUser(ctx context.Context, id string) (*User, error) {
    r.mu.RLock()
    defer r.mu.RUnlock()

    select {
    case <-ctx.Done():
        return nil, ctx.Err()
    default:
    }

    user, ok := r.users[id]
    if !ok {
        return nil, ErrNotFound
    }
    return user, nil
}

func (r *InMemoryUserRepo) CreateUser(ctx context.Context, user *User) error {
    r.mu.Lock()
    defer r.mu.Unlock()

    select {
    case <-ctx.Done():
        return ctx.Err()
    default:
    }

    if _, exists := r.users[user.ID]; exists {
        return fmt.Errorf("user already exists: %w", ErrConflict)
    }

    r.users[user.ID] = user
    return nil
}

// Errors
var (
    ErrNotFound = errors.New("user not found")
    ErrConflict = errors.New("resource conflict")
)

// Service layer
type UserService struct {
    repo   UserRepository
    logger *slog.Logger
}

func NewUserService(repo UserRepository, logger *slog.Logger) *UserService {
    return &UserService{
        repo:   repo,
        logger: logger,
    }
}

func (s *UserService) GetUser(ctx context.Context, id string) (*User, error) {
    s.logger.Info("getting user", "user_id", id)

    user, err := s.repo.GetUser(ctx, id)
    if err != nil {
        if errors.Is(err, ErrNotFound) {
            s.logger.Warn("user not found", "user_id", id)
            return nil, fmt.Errorf("user %s not found: %w", id, err)
        }
        s.logger.Error("failed to get user", "error", err, "user_id", id)
        return nil, fmt.Errorf("failed to get user: %w", err)
    }

    return user, nil
}

func (s *UserService) CreateUser(ctx context.Context, user *User) error {
    s.logger.Info("creating user", "user_id", user.ID)

    if err := s.repo.CreateUser(ctx, user); err != nil {
        if errors.Is(err, ErrConflict) {
            s.logger.Warn("user already exists", "user_id", user.ID)
            return fmt.Errorf("user already exists: %w", err)
        }
        s.logger.Error("failed to create user", "error", err, "user_id", user.ID)
        return fmt.Errorf("failed to create user: %w", err)
    }

    s.logger.Info("user created", "user_id", user.ID)
    return nil
}

// HTTP handlers
type UserHandler struct {
    service *UserService
    logger  *slog.Logger
}

func NewUserHandler(service *UserService, logger *slog.Logger) *UserHandler {
    return &UserHandler{
        service: service,
        logger:  logger,
    }
}

func (h *UserHandler) GetUser(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    id := r.URL.Query().Get("id")

    if id == "" {
        http.Error(w, "id parameter required", http.StatusBadRequest)
        return
    }

    user, err := h.service.GetUser(ctx, id)
    if err != nil {
        if errors.Is(err, ErrNotFound) {
            http.Error(w, err.Error(), http.StatusNotFound)
            return
        }
        h.logger.Error("handler error", "error", err)
        http.Error(w, "internal server error", http.StatusInternalServerError)
        return
    }

    w.Header().Set("Content-Type", "application/json")
    if err := json.NewEncoder(w).Encode(user); err != nil {
        h.logger.Error("failed to encode response", "error", err)
    }
}

func (h *UserHandler) CreateUser(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()

    var user User
    if err := json.NewDecoder(r.Body).Decode(&user); err != nil {
        http.Error(w, "invalid request body", http.StatusBadRequest)
        return
    }

    if user.ID == "" || user.Name == "" || user.Email == "" {
        http.Error(w, "id, name, and email are required", http.StatusBadRequest)
        return
    }

    user.CreatedAt = time.Now()

    if err := h.service.CreateUser(ctx, &user); err != nil {
        if errors.Is(err, ErrConflict) {
            http.Error(w, err.Error(), http.StatusConflict)
            return
        }
        h.logger.Error("handler error", "error", err)
        http.Error(w, "internal server error", http.StatusInternalServerError)
        return
    }

    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusCreated)
    if err := json.NewEncoder(w).Encode(user); err != nil {
        h.logger.Error("failed to encode response", "error", err)
    }
}

// Middleware
func loggingMiddleware(logger *slog.Logger, next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()

        next.ServeHTTP(w, r)

        logger.Info("request completed",
            "method", r.Method,
            "path", r.URL.Path,
            "duration_ms", time.Since(start).Milliseconds(),
        )
    })
}

// Server
type Server struct {
    httpServer *http.Server
    logger     *slog.Logger
}

func NewServer(addr string, handler http.Handler, logger *slog.Logger) *Server {
    return &Server{
        httpServer: &http.Server{
            Addr:         addr,
            Handler:      handler,
            ReadTimeout:  15 * time.Second,
            WriteTimeout: 15 * time.Second,
            IdleTimeout:  60 * time.Second,
        },
        logger: logger,
    }
}

func (s *Server) Start() error {
    s.logger.Info("starting server", "addr", s.httpServer.Addr)
    return s.httpServer.ListenAndServe()
}

func (s *Server) Shutdown(ctx context.Context) error {
    s.logger.Info("shutting down server")
    return s.httpServer.Shutdown(ctx)
}

// Main
func main() {
    var (
        addr     = flag.String("addr", ":8080", "server address")
        logLevel = flag.String("log-level", "info", "log level (debug, info, warn, error)")
    )
    flag.Parse()

    // Logger setup
    logger := setupLogger(*logLevel)

    // Initialize dependencies
    repo := NewInMemoryUserRepo()
    service := NewUserService(repo, logger)
    handler := NewUserHandler(service, logger)

    // Router
    mux := http.NewServeMux()
    mux.HandleFunc("/user", func(w http.ResponseWriter, r *http.Request) {
        switch r.Method {
        case http.MethodGet:
            handler.GetUser(w, r)
        case http.MethodPost:
            handler.CreateUser(w, r)
        default:
            http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
        }
    })

    // Apply middleware
    wrappedMux := loggingMiddleware(logger, mux)

    // Create server
    server := NewServer(*addr, wrappedMux, logger)

    // Graceful shutdown
    ctx, cancel := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
    defer cancel()

    // Start server in goroutine
    errCh := make(chan error, 1)
    go func() {
        if err := server.Start(); err != nil && !errors.Is(err, http.ErrServerClosed) {
            errCh <- err
        }
    }()

    // Wait for shutdown signal
    select {
    case <-ctx.Done():
        logger.Info("shutdown signal received")
        shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer shutdownCancel()

        if err := server.Shutdown(shutdownCtx); err != nil {
            logger.Error("shutdown error", "error", err)
        }
    case err := <-errCh:
        logger.Error("server error", "error", err)
        os.Exit(1)
    }

    logger.Info("server stopped")
}

func setupLogger(level string) *slog.Logger {
    var logLevel slog.Level
    switch level {
    case "debug":
        logLevel = slog.LevelDebug
    case "info":
        logLevel = slog.LevelInfo
    case "warn":
        logLevel = slog.LevelWarn
    case "error":
        logLevel = slog.LevelError
    default:
        logLevel = slog.LevelInfo
    }

    opts := &slog.HandlerOptions{
        Level: logLevel,
    }

    handler := slog.NewJSONHandler(os.Stdout, opts)
    return slog.New(handler)
}
```

**Key Patterns Demonstrated:**

- ✅ Error handling with wrapping and sentinel errors
- ✅ Context propagation for cancellation
- ✅ Interface-based design (small interfaces)
- ✅ Repository pattern
- ✅ Service layer separation
- ✅ HTTP handlers with proper error responses
- ✅ Middleware pattern
- ✅ Graceful shutdown
- ✅ Structured logging
- ✅ Mutex for thread-safe operations
- ✅ Dependency injection
- ✅ Command-line flags
- ✅ Zero value useful (sync.RWMutex)

---

## Anti-Patterns (Automatic Rejection)

### Critical
-  Panic/recover as control flow ("Don't panic" - use errors for normal error handling)
-  Goroutines without lifecycle management
-  Swallowed errors ("Don't just check errors, handle them gracefully")
-  Global mutable state
-  Logging secrets/PII
-  Zero values that require initialization to be safe ("Make the zero value useful")

### Code Smells
-  Channels for simple mutual exclusion (use mutexes)
-  Reflection/unsafe without benchmarks ("Reflection is never clear")
-  "God" interfaces ("The bigger the interface, the weaker the abstraction")
-  Premature abstraction ("A little copying is better than a little dependency")
-  Missing context propagation
-  Using `interface{}` when generics or specific types would work ("interface{} says nothing")
-  Clever code over clear code ("Clear is better than clever")
-  Zero values that require initialization to be safe ("Make the zero value useful")

---

**Context Matters**: These rules optimize for long-lived production services. A one-off script has different needs than a high-traffic API. Deviations are fine when justified and intentional.

**Go Version**: 1.25+
