---
title: Python Code Review & Enhancement Guidelines
description: Opinionated, performance- and security-minded Python rules for generation and review.
priority: 160
alwaysApply: false
files:
  include:
    - "**/*.py"
    - "pyproject.toml"
    - "uv.lock"
    - "requirements*.txt"
    - ".pre-commit-config.yaml"
---

## Guiding Principle
Apply features only when they add clarity, correctness, performance, or security. Prefer simple, intentional solutions (DRY, KISS, YAGNI, Fail Fast).

## 0) AI Assistant Guidelines

When providing code assistance, follow these guardrails:

- **Avoid Over-Engineering**: Do not recommend `boto3` client caching, `async/await`, `threading`, `multiprocessing`, or other advanced concurrency patterns unless the user explicitly requests them or performance bottlenecks are evident.
- **Keep It Simple**: Prefer straightforward solutions using standard library features over complex architectures.
- **Testing Guidance**: Suggest appropriate tests or improvements to existing test coverage when reviewing code.
- **Explain Trade-offs**: When proposing optimizations or refactoring, clearly explain the benefits and costs (complexity, maintenance, performance).
- **Respect Context**: Analyze the provided code and suggest improvements that align with its scope and purpose—don't transform a 20-line script into a 200-line framework.

## 1) Standards

- **Shebang:** `#!/usr/bin/env -S uv run` (preferred) or `#!/usr/bin/env python3`.
- **Python Version:** ≥ 3.12.
- **Formatting:** 4-space indents; soft wrap at 120 chars (adhere to PEP 8, PEP 257, PEP 484).
- **Linting:** Run `black`, `ruff`, and `pylint`. Aim for a score of ≥9.0 on `pylint`.
- **String Formatting:** Use double quotes `"` unless the string contains double quotes (use `'` then). `black` handles this.
- **Imports:** Grouped: stdlib / third-party / local. Sorted alphabetically within groups. Separate groups with blank lines.
- **Documentation:**
  - Google-style docstrings for all functions, classes, methods.
  - Module docstring immediately below shebang (leave space between shebang and docstring).
  - Include workflow with numbered steps if applicable.
  - Add usage syntax guide with command-line examples (not needed for Lambda).
  - Inline comments for complex logic.
- **Type Hints:** Strict typing required. Use Python 3.12 built-in types:
    - `Dict` → `dict`
    - `List` → `list`
    - `Tuple` → `tuple`
    - `Set` → `set`
    - `Union[X, Y]` → `X | Y`
    - `Optional[X]` → `X | None`
- **Type Checking:** Enable strict mode (`mypy --strict`, `pyright`, or `pyre`) where appropriate. Use `NewType`, `TypedDict`, or `TypeAlias` for specificity.
- **Dependencies:** Prefer `uv` for package management. Introduce third-party libraries only when needed—stick to stdlib otherwise.
- **Circular Imports:** Avoid by restructuring (move shared logic to separate module).
- **Local Libraries:** Use `aws_utils.py`, `cloudflare_utils.py`, `utils.py` for common tasks to avoid duplication.

## 1a) Package Management (uv)

**Prefer `uv` for new projects** - Fast, modern Python package installer and resolver.

**Installation:**
```bash
curl -LsSf https://astral.sh/uv/install.sh | sh
```

**Project Setup:**
```bash
uv init my-project
uv sync
```

**Benefits:** 10-100x faster, deterministic resolution, drop-in pip replacement.

## 2) Code Structure & Readability

- **Function Order:** Order functions by call hierarchy. Helper functions first, `main()` last.
- **Entry Point:** Always use `if __name__ == "__main__":` to call the main function.
- **Small Functions:** Break code into small, reusable functions with meaningful verb-based names.
- **Defensive Programming:** Validate inputs early (fail-fast). Use specific checks (`if x is None`) over broad `try/except`.
- **Meaningful Naming:** Use `fetch_user_details` (not `get`) or `order_total` (not `ot`).
- **No Mutable Defaults:** Avoid `def foo(bar=[])`. Use `def foo(bar: list[str] | None = None): bar = bar or []`.

## 3) Modern Python & Advanced Features

### Core Language Features
- **f-strings:** Use `f"User: {user_name}"` for formatting. Python 3.12: `f"{text!r}"` for debugging.
- **Exception Handling:** Use `try-except-else-finally` for complex flows.
- **Assertions:** Use `assert stock >= 0, "Stock cannot be negative"` for development—not production.
- **Comprehensions:** Use `[price * 2 for price in prices]` where clear—avoid if it reduces readability.
- **Walrus Operator (`:=`):** Use `if (count := len(items)) > 5:` for inline assignments—don't force it.
- **match-case:** Simplify complex conditionals:
  ```python
  def handle_response(code: int) -> str:
      match code:
          case 200: return "Success"
          case 400 | 404: return "Client Error"
          case _: return "Unknown"
  ```
- **Literal Types:** Use `status: Literal["active", "inactive"]` for fixed values.
- **Type Safety:** Use `isinstance` and `issubclass` for safe type checks.

### Functional Programming
- **`functools.wraps`:** Preserve metadata in decorators.
- **`functools.cache`:** Use `@functools.cache` for costly, repeated calls.
- **`functools.partial`:** Pre-specify function arguments: `partial(multiply, 2)`.
- **`functools.singledispatch`:** Polymorphic functions based on type.
- **`functools.total_ordering`:** Reduce comparison method boilerplate.
- **map/filter/reduce:** Use where readable—prefer comprehensions otherwise.

### Data Structures
- **dataclasses:** Use for data-centric classes:
  ```python
  from dataclasses import dataclass, field
  @dataclass
  class Product:
      product_id: int
      tags: list[str] = field(default_factory=list)
  ```
- **`collections`:** Use `Counter`, `deque`, `defaultdict`, `namedtuple` where appropriate.
- **Tuple Unpacking:** Use `x, y = get_coordinates()` for cleaner code.
- **`enumerate`:** Use `for idx, value in enumerate(values):` for indexed loops.

### Object-Oriented Features
- **`@property`:** Use for validation or computed properties:
  ```python
  @property
  def total(self) -> float:
      return self._total
  @total.setter
  def total(self, value: float) -> None:
      if value < 0: raise ValueError("Total cannot be negative")
      self._total = value
  ```
- **Abstract Base Classes (ABC):** Define interfaces:
  ```python
  from abc import ABC, abstractmethod
  class DataWriter(ABC):
      @abstractmethod
      def write(self, data: str) -> None: ...
  ```
- **Protocols:** Use for structural typing (duck typing).
- **MetaClasses:** Use for advanced class customization (e.g., Singleton pattern).
- **`@classmethod`/`@staticmethod`:** Use for utility/factory methods.
- **Magic Methods:** Implement `__str__`, `__repr__`, `__eq__`, etc., for Pythonic behavior.

### Context Managers
- **Built-in:** Use `with` for file handling, network connections.
- **Custom:** Create with `contextlib`:
  ```python
  from contextlib import contextmanager
  @contextmanager
  def database_connection(db_name: str):
      logger.info(f"Connecting to {db_name}")
      yield
      logger.info("Disconnected")
  ```

### Text Processing
- **`dedent` from textwrap:** Remove leading whitespace for SQL queries, templates:
  ```python
  from textwrap import dedent
  query = dedent("""
      SELECT * FROM users
      WHERE age > 18
  """)
  ```
- **`re` module:** Validate inputs to prevent injection attacks.

## 4) Logging & Observability

- **Setup:** Use a custom logger setup function at the start of scripts.
- **Pattern:**
  ```python
  import logging
  import time

  def setup_custom_logger(name: str) -> logging.Logger:
      """Create and configure a logger with UTC timestamps."""
      logger = logging.getLogger(name)
      logger.setLevel(logging.DEBUG)

      class UTCFormatter(logging.Formatter):
          converter = time.gmtime

      formatter = UTCFormatter(
          "%(asctime)s - %(levelname)s - %(message)s",
          datefmt="%c %Z"
      )

      if not logger.handlers:
          handler = logging.StreamHandler()
          handler.setFormatter(formatter)
          logger.addHandler(handler)
      return logger

  logger = setup_custom_logger(__name__)
  ```
- **Structured Logging:** Use `loguru` or JSON format for observability pipelines where needed.
- **Error Logging:** Include `exc_info=True` for tracebacks: `logger.error("Error", exc_info=True)`.

## 5) Security & Validation

- **Input Validation:** Sanitize early with `re.match(r"^\w+$", user_input)`.
- **SQL Injection:** Use parameterized queries: `cursor.execute("SELECT * FROM users WHERE id = %s", (user_id,))`.
- **Shell Sanitization:** Use `shlex.quote(user_input)` for shell commands.
- **Pydantic:** Use for structured data validation:
  ```python
  from pydantic import BaseModel, field_validator
  class User(BaseModel):
      name: str
      age: int
      @field_validator("age")
      @classmethod
      def valid_age(cls, v: int) -> int:
          if v < 0 or v > 150: raise ValueError("Invalid age")
          return v
  ```
- **Avoid Broad Exceptions:** Catch specific exceptions (`ValueError`, `KeyError`) instead of bare `except Exception`.

## 6) Error Handling & Resilience

- **Exception Groups:** For batch operations:
  ```python
  from exceptiongroup import ExceptionGroup
  errors = []
  for item in items:
      try:
          process(item)
      except Exception as e:
          errors.append(e)
  if errors:
      raise ExceptionGroup("Batch failed", errors)
  ```
- **Retry Libraries:** Use `tenacity`, `backoff`, or `retrying` for transient failures:
  ```python
  from tenacity import retry, stop_after_attempt, wait_exponential
  @retry(stop=stop_after_attempt(3), wait=wait_exponential(min=1, max=10))
  def fetch_data(): ...
  ```
- **Custom Exceptions:** Define `class FileProcessingError(Exception): pass` for clarity.
- **Warnings Module:** Use for non-critical issues: `warnings.warn("Deprecated", DeprecationWarning)`.

## 7) Performance Optimization

- **Profiling:** Use `cProfile`, `line_profiler`, or `memory_profiler` to identify bottlenecks.
- **Generators:** Use `yield` for large datasets to save memory.
- **Session Reuse:** Use `requests.Session()` for multiple API calls.
- **Concurrency:**
  - **`asyncio`:** For I/O-bound tasks.
  - **`threading`:** For I/O-bound with blocking libraries.
  - **`multiprocessing`:** For CPU-bound tasks.
- **Speed Boosts:** Use `numba` or `cython` for performance-critical loops (if profiling justifies).
- **Efficient Lookups:** Use `set` for O(1) lookups, `heapq` for priority queues, `bisect` for sorted lists.
- **Parallel Computing:** Use `ray` or `dask` for distributed workloads if needed.
- **Complexity Analysis:** Avoid O(n²) loops—refactor with better data structures.

## 8) AWS & Boto3 Best Practices

### Client Configuration
- **Global Initialization:** In Lambda, create `boto3` clients globally (outside handler) to reuse across invocations:
  ```python
  import boto3
  from botocore.config import Config

  boto_config = Config(
      retries={"max_attempts": 5, "mode": "standard"},
      connect_timeout=5,
      read_timeout=30
  )

  s3_client = boto3.client("s3", config=boto_config, region_name="us-east-1")
  ```
- **Region Handling:** Retrieve from `AWS_REGION` env var, default to `us-east-1`, allow override via parameter.
- **Client Factory:** Create reusable factory function:
  ```python
  def create_boto3_client(service_name: str, region_name: str, **kwargs) -> boto3.client:
      try:
          config = Config(retries={"max_attempts": 5, "mode": "standard"})
          client = boto3.client(service_name, region_name=region_name, config=config, **kwargs)
          logger.info(f"Created boto3 client for {service_name} in {region_name}")
          return client
      except (BotoCoreError, ClientError) as e:
          logger.error(f"Failed to create boto3 client: {e}")
          raise
  ```

### Error Handling
- **Specific Exceptions:** Catch `botocore.exceptions.ClientError`, `ResourceNotFoundError`, etc.
- **Error Codes:** Check `e.response['Error']['Code']` for specific AWS errors.

### Pagination & Waiters
- **Paginators:** Use for large result sets:
  ```python
  paginator = s3_client.get_paginator("list_objects_v2")
  for page in paginator.paginate(Bucket="my-bucket"):
      for obj in page.get("Contents", []):
          process(obj)
  ```
- **NextToken:** Handle manually if paginator unavailable.
- **Waiters:** Pause until resource is ready:
  ```python
  waiter = ec2_client.get_waiter("instance_running")
  waiter.wait(InstanceIds=["i-123456"])
  ```

### Lambda Patterns

**Global Scope Pattern (Recommended):**
```python
import boto3
import os
from botocore.config import Config

# ✅ CORRECT: Create clients in global scope (outside handler)
boto_config = Config(
    retries={"max_attempts": 10, "mode": "adaptive"},
    connect_timeout=5,
    read_timeout=30,
)

region = os.environ["AWS_REGION"]
s3_client = boto3.client("s3", config=boto_config, region_name=region)
dynamodb_client = boto3.client("dynamodb", config=boto_config, region_name=region)

def lambda_handler(event: dict[str, Any], context: Any) -> dict[str, Any]:
    """Lambda handler reuses clients from global scope."""
    response = s3_client.list_buckets()
    return {"statusCode": 200, "body": "Success"}
```

**❌ Anti-Patterns:**
```python
# ❌ WRONG: Creates new client on every invocation (cold start penalty)
def lambda_handler(event: dict[str, Any], context: Any) -> dict[str, Any]:
    s3_client = boto3.client("s3")  # Bad: Recreated every time
    return {"statusCode": 200}

# ❌ WRONG: Ties client lifecycle to class instance
class S3Manager:
    def __init__(self):
        self.s3_client = boto3.client("s3")  # Bad
```

**Cold Start Optimization:**
```python
# ✅ Lazy initialization for rarely-used clients
_sns_client: Any = None

def get_sns_client() -> Any:
    """Lazy-load SNS client only when needed."""
    global _sns_client
    if _sns_client is None:
        _sns_client = boto3.client("sns")
    return _sns_client

# ✅ Always-needed clients in global scope
s3_client = boto3.client("s3")  # Frequently used

def lambda_handler(event: dict[str, Any], context: Any) -> dict[str, Any]:
    s3_client.list_buckets()  # Always available

    if event.get("notify"):
        sns = get_sns_client()  # Loaded only if needed
        sns.publish(TopicArn="...", Message="...")

    return {"statusCode": 200}
```

**AWS Lambda Powertools (Observability):**
```python
from aws_lambda_powertools import Logger, Tracer, Metrics
from aws_lambda_powertools.metrics import MetricUnit
from typing import Any

logger = Logger()
tracer = Tracer()
metrics = Metrics()

@tracer.capture_lambda_handler
@logger.inject_lambda_context(log_event=True)
@metrics.log_metrics(capture_cold_start_metric=True)
def lambda_handler(event: dict[str, Any], context: Any) -> dict[str, Any]:
    """Lambda handler with full observability."""
    logger.info("Processing request", extra={"request_id": event.get("requestId")})
    metrics.add_metric(name="ItemsProcessed", unit=MetricUnit.Count, value=10)
    result = process_items(event["items"])
    return {"statusCode": 200, "body": result}

@tracer.capture_method
def process_items(items: list[str]) -> str:
    """Process items with automatic tracing."""
    logger.info(f"Processing {len(items)} items")
    return "success"
```

**Lambda Best Practices:**
- **Handler Placement:** Place `lambda_handler` at end of file.
- **Clients as Parameters:** Pass clients to functions (don't recreate inside functions).
- **Correlation ID:** Use `context.aws_request_id` for tracing.
- **Handler Signature:** Use `def lambda_handler(event: dict[str, Any], _) -> dict[str, Any]:` when context unused.
- **Dry-Run Mode:** Add flag to preview actions: `if event.get("dry_run"): logger.info(f"Would perform: {action}")`.

### Region Validation
```python
def validate_region(region: str) -> str:
    """Validate AWS region against allowed list."""
    allowed_regions = [
        "us-east-1", "us-west-2", "us-east-2", "ca-central-1",
        "eu-west-1", "eu-west-2", "eu-central-1", "eu-north-1",
        "ap-southeast-1", "ap-southeast-2"
    ]
    if region not in allowed_regions:
        raise ValueError(f"Invalid region: {region}. Allowed: {allowed_regions}")
    return region
```

## 9) Testing & Quality

- **pytest:** Write tests for reliability:
  ```python
  def test_parse():
      assert parse_input("123") == 123
  ```
- **Mocking:** Use `unittest.mock.patch` or `pytest-mock` for external dependencies.
- **Parameterized Tests:** Use `@pytest.mark.parametrize` for multiple inputs.
- **Test-Driven Development (TDD):** Write tests before implementation where appropriate.
- **Type Checking:** Run `mypy --strict` to catch type errors.

## 10) Data Handling & Integration

- **pandas:** Use for tabular data analysis: `df[df["sales"] > 100]`.
- **SQLAlchemy:** Use for database ORM if needed.
- **cerberus:** Alternative to Pydantic for simple validation.
- **jinja/jinjasql:** Use for templating (HTML, SQL, etc.).
- **httpx:** Modern async HTTP client (alternative to `requests`).
- **Message Brokers:** Integrate RabbitMQ/Kafka if event-driven architecture needed.

## 11) Code Structure & Architecture

- **SOLID Principles:**
  - **Single Responsibility:** One task per class/function.
  - **Open-Closed:** Extend, don't modify.
  - **Liskov Substitution:** Subclasses interchangeable.
  - **Interface Segregation:** Small, focused interfaces.
  - **Dependency Inversion:** Depend on abstractions, not concretions.
- **Separation of Concerns:** Use service/repository/handler pattern for layers.
- **Dependency Injection:** Pass dependencies as parameters for testability.
- **Plugin Architecture:** Enable extensions via registration:
  ```python
  plugins: dict[str, Callable] = {}
  def register_plugin(name: str, func: Callable) -> None:
      plugins[name] = func
  ```
- **Configuration Management:** Use `configparser`, `os.environ`, or `.env` files.
- **Feature Flags:** Implement toggles for gradual rollout.

## 11a) Design Patterns

Design patterns provide reusable solutions to common problems. Use them where they add clarity and maintainability—avoid forcing patterns where simple code suffices.

### Factory Method Pattern
Creates objects without specifying their exact class. Useful when object creation logic is complex or varies based on input.

```python
from typing import Protocol

class DatabaseConnection(Protocol):
    """Protocol for database connections."""
    def execute(self, query: str) -> list[dict]: ...

class PostgresConnection:
    def execute(self, query: str) -> list[dict]:
        return [{"result": "postgres_data"}]

class MySQLConnection:
    def execute(self, query: str) -> list[dict]:
        return [{"result": "mysql_data"}]

class DatabaseFactory:
    """Factory for creating database connections."""
    @staticmethod
    def create_connection(db_type: str) -> DatabaseConnection:
        match db_type.lower():
            case "postgres": return PostgresConnection()
            case "mysql": return MySQLConnection()
            case _: raise ValueError(f"Unsupported: {db_type}")
```

### Singleton Pattern
Ensures a class has only one instance. Useful for managing shared resources like boto3 clients, database connections, or configuration objects.

```python
from typing import Any

class SingletonMeta(type):
    """Metaclass that creates a Singleton base class."""
    _instances: dict[type, object] = {}

    def __call__(cls, *args: Any, **kwargs: Any) -> object:
        if cls not in cls._instances:
            cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]

class AWSClientManager(metaclass=SingletonMeta):
    """Singleton manager for AWS boto3 clients."""
    def __init__(self) -> None:
        self._clients: dict[str, Any] = {}

    def get_client(self, service: str, region: str = "us-east-1") -> Any:
        key = f"{service}:{region}"
        if key not in self._clients:
            self._clients[key] = boto3.client(service, region_name=region)
        return self._clients[key]

# Usage in Lambda or application code
aws_clients = AWSClientManager()
s3_client = aws_clients.get_client("s3", "us-east-1")
```

### Strategy Pattern
Defines a family of interchangeable algorithms. Useful for multi-region AWS operations or varying behaviors based on environment.

```python
from typing import Protocol

class DeploymentStrategy(Protocol):
    def deploy(self, application: str) -> None: ...

class DevelopmentDeployment:
    def deploy(self, application: str) -> None:
        print(f"Deploying {application} to dev (single instance)")

class ProductionDeployment:
    def deploy(self, application: str) -> None:
        print(f"Deploying {application} to prod (multi-AZ, auto-scaling)")

class DeploymentContext:
    def __init__(self, strategy: DeploymentStrategy) -> None:
        self._strategy = strategy

    def execute_deployment(self, application: str) -> None:
        self._strategy.deploy(application)
```

## 12) CLI & User Experience

- **argparse:** Add CLI options:
  ```python
  parser = argparse.ArgumentParser()
  parser.add_argument("--dry-run", action="store_true")
  parser.add_argument("-v", "--verbose", action="count", default=0)
  ```
- **typer:** Modern CLI framework (alternative to argparse).
- **rich:** Rich text and progress bars:
  ```python
  from rich.console import Console
  console = Console()
  console.print("[bold green]Success![/bold green]")
  ```
- **tqdm:** Progress bars: `for item in tqdm(items): process(item)`.
- **colorama:** Colored output for diffs or status messages.

## 13) Deployment & Distribution

### Creating Installable Packages

**Basic Package Structure:**
```
my_utils/
├── my_utils/
│   ├── __init__.py
│   ├── aws_helper.py
│   └── validators.py
├── tests/
│   └── test_aws_helper.py
├── README.md
├── pyproject.toml
└── requirements.txt
```

**Modern Approach: pyproject.toml (Recommended):**
```toml
[build-system]
requires = ["setuptools>=61.0", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "my-utils"
version = "1.0.0"
description = "Common utility functions for AWS and validation"
readme = "README.md"
authors = [{name = "Your Name", email = "you@acme.com"}]
requires-python = ">=3.12"
dependencies = [
    "boto3>=1.28.0",
    "pydantic>=2.0.0",
]

[project.optional-dependencies]
dev = ["pytest>=7.0", "black", "ruff"]

[tool.setuptools.packages.find]
where = ["."]
```

**Installation Commands:**
```bash
# Development mode (editable install)
pip install -e .

# Production install
pip install .

# With optional dependencies
pip install -e ".[dev]"

# Build distribution
python -m build

# Upload to PyPI
python -m twine upload dist/*
```

**Best Practices:**
- **Version Management**: Use semantic versioning (MAJOR.MINOR.PATCH)
- **Dependencies**: Pin major versions, allow minor/patch updates (`boto3>=1.28.0,<2.0.0`)
- **Entry Points**: Add CLI commands via `[project.scripts]` in `pyproject.toml`
- **Documentation**: Include comprehensive README with usage examples
- **Testing**: Include tests and configure with `pytest.ini` or `pyproject.toml`

### Docker & CI/CD

- **Docker:** Use multi-stage builds:
  ```dockerfile
  FROM python:3.12 AS builder
  COPY requirements.txt .
  RUN pip install -r requirements.txt
  FROM python:3.12-slim
  COPY --from=builder /usr/local/lib/python3.12/site-packages/ /usr/local/lib/python3.12/site-packages/
  COPY . .
  CMD ["python", "main.py"]
  ```
- **Executables:** Use `PyInstaller` or `cx_Freeze` for standalone apps.
- **CI/CD:** Automate with GitHub Actions, GitLab CI, etc.

## 14) Timestamps

Use UTC-aware timestamps:
```python
from datetime import datetime, timezone
timestamp = datetime.now(timezone.utc).strftime("%Y%m%d_%H%M%S")
```

## 15) Dry-Run Mode

Simulate operations without executing:
```python
def update_records(records: dict, dry_run: bool = False) -> None:
    if dry_run:
        logger.info(f"Dry run: would update {records}")
        return
    # Actual update logic
```

## 16) Documentation Template

```python
#!/usr/bin/env -S uv run
"""
Module purpose and overview.

This script performs X by doing Y. It interacts with Z.

Workflow:
1. Load configuration
2. Validate inputs
3. Process data
4. Write results

Usage:
    python script.py --input data.json --output results.json
    python script.py --dry-run
"""

# Standard library
import logging

# Third-party
import requests

# Local
from utils import setup_custom_logger

def function_name(param: str) -> int:
    """
    Brief description of what the function does.

    Args:
        param (str): Description of parameter.

    Returns:
        int: Description of return value.

    Raises:
        ValueError: When param is invalid.
    """
    pass
```

## 17) Scaling Guidelines

- **Small Scripts (<50 lines):** Stick to basics—skip advanced features unless critical.
- **Medium Scripts (50–200 lines):** Add type hints, logging, small functions. Consider `argparse` or `Pydantic`.
- **Large Projects (>200 lines):** Use OOP, SOLID principles, plugins, deployment tools. Optimize with profiling/concurrency.

## 18) Example Script

```python
#!/usr/bin/env -S uv run
"""Process user data with logging, validation, and decorators.

This script demonstrates:
- Pydantic models with validation
- Structured logging with UTC timestamps
- Decorators for timing and retries
- CLI with --dry-run
- Error handling and input validation

Usage:
    python app.py --dry-run
"""

from __future__ import annotations

import argparse
import functools
import logging
import re
import sys
import time
from dataclasses import dataclass
from datetime import datetime, timezone
from typing import Callable, Iterable, Iterator, Any

from pydantic import BaseModel, ValidationError, field_validator


# -----------------------------
# Logging setup
# -----------------------------
def setup_custom_logger(name: str) -> logging.Logger:
    """Create and configure a logger with UTC timestamps."""
    logger = logging.getLogger(name)
    logger.setLevel(logging.INFO)

    class UTCFormatter(logging.Formatter):
        converter = time.gmtime

    formatter = UTCFormatter(
        "%(asctime)s - %(levelname)s - %(message)s",
        datefmt="%c %Z"
    )

    if not logger.handlers:
        handler = logging.StreamHandler(sys.stdout)
        handler.setFormatter(formatter)
        logger.addHandler(handler)
    return logger

logger = setup_custom_logger(__name__)


# -----------------------------
# Decorators
# -----------------------------
def timed(func: Callable) -> Callable:
    """Measure and log execution time."""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        start = time.perf_counter()
        try:
            return func(*args, **kwargs)
        finally:
            elapsed_ms = (time.perf_counter() - start) * 1000
            logger.info(f"Metric: timing_ms func={func.__name__} value={elapsed_ms:.2f}")
    return wrapper


def retry(max_attempts: int = 3, base_delay: float = 0.2, max_delay: float = 2.0) -> Callable:
    """Exponential backoff retry decorator."""
    def decorator(func: Callable) -> Callable:
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            attempt = 1
            delay = base_delay
            while True:
                try:
                    return func(*args, **kwargs)
                except Exception as exc:
                    if attempt >= max_attempts:
                        logger.error(f"Retry exhausted: {exc}", exc_info=True)
                        raise
                    logger.warning(f"Retry {attempt}/{max_attempts}: {exc}")
                    time.sleep(delay)
                    delay = min(delay * 2, max_delay)
                    attempt += 1
        return wrapper
    return decorator


# -----------------------------
# Data models
# -----------------------------
class User(BaseModel):
    """Validated user data model."""
    user_name: str
    user_age: int

    @field_validator("user_name")
    @classmethod
    def valid_name(cls, v: str) -> str:
        if not re.fullmatch(r"[A-Za-z0-9]+", v):
            raise ValueError("user_name must be alphanumeric")
        return v

    @field_validator("user_age")
    @classmethod
    def valid_age(cls, v: int) -> int:
        if v < 0 or v > 150:
            raise ValueError("user_age must be 0-150")
        return v


@dataclass(slots=True)
class ProcessResult:
    """Processing result with accepted and rejected users."""
    accepted: list[User]
    rejected: list[dict]


# -----------------------------
# Business logic
# -----------------------------
def _iter_users(raw: Iterable[dict]) -> Iterator[User]:
    """Yield validated users, logging validation errors."""
    for entry in raw:
        try:
            yield User(**entry)
        except ValidationError as e:
            logger.error(f"Validation error for {entry}: {e.errors()}")


@timed
def process_users(raw: Iterable[dict], *, dry_run: bool = False) -> ProcessResult:
    """Validate and process users."""
    accepted: list[User] = []
    rejected: list[dict] = []

    for user in _iter_users(raw):
        try:
            if dry_run:
                logger.info(f"Would process: {user}")
            else:
                logger.info(f"Processed: {user}")
            accepted.append(user)
        except Exception as exc:
            logger.error(f"Process error for {user}: {exc}", exc_info=True)
            rejected.append({"user": user.model_dump(), "error": str(exc)})

    return ProcessResult(accepted=accepted, rejected=rejected)


# -----------------------------
# CLI
# -----------------------------
def _parse_args(argv: list[str] | None = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Process user data with validation and logging."
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Log actions without executing them."
    )
    return parser.parse_args(argv)


def main(argv: list[str] | None = None) -> int:
    """Main entry point."""
    args = _parse_args(argv)
    timestamp = datetime.now(timezone.utc).strftime("%Y%m%d_%H%M%S")
    logger.info(f"Starting run at {timestamp}")

    # Example input
    raw_data: list[dict] = [
        {"user_name": "Alice123", "user_age": 25},
        {"user_name": "Bob!", "user_age": 30},  # Invalid name
        {"user_name": "Chad", "user_age": -5},  # Invalid age
    ]

    result = process_users(raw_data, dry_run=args.dry_run)
    logger.info(f"Summary: accepted={len(result.accepted)} rejected={len(result.rejected)}")

    return 0 if not result.rejected else 1


if __name__ == "__main__":
    sys.exit(main())
```

## 19) Quick Reference Checklist

Before finalizing code, verify:
- [ ] Shebang line present with `uv`
- [ ] Type hints on all functions/variables
- [ ] Google-style docstrings
- [ ] Imports grouped and sorted
- [ ] `if __name__ == "__main__":` guard
- [ ] Logging configured
- [ ] Input validation
- [ ] Error handling (specific exceptions)
- [ ] Security checks (SQL/shell sanitization)
- [ ] Tests written (if applicable)
- [ ] `black` and `ruff` pass
- [ ] `pylint` score ≥ 9.0
- [ ] Dry-run mode (if applicable)
- [ ] No mutable default arguments
- [ ] No bare `except:` clauses
- [ ] Lambda: Clients in global scope (not in handler)
- [ ] Lambda: AWS Lambda Powertools configured (if applicable)

## 20) Comprehensive Technique Reference

Where appropriate, use these techniques:

**Control Flow & Error Handling:**
- `try-except-else-finally`, `match-case`, Custom exceptions, `exceptiongroup`, Assertions

**String & Data Formatting:**
- `f-strings` (with `!r` for debugging), Context managers, Comprehensions, Tuple unpacking

**Type Safety & Validation:**
- Type annotations (Python 3.12 built-ins), `Literal` types, `Pydantic` models, `dataclasses`, `protocols`, `ABC`

**Functions & Decorators:**
- `*args`/`**kwargs`, `@property`/`getter`/`setter`, Custom decorators with `functools.wraps`, `functools.cache`, `functools.partial`, `functools.singledispatch`, `functools.total_ordering`

**Object-Oriented Programming:**
- Classes with encapsulation, `dataclasses`, `MetaClasses`, `@classmethod`/`@staticmethod`, Magic methods, Inheritance/composition

**Data Structures & Collections:**
- `defaultdict`, `Counter`, `deque`, `enum`, Generators (`yield`), Deep/shallow copying

**Performance & Concurrency:**
- `itertools`, `asyncio`, `threading`, `multiprocessing`, `requests.Session()`

**CLI & Configuration:**
- `argparse`, `os.environ`, `configparser`, Dry-run mode

**AWS & Cloud:**
- `boto3` client configuration, Global scope for Lambda, Paginators/waiters, Error handling (`ClientError` codes), `aws_lambda_powertools`

**Design Patterns:**
- Factory method, Singleton, Strategy, Decorator

**Testing & Quality:**
- `pytest`, `unittest.mock`, Profiling (`cProfile`, `memory_profiler`)

**Deployment:**
- Package creation (`pyproject.toml`), Docker multi-stage builds, CI/CD automation

---

**Last Updated**: December 2025
