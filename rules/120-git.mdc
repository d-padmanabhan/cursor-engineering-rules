---
title: Git & Commit Standards
description: Conventional commits, PR hygiene, branch naming, release notes, and foundational GitHub repository scaffolding requirements.
alwaysApply: true
priority: 120
---

# Git Fundamentals

## What is a Ref?

A **ref** (reference) is Git's way of creating human-readable names for commit hashes. Instead of remembering `a3f8b2c...`, you use names like `main` or `v1.2.3`.

Refs are bookmarks pointing to specific commits in your repository's history. They are stored as simple text files in `.git/refs/` containing a 40-character commit SHA.

## Types of Refs

| Ref Type | Location | Purpose |
|----------|----------|---------|
| Local branches | `refs/heads/main` | Track your local work |
| Remote-tracking branches | `refs/remotes/origin/main` | Your local copy of what the remote server has |
| Tags | `refs/tags/v1.2.3` | Permanent markers for releases |
| HEAD | `.git/HEAD` | Special pointer to wherever you are right now |

## The Three-Tier Model

Understanding the relationship between remote and local branches prevents confusion:

```
Remote branch (on server)     :  main
                                  ↓
Remote-tracking branch (local):  origin/main
                                  ↓
Local branch (your work)      :  main
```

**Key insight:** When you run `git fetch`, only the remote-tracking branch updates. Your local branch and working files remain untouched.

This is why you can safely inspect remote changes before integrating them:

```bash
git fetch origin
git log origin/main          # See what's new on remote
git diff origin/main         # Compare with your local state
git merge origin/main        # Integrate when ready
```

---

#  Commit Message Standards

**Goal:** clean, conventional, descriptive commits that communicate intent and feed changelogs.

## Format

```

<type>(<scope>): <short summary>

<bulleted list of key changes>

<optional explanatory paragraph>
```

* First line ≤ **72 chars**, imperative mood (“add”, “fix”, “update”).
* Bullets: start with a **capital letter**, **no period**.
* Add a short **rationale paragraph** when the change is non-obvious.
* Use issue refs when helpful (`Fixes #123`, `Refs #456`).

### Canonical Example

```
docs(upgrade): reorganize and enhance v3.4->v3.8 upgrade guide

- Prioritize ANF-disabled path (Path A)
- Add rationale for route table rotation logic
- Include Q-chat verification prompt
- Add ANF cost caution in Path B
- Remove duplicate ANF-disabled section
- Improve flow to reduce confusion

Improves upgrade experience by making common path primary and documenting motivation behind state changes.
```

---

## Commit Types (Conventional Commits)

| type         | purpose                             |
| ------------ | ----------------------------------- |
| **feat**     | new feature or enhancement          |
| **fix**      | bug fix                             |
| **docs**     | documentation changes               |
| **refactor** | restructure without behavior change |
| **perf**     | performance improvement             |
| **test**     | add/update tests                    |
| **ci**       | GitHub Actions / build infra        |
| **chore**    | dependencies, cleanup               |
| **revert**   | revert a previous commit            |

> **BREAKING CHANGES** require:
> `feat(api)!: ...` + footer:
>
> ```
> BREAKING CHANGE: renamed output vpc_id to lattice_vpc_id
> ```

---

## Scopes (suggested)

Use a concise noun oriented around the domain:

Example scopes:
`terraform`, `aws`, `gha`, `cli`, `lattice`, `cloudflare`, `module/<name>`, `docs`, `security`

> If working from a Jira branch: use the ticket as the scope (`PROJ-1234`)

Examples:

```
feat(terraform): add vpc lattice service network module
fix(gha): correct permissions for PR comment
perf(python): cache IAM role lookups
```

---

#  Commit Approval & User Confirmation

**CRITICAL:** AI agents must **NEVER** commit code without explicit user approval.

**Remote writes (default-deny):** By default, do **not** `git push`, open PRs, or take any action that modifies remote state.
Only perform remote writes when the user explicitly authorizes the specific operation, and record the authorization + commands + results in the audit report (see `060-agent-audit.mdc`).

## Pre-Commit Workflow

Before executing any `git commit` command:

1. **Show the complete commit message** in a formatted preview:

```
==================== COMMIT MESSAGE PREVIEW ====================
<type>(<scope>): <short summary>

- <change 1>
- <change 2>
- <change 3>

<optional explanatory paragraph>
================================================================
```

2. **Display files to be committed:**
```
Files to be committed:
  modified:   path/to/file1.py
  new file:   path/to/file2.md
  deleted:    path/to/file3.txt
```

3. **Ask for explicit confirmation:**
```
Should I proceed with this commit? (yes/no)
```

4. **Only execute** after receiving explicit user approval

## Example Interaction

```
I've prepared the following commit:

==================== COMMIT MESSAGE PREVIEW ====================
feat(communication): add 31 modern workplace phrases

- Add sync up, take it offline, level set phrases
- Add sanity check, gut check, smell test
- Add land the plane, spin up, heavy lift
- Add remote work terms (async, OOO, WFH)
- Add collaboration phrases (pick brain, have back)

Enhances workplace communication guide with commonly used
modern tech industry terminology.
================================================================

Files to be committed:
  modified:   100-ai/pdb/100a-communications-samples.md

Should I proceed with this commit? (yes/no)
```

**User must explicitly respond "yes" before commit executes.**

---

#  Branch & Merge Policy

## Branch Naming

```
<type>/<scope>-<short-topic>[-issue-<n>]
```

Examples:

```
feat/terraform-lattice-issue-421
fix/gha-permissions-pr-comment
docs/upgrade-guide-3-8
```

## History Hygiene

* Prefer small, logically cohesive commits
* Squash only noisy/WIP histories
* Rebase onto `main` before merge (unless policy forbids)
* Separate mechanical formatting from logical changes

---

# Fetch, Pull & Sync Patterns

## Fetch vs Pull

| Command | What It Does | Touches Working Tree? |
|---------|--------------|----------------------|
| `git fetch` | Downloads commits, updates remote-tracking refs | No |
| `git pull` | Fetch + merge (or rebase) into current branch | Yes |

**Why fetch is safer:** You can inspect what changed remotely before deciding to integrate. Fetch updates your "map" of the remote without changing your actual location or files.

## Always Prune Stale Refs

When branches are deleted on the remote, your local remote-tracking refs become stale "ghosts." Use `--prune` to clean them up:

```bash
git fetch origin --prune
```

**Recommended:** Enable automatic pruning globally:

```bash
git config --global fetch.prune true
```

Now every `git fetch` and `git pull` automatically removes stale remote-tracking branches.

> [!NOTE]
> `--prune` only removes remote-tracking branches (like `origin/feat-old`). It does NOT delete your local branches. Your local work is always safe.

## Robust Feature Branch Workflow

When creating a feature branch from an updated `main`, use this explicit pattern:

```bash
# Step 1: Download latest from remote, clean up deleted branches
git fetch origin --prune

# Step 2: Move to main branch explicitly
git switch main

# Step 3: Fast-forward only (refuses to create merge commits)
git pull --ff-only

# Step 4: Create and switch to feature branch
git switch -c feat/your-feature-name
```

**Why this pattern?**

| Step | Purpose |
|------|---------|
| `git fetch origin --prune` | Get latest state, clean stale refs |
| `git switch main` | Ensures you start from the right place |
| `git pull --ff-only` | Prevents accidental merge bubbles |
| `git switch -c` | Creates branch from now-updated main |

## Quick Alternative (With Caveats)

Skip your local `main` entirely by branching directly from `origin/main`:

```bash
git fetch origin --prune && git switch -c feat/your-feature origin/main
```

**Advantages:**
- Faster (one fewer step)
- Works even if your local `main` is in a weird state
- Guaranteed to start from remote's latest

**Use when:** Creating throwaway branches or when local `main` is messy.

## One-Liner (Legacy, Less Safe)

```bash
git pull origin main && git checkout -b feat/your-feature
```

**Downsides:**
- No guarantee you were on `main` first (can mix changes if on wrong branch)
- No `--ff-only` protection (could create merge commit)
- Uses `checkout` (works on older Git but less clear than `switch`)

---

# Modern Git Commands

Git 2.23+ split the multi-purpose `checkout` into focused commands for clarity and safety.

## `git switch` vs `git checkout`

| Old Command | New Command | Purpose |
|-------------|-------------|---------|
| `git checkout branch` | `git switch branch` | Switch branches |
| `git checkout -b new` | `git switch -c new` | Create and switch to new branch |
| `git checkout -- file` | `git restore file` | Restore file from index |
| `git checkout HEAD -- file` | `git restore -s HEAD file` | Restore file from commit |

**Why prefer `switch`?**

`checkout` is a multi-purpose tool that does many different things: switch branches, create branches, restore files, detach HEAD. When you see `git checkout somename`, you cannot immediately tell if it is switching to a branch, restoring a file, or going to a specific commit.

`switch` has one job: work with branches only. The intent is clear when you read it.

```bash
# Ambiguous - what does this do?
git checkout main.py

# Clear - restores the file
git restore main.py

# Clear - switches to branch (would error on file name collision)
git switch main
```

**Recommendation:** Use `git switch` and `git restore` for new work. Use `git checkout` only for older Git versions or compatibility scripts.

## `git mv` vs `mv`

| Command | What Happens | Git Awareness |
|---------|--------------|---------------|
| `mv old new` | Filesystem move only | Git sees delete + new file |
| `git mv old new` | Move + stage in one step | Git tracks as rename |

**Using `mv` (three commands):**
```bash
mv src/utils.js src/helpers.js
git add src/helpers.js
git rm src/utils.js
```

**Using `git mv` (one command):**
```bash
git mv src/utils.js src/helpers.js
```

Both end up in the same place, but `git mv` is cleaner and preserves rename history more reliably.

> [!TIP]
> If you `mv` a file and heavily modify it before committing, Git might not recognize it as a rename (it uses content similarity heuristics). Use `git mv` when you want history tracking preserved.

---

# Pre-Commit Hooks

## Why Pre-Commit?

Pre-commit hooks catch issues before they enter your commit history:

- Formatting errors (trailing whitespace, mixed line endings)
- Linting violations
- Security issues (leaked secrets, private keys)
- Large files that should not be committed
- Merge conflict markers left in code

## Manual Verification

Run hooks against all files before committing:

```bash
pre-commit run --all-files
```

Run against only staged files (faster):

```bash
pre-commit run
```

## Automatic Installation

Install hooks to run automatically on every commit:

```bash
pre-commit install
```

This creates a `.git/hooks/pre-commit` file that runs your configured checks.

## Keep Hooks Updated

Periodically update hook versions to get security fixes and improvements:

```bash
pre-commit autoupdate
```

> [!NOTE]
> If a commit fails due to pre-commit hook changes (e.g., auto-formatting), stage the changes and retry. Some hooks modify files in place to fix issues automatically.

---

#  Pull Request Standards

**PR Title** mirrors commit header:

```
<type>(<scope>): <concise summary>
```

**Body** must include:

* **What & Why**
* **Risk / Impact** (breaking changes, migrations)
* **Tests** (added/updated + any manual validation)
* **Screenshots or artifacts** where relevant (e.g., plan/apply output)
* **Linked Issues** (`Fixes #123`)

**Labels & Reviewers**: Ensure correct ownership and review coverage.

---

#  Sign-off & Security

* Signed commits if mandated by project
* DCO sign-off if required
* No secrets in commits, diffs, PRs, or screenshots
* Large binaries -> artifacts, not git

---

#  Repository Scaffolding & Hygiene

Every repo **must** contain the following foundational files with project-appropriate content:

| File                               | Requirement                                                           |
| ---------------------------------- | --------------------------------------------------------------------- |
| `.gitignore`                       | Based on language/framework presets (GitHub templates)                |
| `.editorconfig`                    | Enforce consistent indentation, LF, charset                           |
| `.gitattributes`                   | Normalize line endings, set diff behavior for binaries                |
| `.pre-commit-config.yaml`          | **Must include top-level `name:`** and proper language-specific hooks |
| `.markdownlint.yaml`               | Align with workspace Markdown rules                                   |
| `.commitlintrc.yaml`               | Enforce commit conventions                                            |
| `.dependabot.yaml`                 | Automated dependency update checks                                    |
| `.github/CODEOWNERS`               | Assign ownership to enforce review policy                             |
| `.github/PULL_REQUEST_TEMPLATE.md` | Enforce PR format above                                               |

> [!TIP]
> Add a periodic maintenance step like:
>
> ```
> pre-commit autoupdate
> ```
>
> to keep hooks updated.

---

### Repo Creation Checklist

* [ ] Meta files exist and follow best practices
* [ ] Pre-commit hooks enabled and documented
* [ ] Codeowners enforce mandatory reviews
* [ ] PR template references testing + security checks
* [ ] Dependabot and automation enabled as needed
* [ ] No secrets or credentials in history

---

#  Commit Examples

```
feat(terraform): add lattice service network module

- Create module with snake_case vars and pinned providers
- Add staging/prod examples
- Document IAM boundary and least privilege
```

```
fix(gha): correct issues:write for PR comment updates

- Permissions moved to job-level
- Add retry and missing-token fallback
```

```
perf(python): memoize sts.get_caller_identity result

- Add runtime cache using lru_cache
```

```
refactor(go): extract S3 client init

- Decouple AWS region/provider from business logic
- Add tests for timeout and retry config
```

---

#  Git Worktrees & Parallel Development

Git worktrees allow you to work on multiple branches simultaneously in separate directories. This is especially useful for:

- AI agents working on multiple features in parallel
- Reviewing PRs while continuing development
- Running long tests on one branch while coding on another
- Comparing implementations side-by-side

## Phantom (Recommended)

**Phantom** simplifies Git worktree management with intuitive commands and AI agent integration.

**Installation:**
```bash
brew install phantom
# or
npm install -g @aku11i/phantom
```

**Basic Usage:**
```bash
# Create a worktree for a new feature
phantom create feature-auth

# List all worktrees
phantom list

# Open shell in worktree
phantom shell feature-auth

# Run command in any worktree
phantom exec feature-auth npm test

# Open editor in worktree
phantom edit feature-auth

# Delete when done
phantom delete feature-auth
```

**AI Agent Integration:**

Phantom provides an MCP server for AI coding assistants to autonomously manage worktrees:

```bash
# Configure AI assistant
phantom preferences set ai claude

# Launch AI in worktree
phantom ai feature-auth
```

> [!TIP]
> For parallel AI development, configure the Phantom MCP server in your editor. AI agents can then create isolated worktrees for each feature, enabling true parallel development without branch conflicts.

**Editor Integration:**
```bash
# Configure preferred editor (stored in git config)
phantom preferences set editor "cursor --reuse-window"

# Open worktree in editor
phantom edit feature-auth
```

**GitHub Integration:**
```bash
# Create worktree from PR
phantom create --pr 123

# Create worktree from issue
phantom create --issue 456
```

---

#  Optional Tooling

* **commitlint** for CI validation of headers
* **auto-changelog** from conventional commits
* **actionlint** for `.github/workflows/**`
* **phantom** for Git worktree management and parallel development

---

#  Reviewer Checklist (copy/paste into PR)

* [ ] Correct type(scope) in title
* [ ] Summary ≤72 chars, imperative mood
* [ ] Bulleted change list included
* [ ] Rationale paragraph provided if non-obvious change
* [ ] Security reviewed; no secrets exposed
* [ ] Tests updated/added
* [ ] Repo scaffolding is compliant (for new repos)


---

